import {
  animate,
  state,
  style,
  transition,
  trigger
} from "./chunk-IIRQSIIO.js";
import {
  DefaultValueAccessor,
  FormsModule,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControlStatus,
  NgControlStatusGroup,
  NgForm,
  NgModel,
  Validators,
  ɵNgNoValidate
} from "./chunk-WZKEDKVK.js";
import {
  ActivatedRoute,
  NavigationEnd,
  Router,
  RouterLink,
  RouterLinkActive,
  RouterModule,
  RouterOutlet
} from "./chunk-NN7MDTWB.js";
import {
  DomSanitizer
} from "./chunk-2IJ3QWNU.js";
import {
  AsyncPipe,
  CommonModule,
  DOCUMENT,
  DatePipe,
  FormStyle,
  FormatWidth,
  Location,
  NgClass,
  NgForOf,
  NgIf,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  TranslationWidth,
  getLocaleDayNames,
  getLocaleFirstDayOfWeek,
  getLocaleMonthNames,
  getLocaleTimeFormat,
  isPlatformBrowser
} from "./chunk-H2OSWUDB.js";
import {
  ANIMATION_MODULE_TYPE,
  APP_ID,
  ApplicationRef,
  Attribute,
  CSP_NONCE,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InputFlags,
  IterableDiffers,
  LOCALE_ID,
  NgModule,
  NgZone,
  Optional,
  Output,
  PLATFORM_ID,
  Pipe,
  QueryList,
  Renderer2,
  SimpleChange,
  SkipSelf,
  TemplateRef,
  Type,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1,
  booleanAttribute,
  effect,
  forwardRef,
  inject,
  isDevMode,
  isSignal,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpureFunction1,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-TEAXYPYX.js";
import {
  BehaviorSubject,
  ConnectableObservable,
  EMPTY,
  Observable,
  ReplaySubject,
  Subject,
  Subscription,
  animationFrameScheduler,
  asapScheduler,
  auditTime,
  combineLatest,
  concat,
  debounceTime,
  delay,
  distinctUntilChanged,
  filter,
  finalize,
  forkJoin,
  from,
  fromEvent,
  interval,
  isObservable,
  map,
  merge,
  observeOn,
  of,
  pairwise,
  publish,
  refCount,
  repeat,
  share,
  shareReplay,
  skip,
  startWith,
  switchMap,
  take,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  timer
} from "./chunk-4J25ECOH.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-ASLTLD6L.js";

// node_modules/@angular/cdk/fesm2022/platform.mjs
var hasV8BreakIterator;
try {
  hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
} catch {
  hasV8BreakIterator = false;
}
var _Platform = class _Platform {
  constructor(_platformId) {
    this._platformId = _platformId;
    this.isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
    this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
    this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
    this.BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
    this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
    this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
    this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
    this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
    this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
  }
};
_Platform.ɵfac = function Platform_Factory(t) {
  return new (t || _Platform)(ɵɵinject(PLATFORM_ID));
};
_Platform.ɵprov = ɵɵdefineInjectable({
  token: _Platform,
  factory: _Platform.ɵfac,
  providedIn: "root"
});
var Platform = _Platform;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Platform, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], null);
})();
var _PlatformModule = class _PlatformModule {
};
_PlatformModule.ɵfac = function PlatformModule_Factory(t) {
  return new (t || _PlatformModule)();
};
_PlatformModule.ɵmod = ɵɵdefineNgModule({
  type: _PlatformModule
});
_PlatformModule.ɵinj = ɵɵdefineInjector({});
var PlatformModule = _PlatformModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var supportsPassiveEvents;
function supportsPassiveEventListeners() {
  if (supportsPassiveEvents == null && typeof window !== "undefined") {
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: () => supportsPassiveEvents = true
      }));
    } finally {
      supportsPassiveEvents = supportsPassiveEvents || false;
    }
  }
  return supportsPassiveEvents;
}
function normalizePassiveListenerOptions(options) {
  return supportsPassiveEventListeners() ? options : !!options.capture;
}
var RtlScrollAxisType;
(function(RtlScrollAxisType2) {
  RtlScrollAxisType2[RtlScrollAxisType2["NORMAL"] = 0] = "NORMAL";
  RtlScrollAxisType2[RtlScrollAxisType2["NEGATED"] = 1] = "NEGATED";
  RtlScrollAxisType2[RtlScrollAxisType2["INVERTED"] = 2] = "INVERTED";
})(RtlScrollAxisType || (RtlScrollAxisType = {}));
var rtlScrollAxisType;
var scrollBehaviorSupported;
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if ("scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return RtlScrollAxisType.NORMAL;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content = document.createElement("div");
    const contentStyle = content.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = RtlScrollAxisType.NORMAL;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}
var shadowDomIsSupported;
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getFocusedElementPierceShadowDom() {
  let activeElement = typeof document !== "undefined" && document ? document.activeElement : null;
  while (activeElement && activeElement.shadowRoot) {
    const newActiveElement = activeElement.shadowRoot.activeElement;
    if (newActiveElement === activeElement) {
      break;
    } else {
      activeElement = newActiveElement;
    }
  }
  return activeElement;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}
function _isTestEnvironment() {
  return (
    // @ts-ignore
    typeof __karma__ !== "undefined" && !!__karma__ || // @ts-ignore
    typeof jasmine !== "undefined" && !!jasmine || // @ts-ignore
    typeof jest !== "undefined" && !!jest || // @ts-ignore
    typeof Mocha !== "undefined" && !!Mocha
  );
}

// node_modules/@angular/cdk/fesm2022/keycodes.mjs
var BACKSPACE = 8;
var TAB = 9;
var ENTER = 13;
var SHIFT = 16;
var CONTROL = 17;
var ALT = 18;
var ESCAPE = 27;
var SPACE = 32;
var PAGE_UP = 33;
var PAGE_DOWN = 34;
var END = 35;
var HOME = 36;
var LEFT_ARROW = 37;
var UP_ARROW = 38;
var RIGHT_ARROW = 39;
var DOWN_ARROW = 40;
var DELETE = 46;
var ZERO = 48;
var NINE = 57;
var A = 65;
var Z = 90;
var META = 91;
var MAC_META = 224;
function hasModifierKey(event, ...modifiers) {
  if (modifiers.length) {
    return modifiers.some((modifier) => event[modifier]);
  }
  return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;
}

// node_modules/@angular/cdk/fesm2022/coercion.mjs
function coerceBooleanProperty(value) {
  return value != null && `${value}` !== "false";
}
function coerceNumberProperty(value, fallbackValue = 0) {
  return _isNumberValue(value) ? Number(value) : fallbackValue;
}
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}
function coerceCssPixelValue(value) {
  if (value == null) {
    return "";
  }
  return typeof value === "string" ? value : `${value}px`;
}
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}

// node_modules/@angular/cdk/fesm2022/observers.mjs
function shouldIgnoreRecord(record) {
  if (record.type === "characterData" && record.target instanceof Comment) {
    return true;
  }
  if (record.type === "childList") {
    for (let i = 0; i < record.addedNodes.length; i++) {
      if (!(record.addedNodes[i] instanceof Comment)) {
        return false;
      }
    }
    for (let i = 0; i < record.removedNodes.length; i++) {
      if (!(record.removedNodes[i] instanceof Comment)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var _MutationObserverFactory = class _MutationObserverFactory {
  create(callback) {
    return typeof MutationObserver === "undefined" ? null : new MutationObserver(callback);
  }
};
_MutationObserverFactory.ɵfac = function MutationObserverFactory_Factory(t) {
  return new (t || _MutationObserverFactory)();
};
_MutationObserverFactory.ɵprov = ɵɵdefineInjectable({
  token: _MutationObserverFactory,
  factory: _MutationObserverFactory.ɵfac,
  providedIn: "root"
});
var MutationObserverFactory = _MutationObserverFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MutationObserverFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _ContentObserver = class _ContentObserver {
  constructor(_mutationObserverFactory) {
    this._mutationObserverFactory = _mutationObserverFactory;
    this._observedElements = /* @__PURE__ */ new Map();
  }
  ngOnDestroy() {
    this._observedElements.forEach((_, element) => this._cleanupObserver(element));
  }
  observe(elementOrRef) {
    const element = coerceElement(elementOrRef);
    return new Observable((observer) => {
      const stream = this._observeElement(element);
      const subscription = stream.pipe(map((records) => records.filter((record) => !shouldIgnoreRecord(record))), filter((records) => !!records.length)).subscribe(observer);
      return () => {
        subscription.unsubscribe();
        this._unobserveElement(element);
      };
    });
  }
  /**
   * Observes the given element by using the existing MutationObserver if available, or creating a
   * new one if not.
   */
  _observeElement(element) {
    if (!this._observedElements.has(element)) {
      const stream = new Subject();
      const observer = this._mutationObserverFactory.create((mutations) => stream.next(mutations));
      if (observer) {
        observer.observe(element, {
          characterData: true,
          childList: true,
          subtree: true
        });
      }
      this._observedElements.set(element, {
        observer,
        stream,
        count: 1
      });
    } else {
      this._observedElements.get(element).count++;
    }
    return this._observedElements.get(element).stream;
  }
  /**
   * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
   * observing this element.
   */
  _unobserveElement(element) {
    if (this._observedElements.has(element)) {
      this._observedElements.get(element).count--;
      if (!this._observedElements.get(element).count) {
        this._cleanupObserver(element);
      }
    }
  }
  /** Clean up the underlying MutationObserver for the specified element. */
  _cleanupObserver(element) {
    if (this._observedElements.has(element)) {
      const {
        observer,
        stream
      } = this._observedElements.get(element);
      if (observer) {
        observer.disconnect();
      }
      stream.complete();
      this._observedElements.delete(element);
    }
  }
};
_ContentObserver.ɵfac = function ContentObserver_Factory(t) {
  return new (t || _ContentObserver)(ɵɵinject(MutationObserverFactory));
};
_ContentObserver.ɵprov = ɵɵdefineInjectable({
  token: _ContentObserver,
  factory: _ContentObserver.ɵfac,
  providedIn: "root"
});
var ContentObserver = _ContentObserver;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: MutationObserverFactory
  }], null);
})();
var _CdkObserveContent = class _CdkObserveContent {
  /**
   * Whether observing content is disabled. This option can be used
   * to disconnect the underlying MutationObserver until it is needed.
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._disabled ? this._unsubscribe() : this._subscribe();
  }
  /** Debounce interval for emitting the changes. */
  get debounce() {
    return this._debounce;
  }
  set debounce(value) {
    this._debounce = coerceNumberProperty(value);
    this._subscribe();
  }
  constructor(_contentObserver, _elementRef, _ngZone) {
    this._contentObserver = _contentObserver;
    this._elementRef = _elementRef;
    this._ngZone = _ngZone;
    this.event = new EventEmitter();
    this._disabled = false;
    this._currentSubscription = null;
  }
  ngAfterContentInit() {
    if (!this._currentSubscription && !this.disabled) {
      this._subscribe();
    }
  }
  ngOnDestroy() {
    this._unsubscribe();
  }
  _subscribe() {
    this._unsubscribe();
    const stream = this._contentObserver.observe(this._elementRef);
    this._ngZone.runOutsideAngular(() => {
      this._currentSubscription = (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);
    });
  }
  _unsubscribe() {
    this._currentSubscription?.unsubscribe();
  }
};
_CdkObserveContent.ɵfac = function CdkObserveContent_Factory(t) {
  return new (t || _CdkObserveContent)(ɵɵdirectiveInject(ContentObserver), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
_CdkObserveContent.ɵdir = ɵɵdefineDirective({
  type: _CdkObserveContent,
  selectors: [["", "cdkObserveContent", ""]],
  inputs: {
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkObserveContentDisabled", "disabled", booleanAttribute],
    debounce: "debounce"
  },
  outputs: {
    event: "cdkObserveContent"
  },
  exportAs: ["cdkObserveContent"],
  standalone: true,
  features: [ɵɵInputTransformsFeature]
});
var CdkObserveContent = _CdkObserveContent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkObserveContent, [{
    type: Directive,
    args: [{
      selector: "[cdkObserveContent]",
      exportAs: "cdkObserveContent",
      standalone: true
    }]
  }], () => [{
    type: ContentObserver
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }], {
    event: [{
      type: Output,
      args: ["cdkObserveContent"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkObserveContentDisabled",
        transform: booleanAttribute
      }]
    }],
    debounce: [{
      type: Input
    }]
  });
})();
var _ObserversModule = class _ObserversModule {
};
_ObserversModule.ɵfac = function ObserversModule_Factory(t) {
  return new (t || _ObserversModule)();
};
_ObserversModule.ɵmod = ɵɵdefineNgModule({
  type: _ObserversModule,
  imports: [CdkObserveContent],
  exports: [CdkObserveContent]
});
_ObserversModule.ɵinj = ɵɵdefineInjector({
  providers: [MutationObserverFactory]
});
var ObserversModule = _ObserversModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObserversModule, [{
    type: NgModule,
    args: [{
      imports: [CdkObserveContent],
      exports: [CdkObserveContent],
      providers: [MutationObserverFactory]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/layout.mjs
var _LayoutModule = class _LayoutModule {
};
_LayoutModule.ɵfac = function LayoutModule_Factory(t) {
  return new (t || _LayoutModule)();
};
_LayoutModule.ɵmod = ɵɵdefineNgModule({
  type: _LayoutModule
});
_LayoutModule.ɵinj = ɵɵdefineInjector({});
var LayoutModule = _LayoutModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var mediaQueriesForWebkitCompatibility = /* @__PURE__ */ new Set();
var mediaQueryStyleNode;
var _MediaMatcher = class _MediaMatcher {
  constructor(_platform, _nonce) {
    this._platform = _platform;
    this._nonce = _nonce;
    this._matchMedia = this._platform.isBrowser && window.matchMedia ? (
      // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
      // call it from a different scope.
      window.matchMedia.bind(window)
    ) : noopMatchMedia;
  }
  /**
   * Evaluates the given media query and returns the native MediaQueryList from which results
   * can be retrieved.
   * Confirms the layout engine will trigger for the selector query provided and returns the
   * MediaQueryList for the query provided.
   */
  matchMedia(query) {
    if (this._platform.WEBKIT || this._platform.BLINK) {
      createEmptyStyleRule(query, this._nonce);
    }
    return this._matchMedia(query);
  }
};
_MediaMatcher.ɵfac = function MediaMatcher_Factory(t) {
  return new (t || _MediaMatcher)(ɵɵinject(Platform), ɵɵinject(CSP_NONCE, 8));
};
_MediaMatcher.ɵprov = ɵɵdefineInjectable({
  token: _MediaMatcher,
  factory: _MediaMatcher.ɵfac,
  providedIn: "root"
});
var MediaMatcher = _MediaMatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaMatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CSP_NONCE]
    }]
  }], null);
})();
function createEmptyStyleRule(query, nonce) {
  if (mediaQueriesForWebkitCompatibility.has(query)) {
    return;
  }
  try {
    if (!mediaQueryStyleNode) {
      mediaQueryStyleNode = document.createElement("style");
      if (nonce) {
        mediaQueryStyleNode.setAttribute("nonce", nonce);
      }
      mediaQueryStyleNode.setAttribute("type", "text/css");
      document.head.appendChild(mediaQueryStyleNode);
    }
    if (mediaQueryStyleNode.sheet) {
      mediaQueryStyleNode.sheet.insertRule(`@media ${query} {body{ }}`, 0);
      mediaQueriesForWebkitCompatibility.add(query);
    }
  } catch (e) {
    console.error(e);
  }
}
function noopMatchMedia(query) {
  return {
    matches: query === "all" || query === "",
    media: query,
    addListener: () => {
    },
    removeListener: () => {
    }
  };
}
var _BreakpointObserver = class _BreakpointObserver {
  constructor(_mediaMatcher, _zone) {
    this._mediaMatcher = _mediaMatcher;
    this._zone = _zone;
    this._queries = /* @__PURE__ */ new Map();
    this._destroySubject = new Subject();
  }
  /** Completes the active subject, signalling to all other observables to complete. */
  ngOnDestroy() {
    this._destroySubject.next();
    this._destroySubject.complete();
  }
  /**
   * Whether one or more media queries match the current viewport size.
   * @param value One or more media queries to check.
   * @returns Whether any of the media queries match.
   */
  isMatched(value) {
    const queries = splitQueries(coerceArray(value));
    return queries.some((mediaQuery) => this._registerQuery(mediaQuery).mql.matches);
  }
  /**
   * Gets an observable of results for the given queries that will emit new results for any changes
   * in matching of the given queries.
   * @param value One or more media queries to check.
   * @returns A stream of matches for the given queries.
   */
  observe(value) {
    const queries = splitQueries(coerceArray(value));
    const observables = queries.map((query) => this._registerQuery(query).observable);
    let stateObservable = combineLatest(observables);
    stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));
    return stateObservable.pipe(map((breakpointStates) => {
      const response = {
        matches: false,
        breakpoints: {}
      };
      breakpointStates.forEach(({
        matches,
        query
      }) => {
        response.matches = response.matches || matches;
        response.breakpoints[query] = matches;
      });
      return response;
    }));
  }
  /** Registers a specific query to be listened for. */
  _registerQuery(query) {
    if (this._queries.has(query)) {
      return this._queries.get(query);
    }
    const mql = this._mediaMatcher.matchMedia(query);
    const queryObservable = new Observable((observer) => {
      const handler = (e) => this._zone.run(() => observer.next(e));
      mql.addListener(handler);
      return () => {
        mql.removeListener(handler);
      };
    }).pipe(startWith(mql), map(({
      matches
    }) => ({
      query,
      matches
    })), takeUntil(this._destroySubject));
    const output = {
      observable: queryObservable,
      mql
    };
    this._queries.set(query, output);
    return output;
  }
};
_BreakpointObserver.ɵfac = function BreakpointObserver_Factory(t) {
  return new (t || _BreakpointObserver)(ɵɵinject(MediaMatcher), ɵɵinject(NgZone));
};
_BreakpointObserver.ɵprov = ɵɵdefineInjectable({
  token: _BreakpointObserver,
  factory: _BreakpointObserver.ɵfac,
  providedIn: "root"
});
var BreakpointObserver = _BreakpointObserver;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreakpointObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: MediaMatcher
  }, {
    type: NgZone
  }], null);
})();
function splitQueries(queries) {
  return queries.map((query) => query.split(",")).reduce((a1, a2) => a1.concat(a2)).map((query) => query.trim());
}

// node_modules/@angular/cdk/fesm2022/a11y.mjs
var ID_DELIMITER = " ";
function addAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  if (ids.some((existingId) => existingId.trim() === id)) {
    return;
  }
  ids.push(id);
  el.setAttribute(attr, ids.join(ID_DELIMITER));
}
function removeAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  const filteredIds = ids.filter((val) => val !== id);
  if (filteredIds.length) {
    el.setAttribute(attr, filteredIds.join(ID_DELIMITER));
  } else {
    el.removeAttribute(attr);
  }
}
function getAriaReferenceIds(el, attr) {
  const attrValue = el.getAttribute(attr);
  return attrValue?.match(/\S+/g) ?? [];
}
var CDK_DESCRIBEDBY_ID_PREFIX = "cdk-describedby-message";
var CDK_DESCRIBEDBY_HOST_ATTRIBUTE = "cdk-describedby-host";
var nextId = 0;
var _AriaDescriber = class _AriaDescriber {
  constructor(_document, _platform) {
    this._platform = _platform;
    this._messageRegistry = /* @__PURE__ */ new Map();
    this._messagesContainer = null;
    this._id = `${nextId++}`;
    this._document = _document;
    this._id = inject(APP_ID) + "-" + nextId++;
  }
  describe(hostElement, message, role) {
    if (!this._canBeDescribed(hostElement, message)) {
      return;
    }
    const key = getKey(message, role);
    if (typeof message !== "string") {
      setMessageId(message, this._id);
      this._messageRegistry.set(key, {
        messageElement: message,
        referenceCount: 0
      });
    } else if (!this._messageRegistry.has(key)) {
      this._createMessageElement(message, role);
    }
    if (!this._isElementDescribedByMessage(hostElement, key)) {
      this._addMessageReference(hostElement, key);
    }
  }
  removeDescription(hostElement, message, role) {
    if (!message || !this._isElementNode(hostElement)) {
      return;
    }
    const key = getKey(message, role);
    if (this._isElementDescribedByMessage(hostElement, key)) {
      this._removeMessageReference(hostElement, key);
    }
    if (typeof message === "string") {
      const registeredMessage = this._messageRegistry.get(key);
      if (registeredMessage && registeredMessage.referenceCount === 0) {
        this._deleteMessageElement(key);
      }
    }
    if (this._messagesContainer?.childNodes.length === 0) {
      this._messagesContainer.remove();
      this._messagesContainer = null;
    }
  }
  /** Unregisters all created message elements and removes the message container. */
  ngOnDestroy() {
    const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}="${this._id}"]`);
    for (let i = 0; i < describedElements.length; i++) {
      this._removeCdkDescribedByReferenceIds(describedElements[i]);
      describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
    }
    this._messagesContainer?.remove();
    this._messagesContainer = null;
    this._messageRegistry.clear();
  }
  /**
   * Creates a new element in the visually hidden message container element with the message
   * as its content and adds it to the message registry.
   */
  _createMessageElement(message, role) {
    const messageElement = this._document.createElement("div");
    setMessageId(messageElement, this._id);
    messageElement.textContent = message;
    if (role) {
      messageElement.setAttribute("role", role);
    }
    this._createMessagesContainer();
    this._messagesContainer.appendChild(messageElement);
    this._messageRegistry.set(getKey(message, role), {
      messageElement,
      referenceCount: 0
    });
  }
  /** Deletes the message element from the global messages container. */
  _deleteMessageElement(key) {
    this._messageRegistry.get(key)?.messageElement?.remove();
    this._messageRegistry.delete(key);
  }
  /** Creates the global container for all aria-describedby messages. */
  _createMessagesContainer() {
    if (this._messagesContainer) {
      return;
    }
    const containerClassName = "cdk-describedby-message-container";
    const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform="server"]`);
    for (let i = 0; i < serverContainers.length; i++) {
      serverContainers[i].remove();
    }
    const messagesContainer = this._document.createElement("div");
    messagesContainer.style.visibility = "hidden";
    messagesContainer.classList.add(containerClassName);
    messagesContainer.classList.add("cdk-visually-hidden");
    if (this._platform && !this._platform.isBrowser) {
      messagesContainer.setAttribute("platform", "server");
    }
    this._document.body.appendChild(messagesContainer);
    this._messagesContainer = messagesContainer;
  }
  /** Removes all cdk-describedby messages that are hosted through the element. */
  _removeCdkDescribedByReferenceIds(element) {
    const originalReferenceIds = getAriaReferenceIds(element, "aria-describedby").filter((id) => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);
    element.setAttribute("aria-describedby", originalReferenceIds.join(" "));
  }
  /**
   * Adds a message reference to the element using aria-describedby and increments the registered
   * message's reference count.
   */
  _addMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    addAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);
    registeredMessage.referenceCount++;
  }
  /**
   * Removes a message reference from the element using aria-describedby
   * and decrements the registered message's reference count.
   */
  _removeMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    registeredMessage.referenceCount--;
    removeAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
  }
  /** Returns true if the element has been described by the provided message ID. */
  _isElementDescribedByMessage(element, key) {
    const referenceIds = getAriaReferenceIds(element, "aria-describedby");
    const registeredMessage = this._messageRegistry.get(key);
    const messageId = registeredMessage && registeredMessage.messageElement.id;
    return !!messageId && referenceIds.indexOf(messageId) != -1;
  }
  /** Determines whether a message can be described on a particular element. */
  _canBeDescribed(element, message) {
    if (!this._isElementNode(element)) {
      return false;
    }
    if (message && typeof message === "object") {
      return true;
    }
    const trimmedMessage = message == null ? "" : `${message}`.trim();
    const ariaLabel = element.getAttribute("aria-label");
    return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;
  }
  /** Checks whether a node is an Element node. */
  _isElementNode(element) {
    return element.nodeType === this._document.ELEMENT_NODE;
  }
};
_AriaDescriber.ɵfac = function AriaDescriber_Factory(t) {
  return new (t || _AriaDescriber)(ɵɵinject(DOCUMENT), ɵɵinject(Platform));
};
_AriaDescriber.ɵprov = ɵɵdefineInjectable({
  token: _AriaDescriber,
  factory: _AriaDescriber.ɵfac,
  providedIn: "root"
});
var AriaDescriber = _AriaDescriber;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AriaDescriber, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }], null);
})();
function getKey(message, role) {
  return typeof message === "string" ? `${role || ""}/${message}` : message;
}
function setMessageId(element, serviceId) {
  if (!element.id) {
    element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;
  }
}
var ListKeyManager = class {
  constructor(_items, injector) {
    this._items = _items;
    this._activeItemIndex = -1;
    this._activeItem = null;
    this._wrap = false;
    this._letterKeyStream = new Subject();
    this._typeaheadSubscription = Subscription.EMPTY;
    this._vertical = true;
    this._allowedModifierKeys = [];
    this._homeAndEnd = false;
    this._pageUpAndDown = {
      enabled: false,
      delta: 10
    };
    this._skipPredicateFn = (item) => item.disabled;
    this._pressedLetters = [];
    this.tabOut = new Subject();
    this.change = new Subject();
    if (_items instanceof QueryList) {
      this._itemChangesSubscription = _items.changes.subscribe((newItems) => this._itemsChanged(newItems.toArray()));
    } else if (isSignal(_items)) {
      if (!injector && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw new Error("ListKeyManager constructed with a signal must receive an injector");
      }
      this._effectRef = effect(() => this._itemsChanged(_items()), {
        injector
      });
    }
  }
  /**
   * Sets the predicate function that determines which items should be skipped by the
   * list key manager.
   * @param predicate Function that determines whether the given item should be skipped.
   */
  skipPredicate(predicate) {
    this._skipPredicateFn = predicate;
    return this;
  }
  /**
   * Configures wrapping mode, which determines whether the active item will wrap to
   * the other end of list when there are no more items in the given direction.
   * @param shouldWrap Whether the list should wrap when reaching the end.
   */
  withWrap(shouldWrap = true) {
    this._wrap = shouldWrap;
    return this;
  }
  /**
   * Configures whether the key manager should be able to move the selection vertically.
   * @param enabled Whether vertical selection should be enabled.
   */
  withVerticalOrientation(enabled = true) {
    this._vertical = enabled;
    return this;
  }
  /**
   * Configures the key manager to move the selection horizontally.
   * Passing in `null` will disable horizontal movement.
   * @param direction Direction in which the selection can be moved.
   */
  withHorizontalOrientation(direction) {
    this._horizontal = direction;
    return this;
  }
  /**
   * Modifier keys which are allowed to be held down and whose default actions will be prevented
   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.
   */
  withAllowedModifierKeys(keys) {
    this._allowedModifierKeys = keys;
    return this;
  }
  /**
   * Turns on typeahead mode which allows users to set the active item by typing.
   * @param debounceInterval Time to wait after the last keystroke before setting the active item.
   */
  withTypeAhead(debounceInterval = 200) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const items = this._getItemsArray();
      if (items.length > 0 && items.some((item) => typeof item.getLabel !== "function")) {
        throw Error("ListKeyManager items in typeahead mode must implement the `getLabel` method.");
      }
    }
    this._typeaheadSubscription.unsubscribe();
    this._typeaheadSubscription = this._letterKeyStream.pipe(tap((letter) => this._pressedLetters.push(letter)), debounceTime(debounceInterval), filter(() => this._pressedLetters.length > 0), map(() => this._pressedLetters.join(""))).subscribe((inputString) => {
      const items = this._getItemsArray();
      for (let i = 1; i < items.length + 1; i++) {
        const index = (this._activeItemIndex + i) % items.length;
        const item = items[index];
        if (!this._skipPredicateFn(item) && item.getLabel().toUpperCase().trim().indexOf(inputString) === 0) {
          this.setActiveItem(index);
          break;
        }
      }
      this._pressedLetters = [];
    });
    return this;
  }
  /** Cancels the current typeahead sequence. */
  cancelTypeahead() {
    this._pressedLetters = [];
    return this;
  }
  /**
   * Configures the key manager to activate the first and last items
   * respectively when the Home or End key is pressed.
   * @param enabled Whether pressing the Home or End key activates the first/last item.
   */
  withHomeAndEnd(enabled = true) {
    this._homeAndEnd = enabled;
    return this;
  }
  /**
   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction
   * respectively when the Page-Up or Page-Down key is pressed.
   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.
   * @param delta Whether pressing the Home or End key activates the first/last item.
   */
  withPageUpDown(enabled = true, delta = 10) {
    this._pageUpAndDown = {
      enabled,
      delta
    };
    return this;
  }
  setActiveItem(item) {
    const previousActiveItem = this._activeItem;
    this.updateActiveItem(item);
    if (this._activeItem !== previousActiveItem) {
      this.change.next(this._activeItemIndex);
    }
  }
  /**
   * Sets the active item depending on the key event passed in.
   * @param event Keyboard event to be used for determining which element should be active.
   */
  onKeydown(event) {
    const keyCode = event.keyCode;
    const modifiers = ["altKey", "ctrlKey", "metaKey", "shiftKey"];
    const isModifierAllowed = modifiers.every((modifier) => {
      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;
    });
    switch (keyCode) {
      case TAB:
        this.tabOut.next();
        return;
      case DOWN_ARROW:
        if (this._vertical && isModifierAllowed) {
          this.setNextItemActive();
          break;
        } else {
          return;
        }
      case UP_ARROW:
        if (this._vertical && isModifierAllowed) {
          this.setPreviousItemActive();
          break;
        } else {
          return;
        }
      case RIGHT_ARROW:
        if (this._horizontal && isModifierAllowed) {
          this._horizontal === "rtl" ? this.setPreviousItemActive() : this.setNextItemActive();
          break;
        } else {
          return;
        }
      case LEFT_ARROW:
        if (this._horizontal && isModifierAllowed) {
          this._horizontal === "rtl" ? this.setNextItemActive() : this.setPreviousItemActive();
          break;
        } else {
          return;
        }
      case HOME:
        if (this._homeAndEnd && isModifierAllowed) {
          this.setFirstItemActive();
          break;
        } else {
          return;
        }
      case END:
        if (this._homeAndEnd && isModifierAllowed) {
          this.setLastItemActive();
          break;
        } else {
          return;
        }
      case PAGE_UP:
        if (this._pageUpAndDown.enabled && isModifierAllowed) {
          const targetIndex = this._activeItemIndex - this._pageUpAndDown.delta;
          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);
          break;
        } else {
          return;
        }
      case PAGE_DOWN:
        if (this._pageUpAndDown.enabled && isModifierAllowed) {
          const targetIndex = this._activeItemIndex + this._pageUpAndDown.delta;
          const itemsLength = this._getItemsArray().length;
          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);
          break;
        } else {
          return;
        }
      default:
        if (isModifierAllowed || hasModifierKey(event, "shiftKey")) {
          if (event.key && event.key.length === 1) {
            this._letterKeyStream.next(event.key.toLocaleUpperCase());
          } else if (keyCode >= A && keyCode <= Z || keyCode >= ZERO && keyCode <= NINE) {
            this._letterKeyStream.next(String.fromCharCode(keyCode));
          }
        }
        return;
    }
    this._pressedLetters = [];
    event.preventDefault();
  }
  /** Index of the currently active item. */
  get activeItemIndex() {
    return this._activeItemIndex;
  }
  /** The active item. */
  get activeItem() {
    return this._activeItem;
  }
  /** Gets whether the user is currently typing into the manager using the typeahead feature. */
  isTyping() {
    return this._pressedLetters.length > 0;
  }
  /** Sets the active item to the first enabled item in the list. */
  setFirstItemActive() {
    this._setActiveItemByIndex(0, 1);
  }
  /** Sets the active item to the last enabled item in the list. */
  setLastItemActive() {
    this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);
  }
  /** Sets the active item to the next enabled item in the list. */
  setNextItemActive() {
    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
  }
  /** Sets the active item to a previous enabled item in the list. */
  setPreviousItemActive() {
    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1);
  }
  updateActiveItem(item) {
    const itemArray = this._getItemsArray();
    const index = typeof item === "number" ? item : itemArray.indexOf(item);
    const activeItem = itemArray[index];
    this._activeItem = activeItem == null ? null : activeItem;
    this._activeItemIndex = index;
  }
  /** Cleans up the key manager. */
  destroy() {
    this._typeaheadSubscription.unsubscribe();
    this._itemChangesSubscription?.unsubscribe();
    this._effectRef?.destroy();
    this._letterKeyStream.complete();
    this.tabOut.complete();
    this.change.complete();
    this._pressedLetters = [];
  }
  /**
   * This method sets the active item, given a list of items and the delta between the
   * currently active item and the new active item. It will calculate differently
   * depending on whether wrap mode is turned on.
   */
  _setActiveItemByDelta(delta) {
    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);
  }
  /**
   * Sets the active item properly given "wrap" mode. In other words, it will continue to move
   * down the list until it finds an item that is not disabled, and it will wrap if it
   * encounters either end of the list.
   */
  _setActiveInWrapMode(delta) {
    const items = this._getItemsArray();
    for (let i = 1; i <= items.length; i++) {
      const index = (this._activeItemIndex + delta * i + items.length) % items.length;
      const item = items[index];
      if (!this._skipPredicateFn(item)) {
        this.setActiveItem(index);
        return;
      }
    }
  }
  /**
   * Sets the active item properly given the default mode. In other words, it will
   * continue to move down the list until it finds an item that is not disabled. If
   * it encounters either end of the list, it will stop and not wrap.
   */
  _setActiveInDefaultMode(delta) {
    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);
  }
  /**
   * Sets the active item to the first enabled item starting at the index specified. If the
   * item is disabled, it will move in the fallbackDelta direction until it either
   * finds an enabled item or encounters the end of the list.
   */
  _setActiveItemByIndex(index, fallbackDelta) {
    const items = this._getItemsArray();
    if (!items[index]) {
      return;
    }
    while (this._skipPredicateFn(items[index])) {
      index += fallbackDelta;
      if (!items[index]) {
        return;
      }
    }
    this.setActiveItem(index);
  }
  /** Returns the items as an array. */
  _getItemsArray() {
    if (isSignal(this._items)) {
      return this._items();
    }
    return this._items instanceof QueryList ? this._items.toArray() : this._items;
  }
  /** Callback for when the items have changed. */
  _itemsChanged(newItems) {
    if (this._activeItem) {
      const newIndex = newItems.indexOf(this._activeItem);
      if (newIndex > -1 && newIndex !== this._activeItemIndex) {
        this._activeItemIndex = newIndex;
      }
    }
  }
};
var ActiveDescendantKeyManager = class extends ListKeyManager {
  setActiveItem(index) {
    if (this.activeItem) {
      this.activeItem.setInactiveStyles();
    }
    super.setActiveItem(index);
    if (this.activeItem) {
      this.activeItem.setActiveStyles();
    }
  }
};
var FocusKeyManager = class extends ListKeyManager {
  constructor() {
    super(...arguments);
    this._origin = "program";
  }
  /**
   * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.
   * @param origin Focus origin to be used when focusing items.
   */
  setFocusOrigin(origin) {
    this._origin = origin;
    return this;
  }
  setActiveItem(item) {
    super.setActiveItem(item);
    if (this.activeItem) {
      this.activeItem.focus(this._origin);
    }
  }
};
var _InteractivityChecker = class _InteractivityChecker {
  constructor(_platform) {
    this._platform = _platform;
  }
  /**
   * Gets whether an element is disabled.
   *
   * @param element Element to be checked.
   * @returns Whether the element is disabled.
   */
  isDisabled(element) {
    return element.hasAttribute("disabled");
  }
  /**
   * Gets whether an element is visible for the purposes of interactivity.
   *
   * This will capture states like `display: none` and `visibility: hidden`, but not things like
   * being clipped by an `overflow: hidden` parent or being outside the viewport.
   *
   * @returns Whether the element is visible.
   */
  isVisible(element) {
    return hasGeometry(element) && getComputedStyle(element).visibility === "visible";
  }
  /**
   * Gets whether an element can be reached via Tab key.
   * Assumes that the element has already been checked with isFocusable.
   *
   * @param element Element to be checked.
   * @returns Whether the element is tabbable.
   */
  isTabbable(element) {
    if (!this._platform.isBrowser) {
      return false;
    }
    const frameElement = getFrameElement(getWindow(element));
    if (frameElement) {
      if (getTabIndexValue(frameElement) === -1) {
        return false;
      }
      if (!this.isVisible(frameElement)) {
        return false;
      }
    }
    let nodeName = element.nodeName.toLowerCase();
    let tabIndexValue = getTabIndexValue(element);
    if (element.hasAttribute("contenteditable")) {
      return tabIndexValue !== -1;
    }
    if (nodeName === "iframe" || nodeName === "object") {
      return false;
    }
    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
      return false;
    }
    if (nodeName === "audio") {
      if (!element.hasAttribute("controls")) {
        return false;
      }
      return tabIndexValue !== -1;
    }
    if (nodeName === "video") {
      if (tabIndexValue === -1) {
        return false;
      }
      if (tabIndexValue !== null) {
        return true;
      }
      return this._platform.FIREFOX || element.hasAttribute("controls");
    }
    return element.tabIndex >= 0;
  }
  /**
   * Gets whether an element can be focused by the user.
   *
   * @param element Element to be checked.
   * @param config The config object with options to customize this method's behavior
   * @returns Whether the element is focusable.
   */
  isFocusable(element, config) {
    return isPotentiallyFocusable(element) && !this.isDisabled(element) && (config?.ignoreVisibility || this.isVisible(element));
  }
};
_InteractivityChecker.ɵfac = function InteractivityChecker_Factory(t) {
  return new (t || _InteractivityChecker)(ɵɵinject(Platform));
};
_InteractivityChecker.ɵprov = ɵɵdefineInjectable({
  token: _InteractivityChecker,
  factory: _InteractivityChecker.ɵfac,
  providedIn: "root"
});
var InteractivityChecker = _InteractivityChecker;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InteractivityChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }], null);
})();
function getFrameElement(window2) {
  try {
    return window2.frameElement;
  } catch {
    return null;
  }
}
function hasGeometry(element) {
  return !!(element.offsetWidth || element.offsetHeight || typeof element.getClientRects === "function" && element.getClientRects().length);
}
function isNativeFormElement(element) {
  let nodeName = element.nodeName.toLowerCase();
  return nodeName === "input" || nodeName === "select" || nodeName === "button" || nodeName === "textarea";
}
function isHiddenInput(element) {
  return isInputElement(element) && element.type == "hidden";
}
function isAnchorWithHref(element) {
  return isAnchorElement(element) && element.hasAttribute("href");
}
function isInputElement(element) {
  return element.nodeName.toLowerCase() == "input";
}
function isAnchorElement(element) {
  return element.nodeName.toLowerCase() == "a";
}
function hasValidTabIndex(element) {
  if (!element.hasAttribute("tabindex") || element.tabIndex === void 0) {
    return false;
  }
  let tabIndex = element.getAttribute("tabindex");
  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
}
function getTabIndexValue(element) {
  if (!hasValidTabIndex(element)) {
    return null;
  }
  const tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
  return isNaN(tabIndex) ? -1 : tabIndex;
}
function isPotentiallyTabbableIOS(element) {
  let nodeName = element.nodeName.toLowerCase();
  let inputType = nodeName === "input" && element.type;
  return inputType === "text" || inputType === "password" || nodeName === "select" || nodeName === "textarea";
}
function isPotentiallyFocusable(element) {
  if (isHiddenInput(element)) {
    return false;
  }
  return isNativeFormElement(element) || isAnchorWithHref(element) || element.hasAttribute("contenteditable") || hasValidTabIndex(element);
}
function getWindow(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || window;
}
var FocusTrap = class {
  /** Whether the focus trap is active. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(value, this._startAnchor);
      this._toggleAnchorTabIndex(value, this._endAnchor);
    }
  }
  constructor(_element, _checker, _ngZone, _document, deferAnchors = false) {
    this._element = _element;
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._document = _document;
    this._hasAttached = false;
    this.startAnchorListener = () => this.focusLastTabbableElement();
    this.endAnchorListener = () => this.focusFirstTabbableElement();
    this._enabled = true;
    if (!deferAnchors) {
      this.attachAnchors();
    }
  }
  /** Destroys the focus trap by cleaning up the anchors. */
  destroy() {
    const startAnchor = this._startAnchor;
    const endAnchor = this._endAnchor;
    if (startAnchor) {
      startAnchor.removeEventListener("focus", this.startAnchorListener);
      startAnchor.remove();
    }
    if (endAnchor) {
      endAnchor.removeEventListener("focus", this.endAnchorListener);
      endAnchor.remove();
    }
    this._startAnchor = this._endAnchor = null;
    this._hasAttached = false;
  }
  /**
   * Inserts the anchors into the DOM. This is usually done automatically
   * in the constructor, but can be deferred for cases like directives with `*ngIf`.
   * @returns Whether the focus trap managed to attach successfully. This may not be the case
   * if the target element isn't currently in the DOM.
   */
  attachAnchors() {
    if (this._hasAttached) {
      return true;
    }
    this._ngZone.runOutsideAngular(() => {
      if (!this._startAnchor) {
        this._startAnchor = this._createAnchor();
        this._startAnchor.addEventListener("focus", this.startAnchorListener);
      }
      if (!this._endAnchor) {
        this._endAnchor = this._createAnchor();
        this._endAnchor.addEventListener("focus", this.endAnchorListener);
      }
    });
    if (this._element.parentNode) {
      this._element.parentNode.insertBefore(this._startAnchor, this._element);
      this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);
      this._hasAttached = true;
    }
    return this._hasAttached;
  }
  /**
   * Waits for the zone to stabilize, then focuses the first tabbable element.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusInitialElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusInitialElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the first tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusFirstTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the last tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusLastTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));
    });
  }
  /**
   * Get the specified boundary element of the trapped region.
   * @param bound The boundary to get (start or end of trapped region).
   * @returns The boundary element.
   */
  _getRegionBoundary(bound) {
    const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], [cdkFocusRegion${bound}], [cdk-focus-${bound}]`);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      for (let i = 0; i < markers.length; i++) {
        if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        } else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        }
      }
    }
    if (bound == "start") {
      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
    }
    return markers.length ? markers[markers.length - 1] : this._getLastTabbableElement(this._element);
  }
  /**
   * Focuses the element that should be focused when the focus trap is initialized.
   * @returns Whether focus was moved successfully.
   */
  focusInitialElement(options) {
    const redirectToElement = this._element.querySelector(`[cdk-focus-initial], [cdkFocusInitial]`);
    if (redirectToElement) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && redirectToElement.hasAttribute(`cdk-focus-initial`)) {
        console.warn(`Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0`, redirectToElement);
      }
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._checker.isFocusable(redirectToElement)) {
        console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);
      }
      if (!this._checker.isFocusable(redirectToElement)) {
        const focusableChild = this._getFirstTabbableElement(redirectToElement);
        focusableChild?.focus(options);
        return !!focusableChild;
      }
      redirectToElement.focus(options);
      return true;
    }
    return this.focusFirstTabbableElement(options);
  }
  /**
   * Focuses the first tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusFirstTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("start");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Focuses the last tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusLastTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("end");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Checks whether the focus trap has successfully been attached.
   */
  hasAttached() {
    return this._hasAttached;
  }
  /** Get the first tabbable element from a DOM subtree (inclusive). */
  _getFirstTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = 0; i < children.length; i++) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Get the last tabbable element from a DOM subtree (inclusive). */
  _getLastTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = children.length - 1; i >= 0; i--) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Creates an anchor element. */
  _createAnchor() {
    const anchor = this._document.createElement("div");
    this._toggleAnchorTabIndex(this._enabled, anchor);
    anchor.classList.add("cdk-visually-hidden");
    anchor.classList.add("cdk-focus-trap-anchor");
    anchor.setAttribute("aria-hidden", "true");
    return anchor;
  }
  /**
   * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.
   * @param isEnabled Whether the focus trap is enabled.
   * @param anchor Anchor on which to toggle the tabindex.
   */
  _toggleAnchorTabIndex(isEnabled, anchor) {
    isEnabled ? anchor.setAttribute("tabindex", "0") : anchor.removeAttribute("tabindex");
  }
  /**
   * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.
   * @param enabled: Whether the anchors should trap Tab.
   */
  toggleAnchors(enabled) {
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(enabled, this._startAnchor);
      this._toggleAnchorTabIndex(enabled, this._endAnchor);
    }
  }
  /** Executes a function when the zone is stable. */
  _executeOnStable(fn) {
    if (this._ngZone.isStable) {
      fn();
    } else {
      this._ngZone.onStable.pipe(take(1)).subscribe(fn);
    }
  }
};
var _FocusTrapFactory = class _FocusTrapFactory {
  constructor(_checker, _ngZone, _document) {
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._document = _document;
  }
  /**
   * Creates a focus-trapped region around the given element.
   * @param element The element around which focus will be trapped.
   * @param deferCaptureElements Defers the creation of focus-capturing elements to be done
   *     manually by the user.
   * @returns The created focus trap instance.
   */
  create(element, deferCaptureElements = false) {
    return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);
  }
};
_FocusTrapFactory.ɵfac = function FocusTrapFactory_Factory(t) {
  return new (t || _FocusTrapFactory)(ɵɵinject(InteractivityChecker), ɵɵinject(NgZone), ɵɵinject(DOCUMENT));
};
_FocusTrapFactory.ɵprov = ɵɵdefineInjectable({
  token: _FocusTrapFactory,
  factory: _FocusTrapFactory.ɵfac,
  providedIn: "root"
});
var FocusTrapFactory = _FocusTrapFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: InteractivityChecker
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _CdkTrapFocus = class _CdkTrapFocus {
  /** Whether the focus trap is active. */
  get enabled() {
    return this.focusTrap?.enabled || false;
  }
  set enabled(value) {
    if (this.focusTrap) {
      this.focusTrap.enabled = value;
    }
  }
  constructor(_elementRef, _focusTrapFactory, _document) {
    this._elementRef = _elementRef;
    this._focusTrapFactory = _focusTrapFactory;
    this._previouslyFocusedElement = null;
    const platform = inject(Platform);
    if (platform.isBrowser) {
      this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
    }
  }
  ngOnDestroy() {
    this.focusTrap?.destroy();
    if (this._previouslyFocusedElement) {
      this._previouslyFocusedElement.focus();
      this._previouslyFocusedElement = null;
    }
  }
  ngAfterContentInit() {
    this.focusTrap?.attachAnchors();
    if (this.autoCapture) {
      this._captureFocus();
    }
  }
  ngDoCheck() {
    if (this.focusTrap && !this.focusTrap.hasAttached()) {
      this.focusTrap.attachAnchors();
    }
  }
  ngOnChanges(changes) {
    const autoCaptureChange = changes["autoCapture"];
    if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture && this.focusTrap?.hasAttached()) {
      this._captureFocus();
    }
  }
  _captureFocus() {
    this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();
    this.focusTrap?.focusInitialElementWhenReady();
  }
};
_CdkTrapFocus.ɵfac = function CdkTrapFocus_Factory(t) {
  return new (t || _CdkTrapFocus)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusTrapFactory), ɵɵdirectiveInject(DOCUMENT));
};
_CdkTrapFocus.ɵdir = ɵɵdefineDirective({
  type: _CdkTrapFocus,
  selectors: [["", "cdkTrapFocus", ""]],
  inputs: {
    enabled: [InputFlags.HasDecoratorInputTransform, "cdkTrapFocus", "enabled", booleanAttribute],
    autoCapture: [InputFlags.HasDecoratorInputTransform, "cdkTrapFocusAutoCapture", "autoCapture", booleanAttribute]
  },
  exportAs: ["cdkTrapFocus"],
  standalone: true,
  features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
});
var CdkTrapFocus = _CdkTrapFocus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkTrapFocus]",
      exportAs: "cdkTrapFocus",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: FocusTrapFactory
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], {
    enabled: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocus",
        transform: booleanAttribute
      }]
    }],
    autoCapture: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocusAutoCapture",
        transform: booleanAttribute
      }]
    }]
  });
})();
var ConfigurableFocusTrap = class extends FocusTrap {
  /** Whether the FocusTrap is enabled. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._enabled) {
      this._focusTrapManager.register(this);
    } else {
      this._focusTrapManager.deregister(this);
    }
  }
  constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config) {
    super(_element, _checker, _ngZone, _document, config.defer);
    this._focusTrapManager = _focusTrapManager;
    this._inertStrategy = _inertStrategy;
    this._focusTrapManager.register(this);
  }
  /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */
  destroy() {
    this._focusTrapManager.deregister(this);
    super.destroy();
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _enable() {
    this._inertStrategy.preventFocus(this);
    this.toggleAnchors(true);
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _disable() {
    this._inertStrategy.allowFocus(this);
    this.toggleAnchors(false);
  }
};
var FOCUS_TRAP_INERT_STRATEGY = new InjectionToken("FOCUS_TRAP_INERT_STRATEGY");
var EventListenerFocusTrapInertStrategy = class {
  constructor() {
    this._listener = null;
  }
  /** Adds a document event listener that keeps focus inside the FocusTrap. */
  preventFocus(focusTrap) {
    if (this._listener) {
      focusTrap._document.removeEventListener("focus", this._listener, true);
    }
    this._listener = (e) => this._trapFocus(focusTrap, e);
    focusTrap._ngZone.runOutsideAngular(() => {
      focusTrap._document.addEventListener("focus", this._listener, true);
    });
  }
  /** Removes the event listener added in preventFocus. */
  allowFocus(focusTrap) {
    if (!this._listener) {
      return;
    }
    focusTrap._document.removeEventListener("focus", this._listener, true);
    this._listener = null;
  }
  /**
   * Refocuses the first element in the FocusTrap if the focus event target was outside
   * the FocusTrap.
   *
   * This is an event listener callback. The event listener is added in runOutsideAngular,
   * so all this code runs outside Angular as well.
   */
  _trapFocus(focusTrap, event) {
    const target = event.target;
    const focusTrapRoot = focusTrap._element;
    if (target && !focusTrapRoot.contains(target) && !target.closest?.("div.cdk-overlay-pane")) {
      setTimeout(() => {
        if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {
          focusTrap.focusFirstTabbableElement();
        }
      });
    }
  }
};
var _FocusTrapManager = class _FocusTrapManager {
  constructor() {
    this._focusTrapStack = [];
  }
  /**
   * Disables the FocusTrap at the top of the stack, and then pushes
   * the new FocusTrap onto the stack.
   */
  register(focusTrap) {
    this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);
    let stack = this._focusTrapStack;
    if (stack.length) {
      stack[stack.length - 1]._disable();
    }
    stack.push(focusTrap);
    focusTrap._enable();
  }
  /**
   * Removes the FocusTrap from the stack, and activates the
   * FocusTrap that is the new top of the stack.
   */
  deregister(focusTrap) {
    focusTrap._disable();
    const stack = this._focusTrapStack;
    const i = stack.indexOf(focusTrap);
    if (i !== -1) {
      stack.splice(i, 1);
      if (stack.length) {
        stack[stack.length - 1]._enable();
      }
    }
  }
};
_FocusTrapManager.ɵfac = function FocusTrapManager_Factory(t) {
  return new (t || _FocusTrapManager)();
};
_FocusTrapManager.ɵprov = ɵɵdefineInjectable({
  token: _FocusTrapManager,
  factory: _FocusTrapManager.ɵfac,
  providedIn: "root"
});
var FocusTrapManager = _FocusTrapManager;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _ConfigurableFocusTrapFactory = class _ConfigurableFocusTrapFactory {
  constructor(_checker, _ngZone, _focusTrapManager, _document, _inertStrategy) {
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._focusTrapManager = _focusTrapManager;
    this._document = _document;
    this._inertStrategy = _inertStrategy || new EventListenerFocusTrapInertStrategy();
  }
  create(element, config = {
    defer: false
  }) {
    let configObject;
    if (typeof config === "boolean") {
      configObject = {
        defer: config
      };
    } else {
      configObject = config;
    }
    return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject);
  }
};
_ConfigurableFocusTrapFactory.ɵfac = function ConfigurableFocusTrapFactory_Factory(t) {
  return new (t || _ConfigurableFocusTrapFactory)(ɵɵinject(InteractivityChecker), ɵɵinject(NgZone), ɵɵinject(FocusTrapManager), ɵɵinject(DOCUMENT), ɵɵinject(FOCUS_TRAP_INERT_STRATEGY, 8));
};
_ConfigurableFocusTrapFactory.ɵprov = ɵɵdefineInjectable({
  token: _ConfigurableFocusTrapFactory,
  factory: _ConfigurableFocusTrapFactory.ɵfac,
  providedIn: "root"
});
var ConfigurableFocusTrapFactory = _ConfigurableFocusTrapFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfigurableFocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: InteractivityChecker
  }, {
    type: NgZone
  }, {
    type: FocusTrapManager
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [FOCUS_TRAP_INERT_STRATEGY]
    }]
  }], null);
})();
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}
var INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken("cdk-input-modality-detector-options");
var INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {
  ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT]
};
var TOUCH_BUFFER_MS = 650;
var modalityEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var _InputModalityDetector = class _InputModalityDetector {
  /** The most recently detected input modality. */
  get mostRecentModality() {
    return this._modality.value;
  }
  constructor(_platform, ngZone, document2, options) {
    this._platform = _platform;
    this._mostRecentTarget = null;
    this._modality = new BehaviorSubject(null);
    this._lastTouchMs = 0;
    this._onKeydown = (event) => {
      if (this._options?.ignoreKeys?.some((keyCode) => keyCode === event.keyCode)) {
        return;
      }
      this._modality.next("keyboard");
      this._mostRecentTarget = _getEventTarget(event);
    };
    this._onMousedown = (event) => {
      if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {
        return;
      }
      this._modality.next(isFakeMousedownFromScreenReader(event) ? "keyboard" : "mouse");
      this._mostRecentTarget = _getEventTarget(event);
    };
    this._onTouchstart = (event) => {
      if (isFakeTouchstartFromScreenReader(event)) {
        this._modality.next("keyboard");
        return;
      }
      this._lastTouchMs = Date.now();
      this._modality.next("touch");
      this._mostRecentTarget = _getEventTarget(event);
    };
    this._options = __spreadValues(__spreadValues({}, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS), options);
    this.modalityDetected = this._modality.pipe(skip(1));
    this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());
    if (_platform.isBrowser) {
      ngZone.runOutsideAngular(() => {
        document2.addEventListener("keydown", this._onKeydown, modalityEventListenerOptions);
        document2.addEventListener("mousedown", this._onMousedown, modalityEventListenerOptions);
        document2.addEventListener("touchstart", this._onTouchstart, modalityEventListenerOptions);
      });
    }
  }
  ngOnDestroy() {
    this._modality.complete();
    if (this._platform.isBrowser) {
      document.removeEventListener("keydown", this._onKeydown, modalityEventListenerOptions);
      document.removeEventListener("mousedown", this._onMousedown, modalityEventListenerOptions);
      document.removeEventListener("touchstart", this._onTouchstart, modalityEventListenerOptions);
    }
  }
};
_InputModalityDetector.ɵfac = function InputModalityDetector_Factory(t) {
  return new (t || _InputModalityDetector)(ɵɵinject(Platform), ɵɵinject(NgZone), ɵɵinject(DOCUMENT), ɵɵinject(INPUT_MODALITY_DETECTOR_OPTIONS, 8));
};
_InputModalityDetector.ɵprov = ɵɵdefineInjectable({
  token: _InputModalityDetector,
  factory: _InputModalityDetector.ɵfac,
  providedIn: "root"
});
var InputModalityDetector = _InputModalityDetector;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputModalityDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: NgZone
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [INPUT_MODALITY_DETECTOR_OPTIONS]
    }]
  }], null);
})();
var LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken("liveAnnouncerElement", {
  providedIn: "root",
  factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY
});
function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {
  return null;
}
var LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
var uniqueIds = 0;
var _LiveAnnouncer = class _LiveAnnouncer {
  constructor(elementToken, _ngZone, _document, _defaultOptions) {
    this._ngZone = _ngZone;
    this._defaultOptions = _defaultOptions;
    this._document = _document;
    this._liveElement = elementToken || this._createLiveElement();
  }
  announce(message, ...args) {
    const defaultOptions2 = this._defaultOptions;
    let politeness;
    let duration;
    if (args.length === 1 && typeof args[0] === "number") {
      duration = args[0];
    } else {
      [politeness, duration] = args;
    }
    this.clear();
    clearTimeout(this._previousTimeout);
    if (!politeness) {
      politeness = defaultOptions2 && defaultOptions2.politeness ? defaultOptions2.politeness : "polite";
    }
    if (duration == null && defaultOptions2) {
      duration = defaultOptions2.duration;
    }
    this._liveElement.setAttribute("aria-live", politeness);
    if (this._liveElement.id) {
      this._exposeAnnouncerToModals(this._liveElement.id);
    }
    return this._ngZone.runOutsideAngular(() => {
      if (!this._currentPromise) {
        this._currentPromise = new Promise((resolve) => this._currentResolve = resolve);
      }
      clearTimeout(this._previousTimeout);
      this._previousTimeout = setTimeout(() => {
        this._liveElement.textContent = message;
        if (typeof duration === "number") {
          this._previousTimeout = setTimeout(() => this.clear(), duration);
        }
        this._currentResolve?.();
        this._currentPromise = this._currentResolve = void 0;
      }, 100);
      return this._currentPromise;
    });
  }
  /**
   * Clears the current text from the announcer element. Can be used to prevent
   * screen readers from reading the text out again while the user is going
   * through the page landmarks.
   */
  clear() {
    if (this._liveElement) {
      this._liveElement.textContent = "";
    }
  }
  ngOnDestroy() {
    clearTimeout(this._previousTimeout);
    this._liveElement?.remove();
    this._liveElement = null;
    this._currentResolve?.();
    this._currentPromise = this._currentResolve = void 0;
  }
  _createLiveElement() {
    const elementClass = "cdk-live-announcer-element";
    const previousElements = this._document.getElementsByClassName(elementClass);
    const liveEl = this._document.createElement("div");
    for (let i = 0; i < previousElements.length; i++) {
      previousElements[i].remove();
    }
    liveEl.classList.add(elementClass);
    liveEl.classList.add("cdk-visually-hidden");
    liveEl.setAttribute("aria-atomic", "true");
    liveEl.setAttribute("aria-live", "polite");
    liveEl.id = `cdk-live-announcer-${uniqueIds++}`;
    this._document.body.appendChild(liveEl);
    return liveEl;
  }
  /**
   * Some browsers won't expose the accessibility node of the live announcer element if there is an
   * `aria-modal` and the live announcer is outside of it. This method works around the issue by
   * pointing the `aria-owns` of all modals to the live announcer element.
   */
  _exposeAnnouncerToModals(id) {
    const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
    for (let i = 0; i < modals.length; i++) {
      const modal = modals[i];
      const ariaOwns = modal.getAttribute("aria-owns");
      if (!ariaOwns) {
        modal.setAttribute("aria-owns", id);
      } else if (ariaOwns.indexOf(id) === -1) {
        modal.setAttribute("aria-owns", ariaOwns + " " + id);
      }
    }
  }
};
_LiveAnnouncer.ɵfac = function LiveAnnouncer_Factory(t) {
  return new (t || _LiveAnnouncer)(ɵɵinject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), ɵɵinject(NgZone), ɵɵinject(DOCUMENT), ɵɵinject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8));
};
_LiveAnnouncer.ɵprov = ɵɵdefineInjectable({
  token: _LiveAnnouncer,
  factory: _LiveAnnouncer.ɵfac,
  providedIn: "root"
});
var LiveAnnouncer = _LiveAnnouncer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LiveAnnouncer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [LIVE_ANNOUNCER_ELEMENT_TOKEN]
    }]
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS]
    }]
  }], null);
})();
var _CdkAriaLive = class _CdkAriaLive {
  /** The aria-live politeness level to use when announcing messages. */
  get politeness() {
    return this._politeness;
  }
  set politeness(value) {
    this._politeness = value === "off" || value === "assertive" ? value : "polite";
    if (this._politeness === "off") {
      if (this._subscription) {
        this._subscription.unsubscribe();
        this._subscription = null;
      }
    } else if (!this._subscription) {
      this._subscription = this._ngZone.runOutsideAngular(() => {
        return this._contentObserver.observe(this._elementRef).subscribe(() => {
          const elementText = this._elementRef.nativeElement.textContent;
          if (elementText !== this._previousAnnouncedText) {
            this._liveAnnouncer.announce(elementText, this._politeness, this.duration);
            this._previousAnnouncedText = elementText;
          }
        });
      });
    }
  }
  constructor(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {
    this._elementRef = _elementRef;
    this._liveAnnouncer = _liveAnnouncer;
    this._contentObserver = _contentObserver;
    this._ngZone = _ngZone;
    this._politeness = "polite";
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._subscription.unsubscribe();
    }
  }
};
_CdkAriaLive.ɵfac = function CdkAriaLive_Factory(t) {
  return new (t || _CdkAriaLive)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LiveAnnouncer), ɵɵdirectiveInject(ContentObserver), ɵɵdirectiveInject(NgZone));
};
_CdkAriaLive.ɵdir = ɵɵdefineDirective({
  type: _CdkAriaLive,
  selectors: [["", "cdkAriaLive", ""]],
  inputs: {
    politeness: [InputFlags.None, "cdkAriaLive", "politeness"],
    duration: [InputFlags.None, "cdkAriaLiveDuration", "duration"]
  },
  exportAs: ["cdkAriaLive"],
  standalone: true
});
var CdkAriaLive = _CdkAriaLive;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAriaLive, [{
    type: Directive,
    args: [{
      selector: "[cdkAriaLive]",
      exportAs: "cdkAriaLive",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: LiveAnnouncer
  }, {
    type: ContentObserver
  }, {
    type: NgZone
  }], {
    politeness: [{
      type: Input,
      args: ["cdkAriaLive"]
    }],
    duration: [{
      type: Input,
      args: ["cdkAriaLiveDuration"]
    }]
  });
})();
var FocusMonitorDetectionMode;
(function(FocusMonitorDetectionMode2) {
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["IMMEDIATE"] = 0] = "IMMEDIATE";
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["EVENTUAL"] = 1] = "EVENTUAL";
})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));
var FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken("cdk-focus-monitor-default-options");
var captureEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var _FocusMonitor = class _FocusMonitor {
  constructor(_ngZone, _platform, _inputModalityDetector, document2, options) {
    this._ngZone = _ngZone;
    this._platform = _platform;
    this._inputModalityDetector = _inputModalityDetector;
    this._origin = null;
    this._windowFocused = false;
    this._originFromTouchInteraction = false;
    this._elementInfo = /* @__PURE__ */ new Map();
    this._monitoredElementCount = 0;
    this._rootNodeFocusListenerCount = /* @__PURE__ */ new Map();
    this._windowFocusListener = () => {
      this._windowFocused = true;
      this._windowFocusTimeoutId = window.setTimeout(() => this._windowFocused = false);
    };
    this._stopInputModalityDetector = new Subject();
    this._rootNodeFocusAndBlurListener = (event) => {
      const target = _getEventTarget(event);
      for (let element = target; element; element = element.parentElement) {
        if (event.type === "focus") {
          this._onFocus(event, element);
        } else {
          this._onBlur(event, element);
        }
      }
    };
    this._document = document2;
    this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;
  }
  monitor(element, checkChildren = false) {
    const nativeElement = coerceElement(element);
    if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {
      return of();
    }
    const rootNode = _getShadowRoot(nativeElement) || this._getDocument();
    const cachedInfo = this._elementInfo.get(nativeElement);
    if (cachedInfo) {
      if (checkChildren) {
        cachedInfo.checkChildren = true;
      }
      return cachedInfo.subject;
    }
    const info = {
      checkChildren,
      subject: new Subject(),
      rootNode
    };
    this._elementInfo.set(nativeElement, info);
    this._registerGlobalListeners(info);
    return info.subject;
  }
  stopMonitoring(element) {
    const nativeElement = coerceElement(element);
    const elementInfo = this._elementInfo.get(nativeElement);
    if (elementInfo) {
      elementInfo.subject.complete();
      this._setClasses(nativeElement);
      this._elementInfo.delete(nativeElement);
      this._removeGlobalListeners(elementInfo);
    }
  }
  focusVia(element, origin, options) {
    const nativeElement = coerceElement(element);
    const focusedElement = this._getDocument().activeElement;
    if (nativeElement === focusedElement) {
      this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));
    } else {
      this._setOrigin(origin);
      if (typeof nativeElement.focus === "function") {
        nativeElement.focus(options);
      }
    }
  }
  ngOnDestroy() {
    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));
  }
  /** Access injected document if available or fallback to global document reference */
  _getDocument() {
    return this._document || document;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    const doc = this._getDocument();
    return doc.defaultView || window;
  }
  _getFocusOrigin(focusEventTarget) {
    if (this._origin) {
      if (this._originFromTouchInteraction) {
        return this._shouldBeAttributedToTouch(focusEventTarget) ? "touch" : "program";
      } else {
        return this._origin;
      }
    }
    if (this._windowFocused && this._lastFocusOrigin) {
      return this._lastFocusOrigin;
    }
    if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {
      return "mouse";
    }
    return "program";
  }
  /**
   * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a
   * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we
   * handle a focus event following a touch interaction, we need to determine whether (1) the focus
   * event was directly caused by the touch interaction or (2) the focus event was caused by a
   * subsequent programmatic focus call triggered by the touch interaction.
   * @param focusEventTarget The target of the focus event under examination.
   */
  _shouldBeAttributedToTouch(focusEventTarget) {
    return this._detectionMode === FocusMonitorDetectionMode.EVENTUAL || !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget);
  }
  /**
   * Sets the focus classes on the element based on the given focus origin.
   * @param element The element to update the classes on.
   * @param origin The focus origin.
   */
  _setClasses(element, origin) {
    element.classList.toggle("cdk-focused", !!origin);
    element.classList.toggle("cdk-touch-focused", origin === "touch");
    element.classList.toggle("cdk-keyboard-focused", origin === "keyboard");
    element.classList.toggle("cdk-mouse-focused", origin === "mouse");
    element.classList.toggle("cdk-program-focused", origin === "program");
  }
  /**
   * Updates the focus origin. If we're using immediate detection mode, we schedule an async
   * function to clear the origin at the end of a timeout. The duration of the timeout depends on
   * the origin being set.
   * @param origin The origin to set.
   * @param isFromInteraction Whether we are setting the origin from an interaction event.
   */
  _setOrigin(origin, isFromInteraction = false) {
    this._ngZone.runOutsideAngular(() => {
      this._origin = origin;
      this._originFromTouchInteraction = origin === "touch" && isFromInteraction;
      if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {
        clearTimeout(this._originTimeoutId);
        const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;
        this._originTimeoutId = setTimeout(() => this._origin = null, ms);
      }
    });
  }
  /**
   * Handles focus events on a registered element.
   * @param event The focus event.
   * @param element The monitored element.
   */
  _onFocus(event, element) {
    const elementInfo = this._elementInfo.get(element);
    const focusEventTarget = _getEventTarget(event);
    if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {
      return;
    }
    this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);
  }
  /**
   * Handles blur events on a registered element.
   * @param event The blur event.
   * @param element The monitored element.
   */
  _onBlur(event, element) {
    const elementInfo = this._elementInfo.get(element);
    if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {
      return;
    }
    this._setClasses(element);
    this._emitOrigin(elementInfo, null);
  }
  _emitOrigin(info, origin) {
    if (info.subject.observers.length) {
      this._ngZone.run(() => info.subject.next(origin));
    }
  }
  _registerGlobalListeners(elementInfo) {
    if (!this._platform.isBrowser) {
      return;
    }
    const rootNode = elementInfo.rootNode;
    const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;
    if (!rootNodeFocusListeners) {
      this._ngZone.runOutsideAngular(() => {
        rootNode.addEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.addEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
      });
    }
    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);
    if (++this._monitoredElementCount === 1) {
      this._ngZone.runOutsideAngular(() => {
        const window2 = this._getWindow();
        window2.addEventListener("focus", this._windowFocusListener);
      });
      this._inputModalityDetector.modalityDetected.pipe(takeUntil(this._stopInputModalityDetector)).subscribe((modality) => {
        this._setOrigin(
          modality,
          true
          /* isFromInteraction */
        );
      });
    }
  }
  _removeGlobalListeners(elementInfo) {
    const rootNode = elementInfo.rootNode;
    if (this._rootNodeFocusListenerCount.has(rootNode)) {
      const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);
      if (rootNodeFocusListeners > 1) {
        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);
      } else {
        rootNode.removeEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.removeEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        this._rootNodeFocusListenerCount.delete(rootNode);
      }
    }
    if (!--this._monitoredElementCount) {
      const window2 = this._getWindow();
      window2.removeEventListener("focus", this._windowFocusListener);
      this._stopInputModalityDetector.next();
      clearTimeout(this._windowFocusTimeoutId);
      clearTimeout(this._originTimeoutId);
    }
  }
  /** Updates all the state on an element once its focus origin has changed. */
  _originChanged(element, origin, elementInfo) {
    this._setClasses(element, origin);
    this._emitOrigin(elementInfo, origin);
    this._lastFocusOrigin = origin;
  }
  /**
   * Collects the `MonitoredElementInfo` of a particular element and
   * all of its ancestors that have enabled `checkChildren`.
   * @param element Element from which to start the search.
   */
  _getClosestElementsInfo(element) {
    const results = [];
    this._elementInfo.forEach((info, currentElement) => {
      if (currentElement === element || info.checkChildren && currentElement.contains(element)) {
        results.push([currentElement, info]);
      }
    });
    return results;
  }
  /**
   * Returns whether an interaction is likely to have come from the user clicking the `label` of
   * an `input` or `textarea` in order to focus it.
   * @param focusEventTarget Target currently receiving focus.
   */
  _isLastInteractionFromInputLabel(focusEventTarget) {
    const {
      _mostRecentTarget: mostRecentTarget,
      mostRecentModality
    } = this._inputModalityDetector;
    if (mostRecentModality !== "mouse" || !mostRecentTarget || mostRecentTarget === focusEventTarget || focusEventTarget.nodeName !== "INPUT" && focusEventTarget.nodeName !== "TEXTAREA" || focusEventTarget.disabled) {
      return false;
    }
    const labels = focusEventTarget.labels;
    if (labels) {
      for (let i = 0; i < labels.length; i++) {
        if (labels[i].contains(mostRecentTarget)) {
          return true;
        }
      }
    }
    return false;
  }
};
_FocusMonitor.ɵfac = function FocusMonitor_Factory(t) {
  return new (t || _FocusMonitor)(ɵɵinject(NgZone), ɵɵinject(Platform), ɵɵinject(InputModalityDetector), ɵɵinject(DOCUMENT, 8), ɵɵinject(FOCUS_MONITOR_DEFAULT_OPTIONS, 8));
};
_FocusMonitor.ɵprov = ɵɵdefineInjectable({
  token: _FocusMonitor,
  factory: _FocusMonitor.ɵfac,
  providedIn: "root"
});
var FocusMonitor = _FocusMonitor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusMonitor, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NgZone
  }, {
    type: Platform
  }, {
    type: InputModalityDetector
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [FOCUS_MONITOR_DEFAULT_OPTIONS]
    }]
  }], null);
})();
var _CdkMonitorFocus = class _CdkMonitorFocus {
  constructor(_elementRef, _focusMonitor) {
    this._elementRef = _elementRef;
    this._focusMonitor = _focusMonitor;
    this._focusOrigin = null;
    this.cdkFocusChange = new EventEmitter();
  }
  get focusOrigin() {
    return this._focusOrigin;
  }
  ngAfterViewInit() {
    const element = this._elementRef.nativeElement;
    this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute("cdkMonitorSubtreeFocus")).subscribe((origin) => {
      this._focusOrigin = origin;
      this.cdkFocusChange.emit(origin);
    });
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
    if (this._monitorSubscription) {
      this._monitorSubscription.unsubscribe();
    }
  }
};
_CdkMonitorFocus.ɵfac = function CdkMonitorFocus_Factory(t) {
  return new (t || _CdkMonitorFocus)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusMonitor));
};
_CdkMonitorFocus.ɵdir = ɵɵdefineDirective({
  type: _CdkMonitorFocus,
  selectors: [["", "cdkMonitorElementFocus", ""], ["", "cdkMonitorSubtreeFocus", ""]],
  outputs: {
    cdkFocusChange: "cdkFocusChange"
  },
  exportAs: ["cdkMonitorFocus"],
  standalone: true
});
var CdkMonitorFocus = _CdkMonitorFocus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkMonitorFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]",
      exportAs: "cdkMonitorFocus",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: FocusMonitor
  }], {
    cdkFocusChange: [{
      type: Output
    }]
  });
})();
var HighContrastMode;
(function(HighContrastMode2) {
  HighContrastMode2[HighContrastMode2["NONE"] = 0] = "NONE";
  HighContrastMode2[HighContrastMode2["BLACK_ON_WHITE"] = 1] = "BLACK_ON_WHITE";
  HighContrastMode2[HighContrastMode2["WHITE_ON_BLACK"] = 2] = "WHITE_ON_BLACK";
})(HighContrastMode || (HighContrastMode = {}));
var BLACK_ON_WHITE_CSS_CLASS = "cdk-high-contrast-black-on-white";
var WHITE_ON_BLACK_CSS_CLASS = "cdk-high-contrast-white-on-black";
var HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = "cdk-high-contrast-active";
var _HighContrastModeDetector = class _HighContrastModeDetector {
  constructor(_platform, document2) {
    this._platform = _platform;
    this._document = document2;
    this._breakpointSubscription = inject(BreakpointObserver).observe("(forced-colors: active)").subscribe(() => {
      if (this._hasCheckedHighContrastMode) {
        this._hasCheckedHighContrastMode = false;
        this._applyBodyHighContrastModeCssClasses();
      }
    });
  }
  /** Gets the current high-contrast-mode for the page. */
  getHighContrastMode() {
    if (!this._platform.isBrowser) {
      return HighContrastMode.NONE;
    }
    const testElement = this._document.createElement("div");
    testElement.style.backgroundColor = "rgb(1,2,3)";
    testElement.style.position = "absolute";
    this._document.body.appendChild(testElement);
    const documentWindow = this._document.defaultView || window;
    const computedStyle = documentWindow && documentWindow.getComputedStyle ? documentWindow.getComputedStyle(testElement) : null;
    const computedColor = (computedStyle && computedStyle.backgroundColor || "").replace(/ /g, "");
    testElement.remove();
    switch (computedColor) {
      case "rgb(0,0,0)":
      case "rgb(45,50,54)":
      case "rgb(32,32,32)":
        return HighContrastMode.WHITE_ON_BLACK;
      case "rgb(255,255,255)":
      case "rgb(255,250,239)":
        return HighContrastMode.BLACK_ON_WHITE;
    }
    return HighContrastMode.NONE;
  }
  ngOnDestroy() {
    this._breakpointSubscription.unsubscribe();
  }
  /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */
  _applyBodyHighContrastModeCssClasses() {
    if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
      const bodyClasses = this._document.body.classList;
      bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      this._hasCheckedHighContrastMode = true;
      const mode = this.getHighContrastMode();
      if (mode === HighContrastMode.BLACK_ON_WHITE) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);
      } else if (mode === HighContrastMode.WHITE_ON_BLACK) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      }
    }
  }
};
_HighContrastModeDetector.ɵfac = function HighContrastModeDetector_Factory(t) {
  return new (t || _HighContrastModeDetector)(ɵɵinject(Platform), ɵɵinject(DOCUMENT));
};
_HighContrastModeDetector.ɵprov = ɵɵdefineInjectable({
  token: _HighContrastModeDetector,
  factory: _HighContrastModeDetector.ɵfac,
  providedIn: "root"
});
var HighContrastModeDetector = _HighContrastModeDetector;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighContrastModeDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _A11yModule = class _A11yModule {
  constructor(highContrastModeDetector) {
    highContrastModeDetector._applyBodyHighContrastModeCssClasses();
  }
};
_A11yModule.ɵfac = function A11yModule_Factory(t) {
  return new (t || _A11yModule)(ɵɵinject(HighContrastModeDetector));
};
_A11yModule.ɵmod = ɵɵdefineNgModule({
  type: _A11yModule,
  imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
  exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
});
_A11yModule.ɵinj = ɵɵdefineInjector({
  imports: [ObserversModule]
});
var A11yModule = _A11yModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(A11yModule, [{
    type: NgModule,
    args: [{
      imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
      exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
    }]
  }], () => [{
    type: HighContrastModeDetector
  }], null);
})();

// node_modules/@angular/cdk/fesm2022/portal.mjs
function throwNullPortalError() {
  throw Error("Must provide a portal to attach");
}
function throwPortalAlreadyAttachedError() {
  throw Error("Host already has a portal attached");
}
function throwPortalOutletAlreadyDisposedError() {
  throw Error("This PortalOutlet has already been disposed");
}
function throwUnknownPortalTypeError() {
  throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.");
}
function throwNullPortalOutletError() {
  throw Error("Attempting to attach a portal to a null PortalOutlet");
}
function throwNoPortalAttachedError() {
  throw Error("Attempting to detach a portal that is not attached to a host");
}
var Portal = class {
  /** Attach this portal to a host. */
  attach(host) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (host == null) {
        throwNullPortalOutletError();
      }
      if (host.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
    }
    this._attachedHost = host;
    return host.attach(this);
  }
  /** Detach this portal from its host */
  detach() {
    let host = this._attachedHost;
    if (host != null) {
      this._attachedHost = null;
      host.detach();
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwNoPortalAttachedError();
    }
  }
  /** Whether this portal is attached to a host. */
  get isAttached() {
    return this._attachedHost != null;
  }
  /**
   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
   * the PortalOutlet when it is performing an `attach()` or `detach()`.
   */
  setAttachedHost(host) {
    this._attachedHost = host;
  }
};
var ComponentPortal = class extends Portal {
  constructor(component, viewContainerRef, injector, componentFactoryResolver, projectableNodes) {
    super();
    this.component = component;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.componentFactoryResolver = componentFactoryResolver;
    this.projectableNodes = projectableNodes;
  }
};
var TemplatePortal = class extends Portal {
  constructor(templateRef, viewContainerRef, context, injector) {
    super();
    this.templateRef = templateRef;
    this.viewContainerRef = viewContainerRef;
    this.context = context;
    this.injector = injector;
  }
  get origin() {
    return this.templateRef.elementRef;
  }
  /**
   * Attach the portal to the provided `PortalOutlet`.
   * When a context is provided it will override the `context` property of the `TemplatePortal`
   * instance.
   */
  attach(host, context = this.context) {
    this.context = context;
    return super.attach(host);
  }
  detach() {
    this.context = void 0;
    return super.detach();
  }
};
var DomPortal = class extends Portal {
  constructor(element) {
    super();
    this.element = element instanceof ElementRef ? element.nativeElement : element;
  }
};
var BasePortalOutlet = class {
  constructor() {
    this._isDisposed = false;
    this.attachDomPortal = null;
  }
  /** Whether this host has an attached portal. */
  hasAttached() {
    return !!this._attachedPortal;
  }
  /** Attaches a portal. */
  attach(portal) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!portal) {
        throwNullPortalError();
      }
      if (this.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
      if (this._isDisposed) {
        throwPortalOutletAlreadyDisposedError();
      }
    }
    if (portal instanceof ComponentPortal) {
      this._attachedPortal = portal;
      return this.attachComponentPortal(portal);
    } else if (portal instanceof TemplatePortal) {
      this._attachedPortal = portal;
      return this.attachTemplatePortal(portal);
    } else if (this.attachDomPortal && portal instanceof DomPortal) {
      this._attachedPortal = portal;
      return this.attachDomPortal(portal);
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwUnknownPortalTypeError();
    }
  }
  /** Detaches a previously attached portal. */
  detach() {
    if (this._attachedPortal) {
      this._attachedPortal.setAttachedHost(null);
      this._attachedPortal = null;
    }
    this._invokeDisposeFn();
  }
  /** Permanently dispose of this portal host. */
  dispose() {
    if (this.hasAttached()) {
      this.detach();
    }
    this._invokeDisposeFn();
    this._isDisposed = true;
  }
  /** @docs-private */
  setDisposeFn(fn) {
    this._disposeFn = fn;
  }
  _invokeDisposeFn() {
    if (this._disposeFn) {
      this._disposeFn();
      this._disposeFn = null;
    }
  }
};
var DomPortalOutlet = class extends BasePortalOutlet {
  /**
   * @param outletElement Element into which the content is projected.
   * @param _componentFactoryResolver Used to resolve the component factory.
   *   Only required when attaching component portals.
   * @param _appRef Reference to the application. Only used in component portals when there
   *   is no `ViewContainerRef` available.
   * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't
   *   have one. Only used for component portals.
   * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually
   *   become a required parameter.
   */
  constructor(outletElement, _componentFactoryResolver, _appRef, _defaultInjector, _document) {
    super();
    this.outletElement = outletElement;
    this._componentFactoryResolver = _componentFactoryResolver;
    this._appRef = _appRef;
    this._defaultInjector = _defaultInjector;
    this.attachDomPortal = (portal) => {
      if (!this._document && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("Cannot attach DOM portal without _document constructor parameter");
      }
      const element = portal.element;
      if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("DOM portal content must be attached to a parent node.");
      }
      const anchorNode = this._document.createComment("dom-portal");
      element.parentNode.insertBefore(anchorNode, element);
      this.outletElement.appendChild(element);
      this._attachedPortal = portal;
      super.setDisposeFn(() => {
        if (anchorNode.parentNode) {
          anchorNode.parentNode.replaceChild(element, anchorNode);
        }
      });
    };
    this._document = _document;
  }
  /**
   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
   * @param portal Portal to be attached
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !resolver) {
      throw Error("Cannot attach component portal to outlet without a ComponentFactoryResolver.");
    }
    const componentFactory = resolver.resolveComponentFactory(portal.component);
    let componentRef;
    if (portal.viewContainerRef) {
      componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector, portal.projectableNodes || void 0);
      this.setDisposeFn(() => componentRef.destroy());
    } else {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._appRef) {
        throw Error("Cannot attach component portal to outlet without an ApplicationRef.");
      }
      componentRef = componentFactory.create(portal.injector || this._defaultInjector || Injector.NULL);
      this._appRef.attachView(componentRef.hostView);
      this.setDisposeFn(() => {
        if (this._appRef.viewCount > 0) {
          this._appRef.detachView(componentRef.hostView);
        }
        componentRef.destroy();
      });
    }
    this.outletElement.appendChild(this._getComponentRootNode(componentRef));
    this._attachedPortal = portal;
    return componentRef;
  }
  /**
   * Attaches a template portal to the DOM as an embedded view.
   * @param portal Portal to be attached.
   * @returns Reference to the created embedded view.
   */
  attachTemplatePortal(portal) {
    let viewContainer = portal.viewContainerRef;
    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    viewRef.rootNodes.forEach((rootNode) => this.outletElement.appendChild(rootNode));
    viewRef.detectChanges();
    this.setDisposeFn(() => {
      let index = viewContainer.indexOf(viewRef);
      if (index !== -1) {
        viewContainer.remove(index);
      }
    });
    this._attachedPortal = portal;
    return viewRef;
  }
  /**
   * Clears out a portal from the DOM.
   */
  dispose() {
    super.dispose();
    this.outletElement.remove();
  }
  /** Gets the root HTMLElement for an instantiated component. */
  _getComponentRootNode(componentRef) {
    return componentRef.hostView.rootNodes[0];
  }
};
var _CdkPortal = class _CdkPortal extends TemplatePortal {
  constructor(templateRef, viewContainerRef) {
    super(templateRef, viewContainerRef);
  }
};
_CdkPortal.ɵfac = function CdkPortal_Factory(t) {
  return new (t || _CdkPortal)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef));
};
_CdkPortal.ɵdir = ɵɵdefineDirective({
  type: _CdkPortal,
  selectors: [["", "cdkPortal", ""]],
  exportAs: ["cdkPortal"],
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkPortal = _CdkPortal;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortal, [{
    type: Directive,
    args: [{
      selector: "[cdkPortal]",
      exportAs: "cdkPortal",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }], null);
})();
var _TemplatePortalDirective = class _TemplatePortalDirective extends CdkPortal {
};
_TemplatePortalDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵTemplatePortalDirective_BaseFactory;
  return function TemplatePortalDirective_Factory(t) {
    return (ɵTemplatePortalDirective_BaseFactory || (ɵTemplatePortalDirective_BaseFactory = ɵɵgetInheritedFactory(_TemplatePortalDirective)))(t || _TemplatePortalDirective);
  };
})();
_TemplatePortalDirective.ɵdir = ɵɵdefineDirective({
  type: _TemplatePortalDirective,
  selectors: [["", "cdk-portal", ""], ["", "portal", ""]],
  exportAs: ["cdkPortal"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CdkPortal,
    useExisting: _TemplatePortalDirective
  }]), ɵɵInheritDefinitionFeature]
});
var TemplatePortalDirective = _TemplatePortalDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplatePortalDirective, [{
    type: Directive,
    args: [{
      selector: "[cdk-portal], [portal]",
      exportAs: "cdkPortal",
      providers: [{
        provide: CdkPortal,
        useExisting: TemplatePortalDirective
      }],
      standalone: true
    }]
  }], null, null);
})();
var _CdkPortalOutlet = class _CdkPortalOutlet extends BasePortalOutlet {
  constructor(_componentFactoryResolver, _viewContainerRef, _document) {
    super();
    this._componentFactoryResolver = _componentFactoryResolver;
    this._viewContainerRef = _viewContainerRef;
    this._isInitialized = false;
    this.attached = new EventEmitter();
    this.attachDomPortal = (portal) => {
      if (!this._document && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("Cannot attach DOM portal without _document constructor parameter");
      }
      const element = portal.element;
      if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("DOM portal content must be attached to a parent node.");
      }
      const anchorNode = this._document.createComment("dom-portal");
      portal.setAttachedHost(this);
      element.parentNode.insertBefore(anchorNode, element);
      this._getRootNode().appendChild(element);
      this._attachedPortal = portal;
      super.setDisposeFn(() => {
        if (anchorNode.parentNode) {
          anchorNode.parentNode.replaceChild(element, anchorNode);
        }
      });
    };
    this._document = _document;
  }
  /** Portal associated with the Portal outlet. */
  get portal() {
    return this._attachedPortal;
  }
  set portal(portal) {
    if (this.hasAttached() && !portal && !this._isInitialized) {
      return;
    }
    if (this.hasAttached()) {
      super.detach();
    }
    if (portal) {
      super.attach(portal);
    }
    this._attachedPortal = portal || null;
  }
  /** Component or view reference that is attached to the portal. */
  get attachedRef() {
    return this._attachedRef;
  }
  ngOnInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    super.dispose();
    this._attachedRef = this._attachedPortal = null;
  }
  /**
   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
   *
   * @param portal Portal to be attached to the portal outlet.
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    portal.setAttachedHost(this);
    const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;
    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
    const componentFactory = resolver.resolveComponentFactory(portal.component);
    const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector, portal.projectableNodes || void 0);
    if (viewContainerRef !== this._viewContainerRef) {
      this._getRootNode().appendChild(ref.hostView.rootNodes[0]);
    }
    super.setDisposeFn(() => ref.destroy());
    this._attachedPortal = portal;
    this._attachedRef = ref;
    this.attached.emit(ref);
    return ref;
  }
  /**
   * Attach the given TemplatePortal to this PortalHost as an embedded View.
   * @param portal Portal to be attached.
   * @returns Reference to the created embedded view.
   */
  attachTemplatePortal(portal) {
    portal.setAttachedHost(this);
    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    super.setDisposeFn(() => this._viewContainerRef.clear());
    this._attachedPortal = portal;
    this._attachedRef = viewRef;
    this.attached.emit(viewRef);
    return viewRef;
  }
  /** Gets the root node of the portal outlet. */
  _getRootNode() {
    const nativeElement = this._viewContainerRef.element.nativeElement;
    return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;
  }
};
_CdkPortalOutlet.ɵfac = function CdkPortalOutlet_Factory(t) {
  return new (t || _CdkPortalOutlet)(ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DOCUMENT));
};
_CdkPortalOutlet.ɵdir = ɵɵdefineDirective({
  type: _CdkPortalOutlet,
  selectors: [["", "cdkPortalOutlet", ""]],
  inputs: {
    portal: [InputFlags.None, "cdkPortalOutlet", "portal"]
  },
  outputs: {
    attached: "attached"
  },
  exportAs: ["cdkPortalOutlet"],
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkPortalOutlet = _CdkPortalOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortalOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalOutlet]",
      exportAs: "cdkPortalOutlet",
      standalone: true
    }]
  }], () => [{
    type: ComponentFactoryResolver$1
  }, {
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], {
    portal: [{
      type: Input,
      args: ["cdkPortalOutlet"]
    }],
    attached: [{
      type: Output
    }]
  });
})();
var _PortalHostDirective = class _PortalHostDirective extends CdkPortalOutlet {
};
_PortalHostDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵPortalHostDirective_BaseFactory;
  return function PortalHostDirective_Factory(t) {
    return (ɵPortalHostDirective_BaseFactory || (ɵPortalHostDirective_BaseFactory = ɵɵgetInheritedFactory(_PortalHostDirective)))(t || _PortalHostDirective);
  };
})();
_PortalHostDirective.ɵdir = ɵɵdefineDirective({
  type: _PortalHostDirective,
  selectors: [["", "cdkPortalHost", ""], ["", "portalHost", ""]],
  inputs: {
    portal: [InputFlags.None, "cdkPortalHost", "portal"]
  },
  exportAs: ["cdkPortalHost"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CdkPortalOutlet,
    useExisting: _PortalHostDirective
  }]), ɵɵInheritDefinitionFeature]
});
var PortalHostDirective = _PortalHostDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalHostDirective, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalHost], [portalHost]",
      exportAs: "cdkPortalHost",
      inputs: [{
        name: "portal",
        alias: "cdkPortalHost"
      }],
      providers: [{
        provide: CdkPortalOutlet,
        useExisting: PortalHostDirective
      }],
      standalone: true
    }]
  }], null, null);
})();
var _PortalModule = class _PortalModule {
};
_PortalModule.ɵfac = function PortalModule_Factory(t) {
  return new (t || _PortalModule)();
};
_PortalModule.ɵmod = ɵɵdefineNgModule({
  type: _PortalModule,
  imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
  exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]
});
_PortalModule.ɵinj = ɵɵdefineInjector({});
var PortalModule = _PortalModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalModule, [{
    type: NgModule,
    args: [{
      imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]
    }]
  }], null, null);
})();
var PortalInjector = class {
  constructor(_parentInjector, _customTokens) {
    this._parentInjector = _parentInjector;
    this._customTokens = _customTokens;
  }
  get(token, notFoundValue) {
    const value = this._customTokens.get(token);
    if (typeof value !== "undefined") {
      return value;
    }
    return this._parentInjector.get(token, notFoundValue);
  }
};

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
  providedIn: "root",
  factory: DIR_DOCUMENT_FACTORY
});
function DIR_DOCUMENT_FACTORY() {
  return inject(DOCUMENT);
}
var RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
var _Directionality = class _Directionality {
  constructor(_document) {
    this.value = "ltr";
    this.change = new EventEmitter();
    if (_document) {
      const bodyDir = _document.body ? _document.body.dir : null;
      const htmlDir = _document.documentElement ? _document.documentElement.dir : null;
      this.value = _resolveDirectionality(bodyDir || htmlDir || "ltr");
    }
  }
  ngOnDestroy() {
    this.change.complete();
  }
};
_Directionality.ɵfac = function Directionality_Factory(t) {
  return new (t || _Directionality)(ɵɵinject(DIR_DOCUMENT, 8));
};
_Directionality.ɵprov = ɵɵdefineInjectable({
  token: _Directionality,
  factory: _Directionality.ɵfac,
  providedIn: "root"
});
var Directionality = _Directionality;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Directionality, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DIR_DOCUMENT]
    }]
  }], null);
})();
var _Dir = class _Dir {
  constructor() {
    this._dir = "ltr";
    this._isInitialized = false;
    this.change = new EventEmitter();
  }
  /** @docs-private */
  get dir() {
    return this._dir;
  }
  set dir(value) {
    const previousValue = this._dir;
    this._dir = _resolveDirectionality(value);
    this._rawDir = value;
    if (previousValue !== this._dir && this._isInitialized) {
      this.change.emit(this._dir);
    }
  }
  /** Current layout direction of the element. */
  get value() {
    return this.dir;
  }
  /** Initialize once default value has been set. */
  ngAfterContentInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    this.change.complete();
  }
};
_Dir.ɵfac = function Dir_Factory(t) {
  return new (t || _Dir)();
};
_Dir.ɵdir = ɵɵdefineDirective({
  type: _Dir,
  selectors: [["", "dir", ""]],
  hostVars: 1,
  hostBindings: function Dir_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("dir", ctx._rawDir);
    }
  },
  inputs: {
    dir: "dir"
  },
  outputs: {
    change: "dirChange"
  },
  exportAs: ["dir"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: Directionality,
    useExisting: _Dir
  }])]
});
var Dir = _Dir;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dir, [{
    type: Directive,
    args: [{
      selector: "[dir]",
      providers: [{
        provide: Directionality,
        useExisting: Dir
      }],
      host: {
        "[attr.dir]": "_rawDir"
      },
      exportAs: "dir",
      standalone: true
    }]
  }], null, {
    change: [{
      type: Output,
      args: ["dirChange"]
    }],
    dir: [{
      type: Input
    }]
  });
})();
var _BidiModule = class _BidiModule {
};
_BidiModule.ɵfac = function BidiModule_Factory(t) {
  return new (t || _BidiModule)();
};
_BidiModule.ɵmod = ɵɵdefineNgModule({
  type: _BidiModule,
  imports: [Dir],
  exports: [Dir]
});
_BidiModule.ɵinj = ɵɵdefineInjector({});
var BidiModule = _BidiModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BidiModule, [{
    type: NgModule,
    args: [{
      imports: [Dir],
      exports: [Dir]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/collections.mjs
var DataSource = class {
};
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}
var ArrayDataSource = class extends DataSource {
  constructor(_data) {
    super();
    this._data = _data;
  }
  connect() {
    return isObservable(this._data) ? this._data : of(this._data);
  }
  disconnect() {
  }
};
var _ViewRepeaterOperation;
(function(_ViewRepeaterOperation2) {
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REPLACED"] = 0] = "REPLACED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["INSERTED"] = 1] = "INSERTED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["MOVED"] = 2] = "MOVED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REMOVED"] = 3] = "REMOVED";
})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));
var _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");
var _DisposeViewRepeaterStrategy = class {
  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
      let view;
      let operation;
      if (record.previousIndex == null) {
        const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);
        view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);
        operation = _ViewRepeaterOperation.INSERTED;
      } else if (currentIndex == null) {
        viewContainerRef.remove(adjustedPreviousIndex);
        operation = _ViewRepeaterOperation.REMOVED;
      } else {
        view = viewContainerRef.get(adjustedPreviousIndex);
        viewContainerRef.move(view, currentIndex);
        operation = _ViewRepeaterOperation.MOVED;
      }
      if (itemViewChanged) {
        itemViewChanged({
          context: view?.context,
          operation,
          record
        });
      }
    });
  }
  detach() {
  }
};
var _RecycleViewRepeaterStrategy = class {
  constructor() {
    this.viewCacheSize = 20;
    this._viewCache = [];
  }
  /** Apply changes to the DOM. */
  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
      let view;
      let operation;
      if (record.previousIndex == null) {
        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);
        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;
      } else if (currentIndex == null) {
        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
        operation = _ViewRepeaterOperation.REMOVED;
      } else {
        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = _ViewRepeaterOperation.MOVED;
      }
      if (itemViewChanged) {
        itemViewChanged({
          context: view?.context,
          operation,
          record
        });
      }
    });
  }
  detach() {
    for (const view of this._viewCache) {
      view.destroy();
    }
    this._viewCache = [];
  }
  /**
   * Inserts a view for a new item, either from the cache or by creating a new
   * one. Returns `undefined` if the item was inserted into a cached view.
   */
  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
    if (cachedView) {
      cachedView.context.$implicit = value;
      return void 0;
    }
    const viewArgs = viewArgsFactory();
    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
  }
  /** Detaches the view at the given index and inserts into the view cache. */
  _detachAndCacheView(index, viewContainerRef) {
    const detachedView = viewContainerRef.detach(index);
    this._maybeCacheView(detachedView, viewContainerRef);
  }
  /** Moves view at the previous index to the current index. */
  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
    const view = viewContainerRef.get(adjustedPreviousIndex);
    viewContainerRef.move(view, currentIndex);
    view.context.$implicit = value;
    return view;
  }
  /**
   * Cache the given detached view. If the cache is full, the view will be
   * destroyed.
   */
  _maybeCacheView(view, viewContainerRef) {
    if (this._viewCache.length < this.viewCacheSize) {
      this._viewCache.push(view);
    } else {
      const index = viewContainerRef.indexOf(view);
      if (index === -1) {
        view.destroy();
      } else {
        viewContainerRef.remove(index);
      }
    }
  }
  /** Inserts a recycled view from the cache at the given index. */
  _insertViewFromCache(index, viewContainerRef) {
    const cachedView = this._viewCache.pop();
    if (cachedView) {
      viewContainerRef.insert(cachedView, index);
    }
    return cachedView || null;
  }
};
var _UniqueSelectionDispatcher = class _UniqueSelectionDispatcher {
  constructor() {
    this._listeners = [];
  }
  /**
   * Notify other items that selection for the given name has been set.
   * @param id ID of the item.
   * @param name Name of the item.
   */
  notify(id, name) {
    for (let listener of this._listeners) {
      listener(id, name);
    }
  }
  /**
   * Listen for future changes to item selection.
   * @return Function used to deregister listener
   */
  listen(listener) {
    this._listeners.push(listener);
    return () => {
      this._listeners = this._listeners.filter((registered) => {
        return listener !== registered;
      });
    };
  }
  ngOnDestroy() {
    this._listeners = [];
  }
};
_UniqueSelectionDispatcher.ɵfac = function UniqueSelectionDispatcher_Factory(t) {
  return new (t || _UniqueSelectionDispatcher)();
};
_UniqueSelectionDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _UniqueSelectionDispatcher,
  factory: _UniqueSelectionDispatcher.ɵfac,
  providedIn: "root"
});
var UniqueSelectionDispatcher = _UniqueSelectionDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UniqueSelectionDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
var _c0 = ["contentWrapper"];
var _c1 = ["*"];
var VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
var FixedSizeVirtualScrollStrategy = class {
  /**
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  constructor(itemSize, minBufferPx, maxBufferPx) {
    this._scrolledIndexChange = new Subject();
    this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
    this._viewport = null;
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
  }
  /**
   * Attaches this scroll strategy to a viewport.
   * @param viewport The viewport to attach this strategy to.
   */
  attach(viewport) {
    this._viewport = viewport;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** Detaches this scroll strategy from the currently attached viewport. */
  detach() {
    this._scrolledIndexChange.complete();
    this._viewport = null;
  }
  /**
   * Update the item size and buffer size.
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
    if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
    }
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentScrolled() {
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onDataLengthChanged() {
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentRendered() {
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onRenderedOffsetChanged() {
  }
  /**
   * Scroll to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling.
   */
  scrollToIndex(index, behavior) {
    if (this._viewport) {
      this._viewport.scrollToOffset(index * this._itemSize, behavior);
    }
  }
  /** Update the viewport's total content size. */
  _updateTotalContentSize() {
    if (!this._viewport) {
      return;
    }
    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
  }
  /** Update the viewport's rendered range. */
  _updateRenderedRange() {
    if (!this._viewport) {
      return;
    }
    const renderedRange = this._viewport.getRenderedRange();
    const newRange = {
      start: renderedRange.start,
      end: renderedRange.end
    };
    const viewportSize = this._viewport.getViewportSize();
    const dataLength = this._viewport.getDataLength();
    let scrollOffset = this._viewport.measureScrollOffset();
    let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
    if (newRange.end > dataLength) {
      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
      const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
      if (firstVisibleIndex != newVisibleIndex) {
        firstVisibleIndex = newVisibleIndex;
        scrollOffset = newVisibleIndex * this._itemSize;
        newRange.start = Math.floor(firstVisibleIndex);
      }
      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
    }
    const startBuffer = scrollOffset - newRange.start * this._itemSize;
    if (startBuffer < this._minBufferPx && newRange.start != 0) {
      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
      newRange.start = Math.max(0, newRange.start - expandStart);
      newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
    } else {
      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
        if (expandEnd > 0) {
          newRange.end = Math.min(dataLength, newRange.end + expandEnd);
          newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
        }
      }
    }
    this._viewport.setRenderedRange(newRange);
    this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
  }
};
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
var _CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
  constructor() {
    this._itemSize = 20;
    this._minBufferPx = 100;
    this._maxBufferPx = 200;
    this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
  /** The size of the items in the list (in pixels). */
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(value) {
    this._itemSize = coerceNumberProperty(value);
  }
  /**
   * The minimum amount of buffer rendered beyond the viewport (in pixels).
   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
   */
  get minBufferPx() {
    return this._minBufferPx;
  }
  set minBufferPx(value) {
    this._minBufferPx = coerceNumberProperty(value);
  }
  /**
   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
   */
  get maxBufferPx() {
    return this._maxBufferPx;
  }
  set maxBufferPx(value) {
    this._maxBufferPx = coerceNumberProperty(value);
  }
  ngOnChanges() {
    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
};
_CdkFixedSizeVirtualScroll.ɵfac = function CdkFixedSizeVirtualScroll_Factory(t) {
  return new (t || _CdkFixedSizeVirtualScroll)();
};
_CdkFixedSizeVirtualScroll.ɵdir = ɵɵdefineDirective({
  type: _CdkFixedSizeVirtualScroll,
  selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
  inputs: {
    itemSize: "itemSize",
    minBufferPx: "minBufferPx",
    maxBufferPx: "maxBufferPx"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: VIRTUAL_SCROLL_STRATEGY,
    useFactory: _fixedSizeVirtualScrollStrategyFactory,
    deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
  }]), ɵɵNgOnChangesFeature]
});
var CdkFixedSizeVirtualScroll = _CdkFixedSizeVirtualScroll;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFixedSizeVirtualScroll, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[itemSize]",
      standalone: true,
      providers: [{
        provide: VIRTUAL_SCROLL_STRATEGY,
        useFactory: _fixedSizeVirtualScrollStrategyFactory,
        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
      }]
    }]
  }], null, {
    itemSize: [{
      type: Input
    }],
    minBufferPx: [{
      type: Input
    }],
    maxBufferPx: [{
      type: Input
    }]
  });
})();
var DEFAULT_SCROLL_TIME = 20;
var _ScrollDispatcher = class _ScrollDispatcher {
  constructor(_ngZone, _platform, document2) {
    this._ngZone = _ngZone;
    this._platform = _platform;
    this._scrolled = new Subject();
    this._globalSubscription = null;
    this._scrolledCount = 0;
    this.scrollContainers = /* @__PURE__ */ new Map();
    this._document = document2;
  }
  /**
   * Registers a scrollable instance with the service and listens for its scrolled events. When the
   * scrollable is scrolled, the service emits the event to its scrolled observable.
   * @param scrollable Scrollable instance to be registered.
   */
  register(scrollable) {
    if (!this.scrollContainers.has(scrollable)) {
      this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
    }
  }
  /**
   * De-registers a Scrollable reference and unsubscribes from its scroll event observable.
   * @param scrollable Scrollable instance to be deregistered.
   */
  deregister(scrollable) {
    const scrollableReference = this.scrollContainers.get(scrollable);
    if (scrollableReference) {
      scrollableReference.unsubscribe();
      this.scrollContainers.delete(scrollable);
    }
  }
  /**
   * Returns an observable that emits an event whenever any of the registered Scrollable
   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
   * to override the default "throttle" time.
   *
   * **Note:** in order to avoid hitting change detection for every scroll event,
   * all of the events emitted from this stream will be run outside the Angular zone.
   * If you need to update any data bindings as a result of a scroll event, you have
   * to run the callback using `NgZone.run`.
   */
  scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
    if (!this._platform.isBrowser) {
      return of();
    }
    return new Observable((observer) => {
      if (!this._globalSubscription) {
        this._addGlobalListener();
      }
      const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
      this._scrolledCount++;
      return () => {
        subscription.unsubscribe();
        this._scrolledCount--;
        if (!this._scrolledCount) {
          this._removeGlobalListener();
        }
      };
    });
  }
  ngOnDestroy() {
    this._removeGlobalListener();
    this.scrollContainers.forEach((_, container) => this.deregister(container));
    this._scrolled.complete();
  }
  /**
   * Returns an observable that emits whenever any of the
   * scrollable ancestors of an element are scrolled.
   * @param elementOrElementRef Element whose ancestors to listen for.
   * @param auditTimeInMs Time to throttle the scroll events.
   */
  ancestorScrolled(elementOrElementRef, auditTimeInMs) {
    const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
    return this.scrolled(auditTimeInMs).pipe(filter((target) => {
      return !target || ancestors.indexOf(target) > -1;
    }));
  }
  /** Returns all registered Scrollables that contain the provided element. */
  getAncestorScrollContainers(elementOrElementRef) {
    const scrollingContainers = [];
    this.scrollContainers.forEach((_subscription, scrollable) => {
      if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
        scrollingContainers.push(scrollable);
      }
    });
    return scrollingContainers;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Returns true if the element is contained within the provided Scrollable. */
  _scrollableContainsElement(scrollable, elementOrElementRef) {
    let element = coerceElement(elementOrElementRef);
    let scrollableElement = scrollable.getElementRef().nativeElement;
    do {
      if (element == scrollableElement) {
        return true;
      }
    } while (element = element.parentElement);
    return false;
  }
  /** Sets up the global scroll listeners. */
  _addGlobalListener() {
    this._globalSubscription = this._ngZone.runOutsideAngular(() => {
      const window2 = this._getWindow();
      return fromEvent(window2.document, "scroll").subscribe(() => this._scrolled.next());
    });
  }
  /** Cleans up the global scroll listener. */
  _removeGlobalListener() {
    if (this._globalSubscription) {
      this._globalSubscription.unsubscribe();
      this._globalSubscription = null;
    }
  }
};
_ScrollDispatcher.ɵfac = function ScrollDispatcher_Factory(t) {
  return new (t || _ScrollDispatcher)(ɵɵinject(NgZone), ɵɵinject(Platform), ɵɵinject(DOCUMENT, 8));
};
_ScrollDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _ScrollDispatcher,
  factory: _ScrollDispatcher.ɵfac,
  providedIn: "root"
});
var ScrollDispatcher = _ScrollDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NgZone
  }, {
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _CdkScrollable = class _CdkScrollable {
  constructor(elementRef, scrollDispatcher, ngZone, dir) {
    this.elementRef = elementRef;
    this.scrollDispatcher = scrollDispatcher;
    this.ngZone = ngZone;
    this.dir = dir;
    this._destroyed = new Subject();
    this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, "scroll").pipe(takeUntil(this._destroyed)).subscribe(observer)));
  }
  ngOnInit() {
    this.scrollDispatcher.register(this);
  }
  ngOnDestroy() {
    this.scrollDispatcher.deregister(this);
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Returns observable that emits when a scroll event is fired on the host element. */
  elementScrolled() {
    return this._elementScrolled;
  }
  /** Gets the ElementRef for the viewport. */
  getElementRef() {
    return this.elementRef;
  }
  /**
   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param options specified the offsets to scroll to.
   */
  scrollTo(options) {
    const el = this.elementRef.nativeElement;
    const isRtl = this.dir && this.dir.value == "rtl";
    if (options.left == null) {
      options.left = isRtl ? options.end : options.start;
    }
    if (options.right == null) {
      options.right = isRtl ? options.start : options.end;
    }
    if (options.bottom != null) {
      options.top = el.scrollHeight - el.clientHeight - options.bottom;
    }
    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
      if (options.left != null) {
        options.right = el.scrollWidth - el.clientWidth - options.left;
      }
      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
        options.left = options.right;
      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
        options.left = options.right ? -options.right : options.right;
      }
    } else {
      if (options.right != null) {
        options.left = el.scrollWidth - el.clientWidth - options.right;
      }
    }
    this._applyScrollToOptions(options);
  }
  _applyScrollToOptions(options) {
    const el = this.elementRef.nativeElement;
    if (supportsScrollBehavior()) {
      el.scrollTo(options);
    } else {
      if (options.top != null) {
        el.scrollTop = options.top;
      }
      if (options.left != null) {
        el.scrollLeft = options.left;
      }
    }
  }
  /**
   * Measures the scroll offset relative to the specified edge of the viewport. This method can be
   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
   * about what scrollLeft means in RTL. The values returned by this method are normalized such that
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param from The edge to measure from.
   */
  measureScrollOffset(from2) {
    const LEFT = "left";
    const RIGHT = "right";
    const el = this.elementRef.nativeElement;
    if (from2 == "top") {
      return el.scrollTop;
    }
    if (from2 == "bottom") {
      return el.scrollHeight - el.clientHeight - el.scrollTop;
    }
    const isRtl = this.dir && this.dir.value == "rtl";
    if (from2 == "start") {
      from2 = isRtl ? RIGHT : LEFT;
    } else if (from2 == "end") {
      from2 = isRtl ? LEFT : RIGHT;
    }
    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
      if (from2 == LEFT) {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      } else {
        return el.scrollLeft;
      }
    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
      if (from2 == LEFT) {
        return el.scrollLeft + el.scrollWidth - el.clientWidth;
      } else {
        return -el.scrollLeft;
      }
    } else {
      if (from2 == LEFT) {
        return el.scrollLeft;
      } else {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      }
    }
  }
};
_CdkScrollable.ɵfac = function CdkScrollable_Factory(t) {
  return new (t || _CdkScrollable)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkScrollable.ɵdir = ɵɵdefineDirective({
  type: _CdkScrollable,
  selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]],
  standalone: true
});
var CdkScrollable = _CdkScrollable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollable, [{
    type: Directive,
    args: [{
      selector: "[cdk-scrollable], [cdkScrollable]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var DEFAULT_RESIZE_TIME = 20;
var _ViewportRuler = class _ViewportRuler {
  constructor(_platform, ngZone, document2) {
    this._platform = _platform;
    this._change = new Subject();
    this._changeListener = (event) => {
      this._change.next(event);
    };
    this._document = document2;
    ngZone.runOutsideAngular(() => {
      if (_platform.isBrowser) {
        const window2 = this._getWindow();
        window2.addEventListener("resize", this._changeListener);
        window2.addEventListener("orientationchange", this._changeListener);
      }
      this.change().subscribe(() => this._viewportSize = null);
    });
  }
  ngOnDestroy() {
    if (this._platform.isBrowser) {
      const window2 = this._getWindow();
      window2.removeEventListener("resize", this._changeListener);
      window2.removeEventListener("orientationchange", this._changeListener);
    }
    this._change.complete();
  }
  /** Returns the viewport's width and height. */
  getViewportSize() {
    if (!this._viewportSize) {
      this._updateViewportSize();
    }
    const output = {
      width: this._viewportSize.width,
      height: this._viewportSize.height
    };
    if (!this._platform.isBrowser) {
      this._viewportSize = null;
    }
    return output;
  }
  /** Gets a DOMRect for the viewport's bounds. */
  getViewportRect() {
    const scrollPosition = this.getViewportScrollPosition();
    const {
      width,
      height
    } = this.getViewportSize();
    return {
      top: scrollPosition.top,
      left: scrollPosition.left,
      bottom: scrollPosition.top + height,
      right: scrollPosition.left + width,
      height,
      width
    };
  }
  /** Gets the (top, left) scroll position of the viewport. */
  getViewportScrollPosition() {
    if (!this._platform.isBrowser) {
      return {
        top: 0,
        left: 0
      };
    }
    const document2 = this._document;
    const window2 = this._getWindow();
    const documentElement = document2.documentElement;
    const documentRect = documentElement.getBoundingClientRect();
    const top = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
    const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
    return {
      top,
      left
    };
  }
  /**
   * Returns a stream that emits whenever the size of the viewport changes.
   * This stream emits outside of the Angular zone.
   * @param throttleTime Time in milliseconds to throttle the stream.
   */
  change(throttleTime = DEFAULT_RESIZE_TIME) {
    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Updates the cached viewport size. */
  _updateViewportSize() {
    const window2 = this._getWindow();
    this._viewportSize = this._platform.isBrowser ? {
      width: window2.innerWidth,
      height: window2.innerHeight
    } : {
      width: 0,
      height: 0
    };
  }
};
_ViewportRuler.ɵfac = function ViewportRuler_Factory(t) {
  return new (t || _ViewportRuler)(ɵɵinject(Platform), ɵɵinject(NgZone), ɵɵinject(DOCUMENT, 8));
};
_ViewportRuler.ɵprov = ɵɵdefineInjectable({
  token: _ViewportRuler,
  factory: _ViewportRuler.ɵfac,
  providedIn: "root"
});
var ViewportRuler = _ViewportRuler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportRuler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
var _CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
  constructor(elementRef, scrollDispatcher, ngZone, dir) {
    super(elementRef, scrollDispatcher, ngZone, dir);
  }
  /**
   * Measure the viewport size for the provided orientation.
   *
   * @param orientation The orientation to measure the size from.
   */
  measureViewportSize(orientation) {
    const viewportEl = this.elementRef.nativeElement;
    return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
  }
};
_CdkVirtualScrollable.ɵfac = function CdkVirtualScrollable_Factory(t) {
  return new (t || _CdkVirtualScrollable)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkVirtualScrollable.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualScrollable,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkVirtualScrollable = _CdkVirtualScrollable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollable, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
function rangesEqual(r1, r2) {
  return r1.start == r2.start && r1.end == r2.end;
}
var SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
var _CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
  /** The direction the viewport scrolls. */
  get orientation() {
    return this._orientation;
  }
  set orientation(orientation) {
    if (this._orientation !== orientation) {
      this._orientation = orientation;
      this._calculateSpacerSize();
    }
  }
  constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler, scrollable) {
    super(elementRef, scrollDispatcher, ngZone, dir);
    this.elementRef = elementRef;
    this._changeDetectorRef = _changeDetectorRef;
    this._scrollStrategy = _scrollStrategy;
    this.scrollable = scrollable;
    this._platform = inject(Platform);
    this._detachedSubject = new Subject();
    this._renderedRangeSubject = new Subject();
    this._orientation = "vertical";
    this.appendOnly = false;
    this.scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
    this.renderedRangeStream = this._renderedRangeSubject;
    this._totalContentSize = 0;
    this._totalContentWidth = "";
    this._totalContentHeight = "";
    this._renderedRange = {
      start: 0,
      end: 0
    };
    this._dataLength = 0;
    this._viewportSize = 0;
    this._renderedContentOffset = 0;
    this._renderedContentOffsetNeedsRewrite = false;
    this._isChangeDetectionPending = false;
    this._runAfterChangeDetection = [];
    this._viewportChanges = Subscription.EMPTY;
    if (!_scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
    }
    this._viewportChanges = viewportRuler.change().subscribe(() => {
      this.checkViewportSize();
    });
    if (!this.scrollable) {
      this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
      this.scrollable = this;
    }
  }
  ngOnInit() {
    if (!this._platform.isBrowser) {
      return;
    }
    if (this.scrollable === this) {
      super.ngOnInit();
    }
    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
      this._measureViewportSize();
      this._scrollStrategy.attach(this);
      this.scrollable.elementScrolled().pipe(
        // Start off with a fake scroll event so we properly detect our initial position.
        startWith(null),
        // Collect multiple events into one until the next animation frame. This way if
        // there are multiple scroll events in the same frame we only need to recheck
        // our layout once.
        auditTime(0, SCROLL_SCHEDULER),
        // Usually `elementScrolled` is completed when the scrollable is destroyed, but
        // that may not be the case if a `CdkVirtualScrollableElement` is used so we have
        // to unsubscribe here just in case.
        takeUntil(this._destroyed)
      ).subscribe(() => this._scrollStrategy.onContentScrolled());
      this._markChangeDetectionNeeded();
    }));
  }
  ngOnDestroy() {
    this.detach();
    this._scrollStrategy.detach();
    this._renderedRangeSubject.complete();
    this._detachedSubject.complete();
    this._viewportChanges.unsubscribe();
    super.ngOnDestroy();
  }
  /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
  attach(forOf) {
    if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CdkVirtualScrollViewport is already attached.");
    }
    this.ngZone.runOutsideAngular(() => {
      this._forOf = forOf;
      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data) => {
        const newLength = data.length;
        if (newLength !== this._dataLength) {
          this._dataLength = newLength;
          this._scrollStrategy.onDataLengthChanged();
        }
        this._doChangeDetection();
      });
    });
  }
  /** Detaches the current `CdkVirtualForOf`. */
  detach() {
    this._forOf = null;
    this._detachedSubject.next();
  }
  /** Gets the length of the data bound to this viewport (in number of items). */
  getDataLength() {
    return this._dataLength;
  }
  /** Gets the size of the viewport (in pixels). */
  getViewportSize() {
    return this._viewportSize;
  }
  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
  // cycle happens. I'm being careful to only call it after the render cycle is complete and before
  // setting it to something else, but its error prone and should probably be split into
  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
  /** Get the current rendered range of items. */
  getRenderedRange() {
    return this._renderedRange;
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
  }
  /**
   * Sets the total size of all content (in pixels), including content that is not currently
   * rendered.
   */
  setTotalContentSize(size) {
    if (this._totalContentSize !== size) {
      this._totalContentSize = size;
      this._calculateSpacerSize();
      this._markChangeDetectionNeeded();
    }
  }
  /** Sets the currently rendered range of indices. */
  setRenderedRange(range2) {
    if (!rangesEqual(this._renderedRange, range2)) {
      if (this.appendOnly) {
        range2 = {
          start: 0,
          end: Math.max(this._renderedRange.end, range2.end)
        };
      }
      this._renderedRangeSubject.next(this._renderedRange = range2);
      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
    }
  }
  /**
   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
   */
  getOffsetToRenderedContentStart() {
    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
  }
  /**
   * Sets the offset from the start of the viewport to either the start or end of the rendered data
   * (in pixels).
   */
  setRenderedContentOffset(offset, to = "to-start") {
    offset = this.appendOnly && to === "to-start" ? 0 : offset;
    const isRtl = this.dir && this.dir.value == "rtl";
    const isHorizontal = this.orientation == "horizontal";
    const axis = isHorizontal ? "X" : "Y";
    const axisDirection = isHorizontal && isRtl ? -1 : 1;
    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
    this._renderedContentOffset = offset;
    if (to === "to-end") {
      transform += ` translate${axis}(-100%)`;
      this._renderedContentOffsetNeedsRewrite = true;
    }
    if (this._renderedContentTransform != transform) {
      this._renderedContentTransform = transform;
      this._markChangeDetectionNeeded(() => {
        if (this._renderedContentOffsetNeedsRewrite) {
          this._renderedContentOffset -= this.measureRenderedContentSize();
          this._renderedContentOffsetNeedsRewrite = false;
          this.setRenderedContentOffset(this._renderedContentOffset);
        } else {
          this._scrollStrategy.onRenderedOffsetChanged();
        }
      });
    }
  }
  /**
   * Scrolls to the given offset from the start of the viewport. Please note that this is not always
   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
   * direction, this would be the equivalent of setting a fictional `scrollRight` property.
   * @param offset The offset to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToOffset(offset, behavior = "auto") {
    const options = {
      behavior
    };
    if (this.orientation === "horizontal") {
      options.start = offset;
    } else {
      options.top = offset;
    }
    this.scrollable.scrollTo(options);
  }
  /**
   * Scrolls to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToIndex(index, behavior = "auto") {
    this._scrollStrategy.scrollToIndex(index, behavior);
  }
  /**
   * Gets the current scroll offset from the start of the scrollable (in pixels).
   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
   *     in horizontal mode.
   */
  measureScrollOffset(from2) {
    let measureScrollOffset;
    if (this.scrollable == this) {
      measureScrollOffset = (_from) => super.measureScrollOffset(_from);
    } else {
      measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);
    }
    return Math.max(0, measureScrollOffset(from2 ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
  }
  /**
   * Measures the offset of the viewport from the scrolling container
   * @param from The edge to measure from.
   */
  measureViewportOffset(from2) {
    let fromRect;
    const LEFT = "left";
    const RIGHT = "right";
    const isRtl = this.dir?.value == "rtl";
    if (from2 == "start") {
      fromRect = isRtl ? RIGHT : LEFT;
    } else if (from2 == "end") {
      fromRect = isRtl ? LEFT : RIGHT;
    } else if (from2) {
      fromRect = from2;
    } else {
      fromRect = this.orientation === "horizontal" ? "left" : "top";
    }
    const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
    const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
    return viewportClientRect - scrollerClientRect;
  }
  /** Measure the combined size of all of the rendered items. */
  measureRenderedContentSize() {
    const contentEl = this._contentWrapper.nativeElement;
    return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
  }
  /**
   * Measure the total combined size of the given range. Throws if the range includes items that are
   * not rendered.
   */
  measureRangeSize(range2) {
    if (!this._forOf) {
      return 0;
    }
    return this._forOf.measureRangeSize(range2, this.orientation);
  }
  /** Update the viewport dimensions and re-render. */
  checkViewportSize() {
    this._measureViewportSize();
    this._scrollStrategy.onDataLengthChanged();
  }
  /** Measure the viewport size. */
  _measureViewportSize() {
    this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
  }
  /** Queue up change detection to run. */
  _markChangeDetectionNeeded(runAfter) {
    if (runAfter) {
      this._runAfterChangeDetection.push(runAfter);
    }
    if (!this._isChangeDetectionPending) {
      this._isChangeDetectionPending = true;
      this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
        this._doChangeDetection();
      }));
    }
  }
  /** Run change detection. */
  _doChangeDetection() {
    this._isChangeDetectionPending = false;
    this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
    this.ngZone.run(() => this._changeDetectorRef.markForCheck());
    const runAfterChangeDetection = this._runAfterChangeDetection;
    this._runAfterChangeDetection = [];
    for (const fn of runAfterChangeDetection) {
      fn();
    }
  }
  /** Calculates the `style.width` and `style.height` for the spacer element. */
  _calculateSpacerSize() {
    this._totalContentHeight = this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`;
    this._totalContentWidth = this.orientation === "horizontal" ? `${this._totalContentSize}px` : "";
  }
};
_CdkVirtualScrollViewport.ɵfac = function CdkVirtualScrollViewport_Factory(t) {
  return new (t || _CdkVirtualScrollViewport)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(VIRTUAL_SCROLL_STRATEGY, 8), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(VIRTUAL_SCROLLABLE, 8));
};
_CdkVirtualScrollViewport.ɵcmp = ɵɵdefineComponent({
  type: _CdkVirtualScrollViewport,
  selectors: [["cdk-virtual-scroll-viewport"]],
  viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentWrapper = _t.first);
    }
  },
  hostAttrs: [1, "cdk-virtual-scroll-viewport"],
  hostVars: 4,
  hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
    }
  },
  inputs: {
    orientation: "orientation",
    appendOnly: [InputFlags.HasDecoratorInputTransform, "appendOnly", "appendOnly", booleanAttribute]
  },
  outputs: {
    scrolledIndexChange: "scrolledIndexChange"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CdkScrollable,
    useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
    deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], _CdkVirtualScrollViewport]
  }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
  ngContentSelectors: _c1,
  decls: 4,
  vars: 4,
  consts: [["contentWrapper", ""], [1, "cdk-virtual-scroll-content-wrapper"], [1, "cdk-virtual-scroll-spacer"]],
  template: function CdkVirtualScrollViewport_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 1, 0);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelement(3, "div", 2);
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵstyleProp("width", ctx._totalContentWidth)("height", ctx._totalContentHeight);
    }
  },
  styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"],
  encapsulation: 2,
  changeDetection: 0
});
var CdkVirtualScrollViewport = _CdkVirtualScrollViewport;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollViewport, [{
    type: Component,
    args: [{
      selector: "cdk-virtual-scroll-viewport",
      host: {
        "class": "cdk-virtual-scroll-viewport",
        "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
        "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      providers: [{
        provide: CdkScrollable,
        useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
        deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]
      }],
      template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth" [style.height]="_totalContentHeight"></div>\n',
      styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [VIRTUAL_SCROLL_STRATEGY]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ScrollDispatcher
  }, {
    type: ViewportRuler
  }, {
    type: CdkVirtualScrollable,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [VIRTUAL_SCROLLABLE]
    }]
  }], {
    orientation: [{
      type: Input
    }],
    appendOnly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    scrolledIndexChange: [{
      type: Output
    }],
    _contentWrapper: [{
      type: ViewChild,
      args: ["contentWrapper", {
        static: true
      }]
    }]
  });
})();
function getOffset(orientation, direction, node) {
  const el = node;
  if (!el.getBoundingClientRect) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
var _CdkVirtualForOf = class _CdkVirtualForOf {
  /** The DataSource to display. */
  get cdkVirtualForOf() {
    return this._cdkVirtualForOf;
  }
  set cdkVirtualForOf(value) {
    this._cdkVirtualForOf = value;
    if (isDataSource(value)) {
      this._dataSourceChanges.next(value);
    } else {
      this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
    }
  }
  /**
   * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
   * the item and produces a value to be used as the item's identity when tracking changes.
   */
  get cdkVirtualForTrackBy() {
    return this._cdkVirtualForTrackBy;
  }
  set cdkVirtualForTrackBy(fn) {
    this._needsUpdate = true;
    this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
  }
  /** The template used to stamp out new elements. */
  set cdkVirtualForTemplate(value) {
    if (value) {
      this._needsUpdate = true;
      this._template = value;
    }
  }
  /**
   * The size of the cache used to store templates that are not being used for re-use later.
   * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
   */
  get cdkVirtualForTemplateCacheSize() {
    return this._viewRepeater.viewCacheSize;
  }
  set cdkVirtualForTemplateCacheSize(size) {
    this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
  }
  constructor(_viewContainerRef, _template, _differs, _viewRepeater, _viewport, ngZone) {
    this._viewContainerRef = _viewContainerRef;
    this._template = _template;
    this._differs = _differs;
    this._viewRepeater = _viewRepeater;
    this._viewport = _viewport;
    this.viewChange = new Subject();
    this._dataSourceChanges = new Subject();
    this.dataStream = this._dataSourceChanges.pipe(
      // Start off with null `DataSource`.
      startWith(null),
      // Bundle up the previous and current data sources so we can work with both.
      pairwise(),
      // Use `_changeDataSource` to disconnect from the previous data source and connect to the
      // new one, passing back a stream of data changes which we run through `switchMap` to give
      // us a data stream that emits the latest data from whatever the current `DataSource` is.
      switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),
      // Replay the last emitted data when someone subscribes.
      shareReplay(1)
    );
    this._differ = null;
    this._needsUpdate = false;
    this._destroyed = new Subject();
    this.dataStream.subscribe((data) => {
      this._data = data;
      this._onRenderedDataChange();
    });
    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range2) => {
      this._renderedRange = range2;
      if (this.viewChange.observers.length) {
        ngZone.run(() => this.viewChange.next(this._renderedRange));
      }
      this._onRenderedDataChange();
    });
    this._viewport.attach(this);
  }
  /**
   * Measures the combined size (width for horizontal orientation, height for vertical) of all items
   * in the specified range. Throws an error if the range includes items that are not currently
   * rendered.
   */
  measureRangeSize(range2, orientation) {
    if (range2.start >= range2.end) {
      return 0;
    }
    if ((range2.start < this._renderedRange.start || range2.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Error: attempted to measure an item that isn't rendered.`);
    }
    const renderedStartIndex = range2.start - this._renderedRange.start;
    const rangeLen = range2.end - range2.start;
    let firstNode;
    let lastNode;
    for (let i = 0; i < rangeLen; i++) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        firstNode = lastNode = view.rootNodes[0];
        break;
      }
    }
    for (let i = rangeLen - 1; i > -1; i--) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        lastNode = view.rootNodes[view.rootNodes.length - 1];
        break;
      }
    }
    return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
  }
  ngDoCheck() {
    if (this._differ && this._needsUpdate) {
      const changes = this._differ.diff(this._renderedItems);
      if (!changes) {
        this._updateContext();
      } else {
        this._applyChanges(changes);
      }
      this._needsUpdate = false;
    }
  }
  ngOnDestroy() {
    this._viewport.detach();
    this._dataSourceChanges.next(void 0);
    this._dataSourceChanges.complete();
    this.viewChange.complete();
    this._destroyed.next();
    this._destroyed.complete();
    this._viewRepeater.detach();
  }
  /** React to scroll state changes in the viewport. */
  _onRenderedDataChange() {
    if (!this._renderedRange) {
      return;
    }
    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
    if (!this._differ) {
      this._differ = this._differs.find(this._renderedItems).create((index, item) => {
        return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
      });
    }
    this._needsUpdate = true;
  }
  /** Swap out one `DataSource` for another. */
  _changeDataSource(oldDs, newDs) {
    if (oldDs) {
      oldDs.disconnect(this);
    }
    this._needsUpdate = true;
    return newDs ? newDs.connect(this) : of();
  }
  /** Update the `CdkVirtualForOfContext` for all views. */
  _updateContext() {
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
      view.detectChanges();
    }
  }
  /** Apply changes to the DOM. */
  _applyChanges(changes) {
    this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
    changes.forEachIdentityChange((record) => {
      const view = this._viewContainerRef.get(record.currentIndex);
      view.context.$implicit = record.item;
    });
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
    }
  }
  /** Update the computed properties on the `CdkVirtualForOfContext`. */
  _updateComputedContextProperties(context) {
    context.first = context.index === 0;
    context.last = context.index === context.count - 1;
    context.even = context.index % 2 === 0;
    context.odd = !context.even;
  }
  _getEmbeddedViewArgs(record, index) {
    return {
      templateRef: this._template,
      context: {
        $implicit: record.item,
        // It's guaranteed that the iterable is not "undefined" or "null" because we only
        // generate views for elements if the "cdkVirtualForOf" iterable has elements.
        cdkVirtualForOf: this._cdkVirtualForOf,
        index: -1,
        count: -1,
        first: false,
        last: false,
        odd: false,
        even: false
      },
      index
    };
  }
};
_CdkVirtualForOf.ɵfac = function CdkVirtualForOf_Factory(t) {
  return new (t || _CdkVirtualForOf)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(CdkVirtualScrollViewport, 4), ɵɵdirectiveInject(NgZone));
};
_CdkVirtualForOf.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualForOf,
  selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
  inputs: {
    cdkVirtualForOf: "cdkVirtualForOf",
    cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
    cdkVirtualForTemplate: "cdkVirtualForTemplate",
    cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: _VIEW_REPEATER_STRATEGY,
    useClass: _RecycleViewRepeaterStrategy
  }])]
});
var CdkVirtualForOf = _CdkVirtualForOf;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualForOf, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualFor][cdkVirtualForOf]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }],
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: _RecycleViewRepeaterStrategy,
    decorators: [{
      type: Inject,
      args: [_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: CdkVirtualScrollViewport,
    decorators: [{
      type: SkipSelf
    }]
  }, {
    type: NgZone
  }], {
    cdkVirtualForOf: [{
      type: Input
    }],
    cdkVirtualForTrackBy: [{
      type: Input
    }],
    cdkVirtualForTemplate: [{
      type: Input
    }],
    cdkVirtualForTemplateCacheSize: [{
      type: Input
    }]
  });
})();
var _CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
  constructor(elementRef, scrollDispatcher, ngZone, dir) {
    super(elementRef, scrollDispatcher, ngZone, dir);
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2] - this.measureScrollOffset(from2);
  }
};
_CdkVirtualScrollableElement.ɵfac = function CdkVirtualScrollableElement_Factory(t) {
  return new (t || _CdkVirtualScrollableElement)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkVirtualScrollableElement.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualScrollableElement,
  selectors: [["", "cdkVirtualScrollingElement", ""]],
  hostAttrs: [1, "cdk-virtual-scrollable"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: VIRTUAL_SCROLLABLE,
    useExisting: _CdkVirtualScrollableElement
  }]), ɵɵInheritDefinitionFeature]
});
var CdkVirtualScrollableElement = _CdkVirtualScrollableElement;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableElement, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualScrollingElement]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableElement
      }],
      standalone: true,
      host: {
        "class": "cdk-virtual-scrollable"
      }
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
  constructor(scrollDispatcher, ngZone, dir) {
    super(new ElementRef(document.documentElement), scrollDispatcher, ngZone, dir);
    this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(document, "scroll").pipe(takeUntil(this._destroyed)).subscribe(observer)));
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
  }
};
_CdkVirtualScrollableWindow.ɵfac = function CdkVirtualScrollableWindow_Factory(t) {
  return new (t || _CdkVirtualScrollableWindow)(ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkVirtualScrollableWindow.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualScrollableWindow,
  selectors: [["cdk-virtual-scroll-viewport", "scrollWindow", ""]],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: VIRTUAL_SCROLLABLE,
    useExisting: _CdkVirtualScrollableWindow
  }]), ɵɵInheritDefinitionFeature]
});
var CdkVirtualScrollableWindow = _CdkVirtualScrollableWindow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableWindow, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[scrollWindow]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableWindow
      }],
      standalone: true
    }]
  }], () => [{
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _CdkScrollableModule = class _CdkScrollableModule {
};
_CdkScrollableModule.ɵfac = function CdkScrollableModule_Factory(t) {
  return new (t || _CdkScrollableModule)();
};
_CdkScrollableModule.ɵmod = ɵɵdefineNgModule({
  type: _CdkScrollableModule,
  imports: [CdkScrollable],
  exports: [CdkScrollable]
});
_CdkScrollableModule.ɵinj = ɵɵdefineInjector({});
var CdkScrollableModule = _CdkScrollableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollableModule, [{
    type: NgModule,
    args: [{
      exports: [CdkScrollable],
      imports: [CdkScrollable]
    }]
  }], null, null);
})();
var _ScrollingModule = class _ScrollingModule {
};
_ScrollingModule.ɵfac = function ScrollingModule_Factory(t) {
  return new (t || _ScrollingModule)();
};
_ScrollingModule.ɵmod = ɵɵdefineNgModule({
  type: _ScrollingModule,
  imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
  exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
});
_ScrollingModule.ɵinj = ɵɵdefineInjector({
  imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]
});
var ScrollingModule = _ScrollingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
      exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/overlay.mjs
var scrollBehaviorSupported2 = supportsScrollBehavior();
var BlockScrollStrategy = class {
  constructor(_viewportRuler, document2) {
    this._viewportRuler = _viewportRuler;
    this._previousHTMLStyles = {
      top: "",
      left: ""
    };
    this._isEnabled = false;
    this._document = document2;
  }
  /** Attaches this scroll strategy to an overlay. */
  attach() {
  }
  /** Blocks page-level scroll while the attached overlay is open. */
  enable() {
    if (this._canBeEnabled()) {
      const root = this._document.documentElement;
      this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();
      this._previousHTMLStyles.left = root.style.left || "";
      this._previousHTMLStyles.top = root.style.top || "";
      root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);
      root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);
      root.classList.add("cdk-global-scrollblock");
      this._isEnabled = true;
    }
  }
  /** Unblocks page-level scroll while the attached overlay is open. */
  disable() {
    if (this._isEnabled) {
      const html = this._document.documentElement;
      const body = this._document.body;
      const htmlStyle = html.style;
      const bodyStyle = body.style;
      const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || "";
      const previousBodyScrollBehavior = bodyStyle.scrollBehavior || "";
      this._isEnabled = false;
      htmlStyle.left = this._previousHTMLStyles.left;
      htmlStyle.top = this._previousHTMLStyles.top;
      html.classList.remove("cdk-global-scrollblock");
      if (scrollBehaviorSupported2) {
        htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = "auto";
      }
      window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
      if (scrollBehaviorSupported2) {
        htmlStyle.scrollBehavior = previousHtmlScrollBehavior;
        bodyStyle.scrollBehavior = previousBodyScrollBehavior;
      }
    }
  }
  _canBeEnabled() {
    const html = this._document.documentElement;
    if (html.classList.contains("cdk-global-scrollblock") || this._isEnabled) {
      return false;
    }
    const body = this._document.body;
    const viewport = this._viewportRuler.getViewportSize();
    return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
  }
};
function getMatScrollStrategyAlreadyAttachedError() {
  return Error(`Scroll strategy has already been attached.`);
}
var CloseScrollStrategy = class {
  constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
    this._scrollDispatcher = _scrollDispatcher;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._config = _config;
    this._scrollSubscription = null;
    this._detach = () => {
      this.disable();
      if (this._overlayRef.hasAttached()) {
        this._ngZone.run(() => this._overlayRef.detach());
      }
    };
  }
  /** Attaches this scroll strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatScrollStrategyAlreadyAttachedError();
    }
    this._overlayRef = overlayRef;
  }
  /** Enables the closing of the attached overlay on scroll. */
  enable() {
    if (this._scrollSubscription) {
      return;
    }
    const stream = this._scrollDispatcher.scrolled(0).pipe(filter((scrollable) => {
      return !scrollable || !this._overlayRef.overlayElement.contains(scrollable.getElementRef().nativeElement);
    }));
    if (this._config && this._config.threshold && this._config.threshold > 1) {
      this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;
      this._scrollSubscription = stream.subscribe(() => {
        const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;
        if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {
          this._detach();
        } else {
          this._overlayRef.updatePosition();
        }
      });
    } else {
      this._scrollSubscription = stream.subscribe(this._detach);
    }
  }
  /** Disables the closing the attached overlay on scroll. */
  disable() {
    if (this._scrollSubscription) {
      this._scrollSubscription.unsubscribe();
      this._scrollSubscription = null;
    }
  }
  detach() {
    this.disable();
    this._overlayRef = null;
  }
};
var NoopScrollStrategy = class {
  /** Does nothing, as this scroll strategy is a no-op. */
  enable() {
  }
  /** Does nothing, as this scroll strategy is a no-op. */
  disable() {
  }
  /** Does nothing, as this scroll strategy is a no-op. */
  attach() {
  }
};
function isElementScrolledOutsideView(element, scrollContainers) {
  return scrollContainers.some((containerBounds) => {
    const outsideAbove = element.bottom < containerBounds.top;
    const outsideBelow = element.top > containerBounds.bottom;
    const outsideLeft = element.right < containerBounds.left;
    const outsideRight = element.left > containerBounds.right;
    return outsideAbove || outsideBelow || outsideLeft || outsideRight;
  });
}
function isElementClippedByScrolling(element, scrollContainers) {
  return scrollContainers.some((scrollContainerRect) => {
    const clippedAbove = element.top < scrollContainerRect.top;
    const clippedBelow = element.bottom > scrollContainerRect.bottom;
    const clippedLeft = element.left < scrollContainerRect.left;
    const clippedRight = element.right > scrollContainerRect.right;
    return clippedAbove || clippedBelow || clippedLeft || clippedRight;
  });
}
var RepositionScrollStrategy = class {
  constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
    this._scrollDispatcher = _scrollDispatcher;
    this._viewportRuler = _viewportRuler;
    this._ngZone = _ngZone;
    this._config = _config;
    this._scrollSubscription = null;
  }
  /** Attaches this scroll strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatScrollStrategyAlreadyAttachedError();
    }
    this._overlayRef = overlayRef;
  }
  /** Enables repositioning of the attached overlay on scroll. */
  enable() {
    if (!this._scrollSubscription) {
      const throttle2 = this._config ? this._config.scrollThrottle : 0;
      this._scrollSubscription = this._scrollDispatcher.scrolled(throttle2).subscribe(() => {
        this._overlayRef.updatePosition();
        if (this._config && this._config.autoClose) {
          const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();
          const {
            width,
            height
          } = this._viewportRuler.getViewportSize();
          const parentRects = [{
            width,
            height,
            bottom: height,
            right: width,
            top: 0,
            left: 0
          }];
          if (isElementScrolledOutsideView(overlayRect, parentRects)) {
            this.disable();
            this._ngZone.run(() => this._overlayRef.detach());
          }
        }
      });
    }
  }
  /** Disables repositioning of the attached overlay on scroll. */
  disable() {
    if (this._scrollSubscription) {
      this._scrollSubscription.unsubscribe();
      this._scrollSubscription = null;
    }
  }
  detach() {
    this.disable();
    this._overlayRef = null;
  }
};
var _ScrollStrategyOptions = class _ScrollStrategyOptions {
  constructor(_scrollDispatcher, _viewportRuler, _ngZone, document2) {
    this._scrollDispatcher = _scrollDispatcher;
    this._viewportRuler = _viewportRuler;
    this._ngZone = _ngZone;
    this.noop = () => new NoopScrollStrategy();
    this.close = (config) => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);
    this.block = () => new BlockScrollStrategy(this._viewportRuler, this._document);
    this.reposition = (config) => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);
    this._document = document2;
  }
};
_ScrollStrategyOptions.ɵfac = function ScrollStrategyOptions_Factory(t) {
  return new (t || _ScrollStrategyOptions)(ɵɵinject(ScrollDispatcher), ɵɵinject(ViewportRuler), ɵɵinject(NgZone), ɵɵinject(DOCUMENT));
};
_ScrollStrategyOptions.ɵprov = ɵɵdefineInjectable({
  token: _ScrollStrategyOptions,
  factory: _ScrollStrategyOptions.ɵfac,
  providedIn: "root"
});
var ScrollStrategyOptions = _ScrollStrategyOptions;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollStrategyOptions, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ScrollDispatcher
  }, {
    type: ViewportRuler
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var OverlayConfig = class {
  constructor(config) {
    this.scrollStrategy = new NoopScrollStrategy();
    this.panelClass = "";
    this.hasBackdrop = false;
    this.backdropClass = "cdk-overlay-dark-backdrop";
    this.disposeOnNavigation = false;
    if (config) {
      const configKeys = Object.keys(config);
      for (const key of configKeys) {
        if (config[key] !== void 0) {
          this[key] = config[key];
        }
      }
    }
  }
};
var ConnectedOverlayPositionChange = class {
  constructor(connectionPair, scrollableViewProperties) {
    this.connectionPair = connectionPair;
    this.scrollableViewProperties = scrollableViewProperties;
  }
};
function validateVerticalPosition(property, value) {
  if (value !== "top" && value !== "bottom" && value !== "center") {
    throw Error(`ConnectedPosition: Invalid ${property} "${value}". Expected "top", "bottom" or "center".`);
  }
}
function validateHorizontalPosition(property, value) {
  if (value !== "start" && value !== "end" && value !== "center") {
    throw Error(`ConnectedPosition: Invalid ${property} "${value}". Expected "start", "end" or "center".`);
  }
}
var _BaseOverlayDispatcher = class _BaseOverlayDispatcher {
  constructor(document2) {
    this._attachedOverlays = [];
    this._document = document2;
  }
  ngOnDestroy() {
    this.detach();
  }
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    this.remove(overlayRef);
    this._attachedOverlays.push(overlayRef);
  }
  /** Remove an overlay from the list of attached overlay refs. */
  remove(overlayRef) {
    const index = this._attachedOverlays.indexOf(overlayRef);
    if (index > -1) {
      this._attachedOverlays.splice(index, 1);
    }
    if (this._attachedOverlays.length === 0) {
      this.detach();
    }
  }
};
_BaseOverlayDispatcher.ɵfac = function BaseOverlayDispatcher_Factory(t) {
  return new (t || _BaseOverlayDispatcher)(ɵɵinject(DOCUMENT));
};
_BaseOverlayDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _BaseOverlayDispatcher,
  factory: _BaseOverlayDispatcher.ɵfac,
  providedIn: "root"
});
var BaseOverlayDispatcher = _BaseOverlayDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseOverlayDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _OverlayKeyboardDispatcher = class _OverlayKeyboardDispatcher extends BaseOverlayDispatcher {
  constructor(document2, _ngZone) {
    super(document2);
    this._ngZone = _ngZone;
    this._keydownListener = (event) => {
      const overlays = this._attachedOverlays;
      for (let i = overlays.length - 1; i > -1; i--) {
        if (overlays[i]._keydownEvents.observers.length > 0) {
          const keydownEvents = overlays[i]._keydownEvents;
          if (this._ngZone) {
            this._ngZone.run(() => keydownEvents.next(event));
          } else {
            keydownEvents.next(event);
          }
          break;
        }
      }
    };
  }
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    super.add(overlayRef);
    if (!this._isAttached) {
      if (this._ngZone) {
        this._ngZone.runOutsideAngular(() => this._document.body.addEventListener("keydown", this._keydownListener));
      } else {
        this._document.body.addEventListener("keydown", this._keydownListener);
      }
      this._isAttached = true;
    }
  }
  /** Detaches the global keyboard event listener. */
  detach() {
    if (this._isAttached) {
      this._document.body.removeEventListener("keydown", this._keydownListener);
      this._isAttached = false;
    }
  }
};
_OverlayKeyboardDispatcher.ɵfac = function OverlayKeyboardDispatcher_Factory(t) {
  return new (t || _OverlayKeyboardDispatcher)(ɵɵinject(DOCUMENT), ɵɵinject(NgZone, 8));
};
_OverlayKeyboardDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _OverlayKeyboardDispatcher,
  factory: _OverlayKeyboardDispatcher.ɵfac,
  providedIn: "root"
});
var OverlayKeyboardDispatcher = _OverlayKeyboardDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayKeyboardDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: NgZone,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _OverlayOutsideClickDispatcher = class _OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {
  constructor(document2, _platform, _ngZone) {
    super(document2);
    this._platform = _platform;
    this._ngZone = _ngZone;
    this._cursorStyleIsSet = false;
    this._pointerDownListener = (event) => {
      this._pointerDownEventTarget = _getEventTarget(event);
    };
    this._clickListener = (event) => {
      const target = _getEventTarget(event);
      const origin = event.type === "click" && this._pointerDownEventTarget ? this._pointerDownEventTarget : target;
      this._pointerDownEventTarget = null;
      const overlays = this._attachedOverlays.slice();
      for (let i = overlays.length - 1; i > -1; i--) {
        const overlayRef = overlays[i];
        if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {
          continue;
        }
        if (overlayRef.overlayElement.contains(target) || overlayRef.overlayElement.contains(origin)) {
          break;
        }
        const outsidePointerEvents = overlayRef._outsidePointerEvents;
        if (this._ngZone) {
          this._ngZone.run(() => outsidePointerEvents.next(event));
        } else {
          outsidePointerEvents.next(event);
        }
      }
    };
  }
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    super.add(overlayRef);
    if (!this._isAttached) {
      const body = this._document.body;
      if (this._ngZone) {
        this._ngZone.runOutsideAngular(() => this._addEventListeners(body));
      } else {
        this._addEventListeners(body);
      }
      if (this._platform.IOS && !this._cursorStyleIsSet) {
        this._cursorOriginalValue = body.style.cursor;
        body.style.cursor = "pointer";
        this._cursorStyleIsSet = true;
      }
      this._isAttached = true;
    }
  }
  /** Detaches the global keyboard event listener. */
  detach() {
    if (this._isAttached) {
      const body = this._document.body;
      body.removeEventListener("pointerdown", this._pointerDownListener, true);
      body.removeEventListener("click", this._clickListener, true);
      body.removeEventListener("auxclick", this._clickListener, true);
      body.removeEventListener("contextmenu", this._clickListener, true);
      if (this._platform.IOS && this._cursorStyleIsSet) {
        body.style.cursor = this._cursorOriginalValue;
        this._cursorStyleIsSet = false;
      }
      this._isAttached = false;
    }
  }
  _addEventListeners(body) {
    body.addEventListener("pointerdown", this._pointerDownListener, true);
    body.addEventListener("click", this._clickListener, true);
    body.addEventListener("auxclick", this._clickListener, true);
    body.addEventListener("contextmenu", this._clickListener, true);
  }
};
_OverlayOutsideClickDispatcher.ɵfac = function OverlayOutsideClickDispatcher_Factory(t) {
  return new (t || _OverlayOutsideClickDispatcher)(ɵɵinject(DOCUMENT), ɵɵinject(Platform), ɵɵinject(NgZone, 8));
};
_OverlayOutsideClickDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _OverlayOutsideClickDispatcher,
  factory: _OverlayOutsideClickDispatcher.ɵfac,
  providedIn: "root"
});
var OverlayOutsideClickDispatcher = _OverlayOutsideClickDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayOutsideClickDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }, {
    type: NgZone,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _OverlayContainer = class _OverlayContainer {
  constructor(document2, _platform) {
    this._platform = _platform;
    this._document = document2;
  }
  ngOnDestroy() {
    this._containerElement?.remove();
  }
  /**
   * This method returns the overlay container element. It will lazily
   * create the element the first time it is called to facilitate using
   * the container in non-browser environments.
   * @returns the container element
   */
  getContainerElement() {
    if (!this._containerElement) {
      this._createContainer();
    }
    return this._containerElement;
  }
  /**
   * Create the overlay container element, which is simply a div
   * with the 'cdk-overlay-container' class on the document body.
   */
  _createContainer() {
    const containerClass = "cdk-overlay-container";
    if (this._platform.isBrowser || _isTestEnvironment()) {
      const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform="server"], .${containerClass}[platform="test"]`);
      for (let i = 0; i < oppositePlatformContainers.length; i++) {
        oppositePlatformContainers[i].remove();
      }
    }
    const container = this._document.createElement("div");
    container.classList.add(containerClass);
    if (_isTestEnvironment()) {
      container.setAttribute("platform", "test");
    } else if (!this._platform.isBrowser) {
      container.setAttribute("platform", "server");
    }
    this._document.body.appendChild(container);
    this._containerElement = container;
  }
};
_OverlayContainer.ɵfac = function OverlayContainer_Factory(t) {
  return new (t || _OverlayContainer)(ɵɵinject(DOCUMENT), ɵɵinject(Platform));
};
_OverlayContainer.ɵprov = ɵɵdefineInjectable({
  token: _OverlayContainer,
  factory: _OverlayContainer.ɵfac,
  providedIn: "root"
});
var OverlayContainer = _OverlayContainer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }], null);
})();
var OverlayRef = class {
  constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher, _animationsDisabled = false) {
    this._portalOutlet = _portalOutlet;
    this._host = _host;
    this._pane = _pane;
    this._config = _config;
    this._ngZone = _ngZone;
    this._keyboardDispatcher = _keyboardDispatcher;
    this._document = _document;
    this._location = _location;
    this._outsideClickDispatcher = _outsideClickDispatcher;
    this._animationsDisabled = _animationsDisabled;
    this._backdropElement = null;
    this._backdropClick = new Subject();
    this._attachments = new Subject();
    this._detachments = new Subject();
    this._locationChanges = Subscription.EMPTY;
    this._backdropClickHandler = (event) => this._backdropClick.next(event);
    this._backdropTransitionendHandler = (event) => {
      this._disposeBackdrop(event.target);
    };
    this._keydownEvents = new Subject();
    this._outsidePointerEvents = new Subject();
    if (_config.scrollStrategy) {
      this._scrollStrategy = _config.scrollStrategy;
      this._scrollStrategy.attach(this);
    }
    this._positionStrategy = _config.positionStrategy;
  }
  /** The overlay's HTML element */
  get overlayElement() {
    return this._pane;
  }
  /** The overlay's backdrop HTML element. */
  get backdropElement() {
    return this._backdropElement;
  }
  /**
   * Wrapper around the panel element. Can be used for advanced
   * positioning where a wrapper with specific styling is
   * required around the overlay pane.
   */
  get hostElement() {
    return this._host;
  }
  /**
   * Attaches content, given via a Portal, to the overlay.
   * If the overlay is configured to have a backdrop, it will be created.
   *
   * @param portal Portal instance to which to attach the overlay.
   * @returns The portal attachment result.
   */
  attach(portal) {
    if (!this._host.parentElement && this._previousHostParent) {
      this._previousHostParent.appendChild(this._host);
    }
    const attachResult = this._portalOutlet.attach(portal);
    if (this._positionStrategy) {
      this._positionStrategy.attach(this);
    }
    this._updateStackingOrder();
    this._updateElementSize();
    this._updateElementDirection();
    if (this._scrollStrategy) {
      this._scrollStrategy.enable();
    }
    this._ngZone.onStable.pipe(take(1)).subscribe(() => {
      if (this.hasAttached()) {
        this.updatePosition();
      }
    });
    this._togglePointerEvents(true);
    if (this._config.hasBackdrop) {
      this._attachBackdrop();
    }
    if (this._config.panelClass) {
      this._toggleClasses(this._pane, this._config.panelClass, true);
    }
    this._attachments.next();
    this._keyboardDispatcher.add(this);
    if (this._config.disposeOnNavigation) {
      this._locationChanges = this._location.subscribe(() => this.dispose());
    }
    this._outsideClickDispatcher.add(this);
    if (typeof attachResult?.onDestroy === "function") {
      attachResult.onDestroy(() => {
        if (this.hasAttached()) {
          this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));
        }
      });
    }
    return attachResult;
  }
  /**
   * Detaches an overlay from a portal.
   * @returns The portal detachment result.
   */
  detach() {
    if (!this.hasAttached()) {
      return;
    }
    this.detachBackdrop();
    this._togglePointerEvents(false);
    if (this._positionStrategy && this._positionStrategy.detach) {
      this._positionStrategy.detach();
    }
    if (this._scrollStrategy) {
      this._scrollStrategy.disable();
    }
    const detachmentResult = this._portalOutlet.detach();
    this._detachments.next();
    this._keyboardDispatcher.remove(this);
    this._detachContentWhenStable();
    this._locationChanges.unsubscribe();
    this._outsideClickDispatcher.remove(this);
    return detachmentResult;
  }
  /** Cleans up the overlay from the DOM. */
  dispose() {
    const isAttached = this.hasAttached();
    if (this._positionStrategy) {
      this._positionStrategy.dispose();
    }
    this._disposeScrollStrategy();
    this._disposeBackdrop(this._backdropElement);
    this._locationChanges.unsubscribe();
    this._keyboardDispatcher.remove(this);
    this._portalOutlet.dispose();
    this._attachments.complete();
    this._backdropClick.complete();
    this._keydownEvents.complete();
    this._outsidePointerEvents.complete();
    this._outsideClickDispatcher.remove(this);
    this._host?.remove();
    this._previousHostParent = this._pane = this._host = null;
    if (isAttached) {
      this._detachments.next();
    }
    this._detachments.complete();
  }
  /** Whether the overlay has attached content. */
  hasAttached() {
    return this._portalOutlet.hasAttached();
  }
  /** Gets an observable that emits when the backdrop has been clicked. */
  backdropClick() {
    return this._backdropClick;
  }
  /** Gets an observable that emits when the overlay has been attached. */
  attachments() {
    return this._attachments;
  }
  /** Gets an observable that emits when the overlay has been detached. */
  detachments() {
    return this._detachments;
  }
  /** Gets an observable of keydown events targeted to this overlay. */
  keydownEvents() {
    return this._keydownEvents;
  }
  /** Gets an observable of pointer events targeted outside this overlay. */
  outsidePointerEvents() {
    return this._outsidePointerEvents;
  }
  /** Gets the current overlay configuration, which is immutable. */
  getConfig() {
    return this._config;
  }
  /** Updates the position of the overlay based on the position strategy. */
  updatePosition() {
    if (this._positionStrategy) {
      this._positionStrategy.apply();
    }
  }
  /** Switches to a new position strategy and updates the overlay position. */
  updatePositionStrategy(strategy) {
    if (strategy === this._positionStrategy) {
      return;
    }
    if (this._positionStrategy) {
      this._positionStrategy.dispose();
    }
    this._positionStrategy = strategy;
    if (this.hasAttached()) {
      strategy.attach(this);
      this.updatePosition();
    }
  }
  /** Update the size properties of the overlay. */
  updateSize(sizeConfig) {
    this._config = __spreadValues(__spreadValues({}, this._config), sizeConfig);
    this._updateElementSize();
  }
  /** Sets the LTR/RTL direction for the overlay. */
  setDirection(dir) {
    this._config = __spreadProps(__spreadValues({}, this._config), {
      direction: dir
    });
    this._updateElementDirection();
  }
  /** Add a CSS class or an array of classes to the overlay pane. */
  addPanelClass(classes) {
    if (this._pane) {
      this._toggleClasses(this._pane, classes, true);
    }
  }
  /** Remove a CSS class or an array of classes from the overlay pane. */
  removePanelClass(classes) {
    if (this._pane) {
      this._toggleClasses(this._pane, classes, false);
    }
  }
  /**
   * Returns the layout direction of the overlay panel.
   */
  getDirection() {
    const direction = this._config.direction;
    if (!direction) {
      return "ltr";
    }
    return typeof direction === "string" ? direction : direction.value;
  }
  /** Switches to a new scroll strategy. */
  updateScrollStrategy(strategy) {
    if (strategy === this._scrollStrategy) {
      return;
    }
    this._disposeScrollStrategy();
    this._scrollStrategy = strategy;
    if (this.hasAttached()) {
      strategy.attach(this);
      strategy.enable();
    }
  }
  /** Updates the text direction of the overlay panel. */
  _updateElementDirection() {
    this._host.setAttribute("dir", this.getDirection());
  }
  /** Updates the size of the overlay element based on the overlay config. */
  _updateElementSize() {
    if (!this._pane) {
      return;
    }
    const style2 = this._pane.style;
    style2.width = coerceCssPixelValue(this._config.width);
    style2.height = coerceCssPixelValue(this._config.height);
    style2.minWidth = coerceCssPixelValue(this._config.minWidth);
    style2.minHeight = coerceCssPixelValue(this._config.minHeight);
    style2.maxWidth = coerceCssPixelValue(this._config.maxWidth);
    style2.maxHeight = coerceCssPixelValue(this._config.maxHeight);
  }
  /** Toggles the pointer events for the overlay pane element. */
  _togglePointerEvents(enablePointer) {
    this._pane.style.pointerEvents = enablePointer ? "" : "none";
  }
  /** Attaches a backdrop for this overlay. */
  _attachBackdrop() {
    const showingClass = "cdk-overlay-backdrop-showing";
    this._backdropElement = this._document.createElement("div");
    this._backdropElement.classList.add("cdk-overlay-backdrop");
    if (this._animationsDisabled) {
      this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation");
    }
    if (this._config.backdropClass) {
      this._toggleClasses(this._backdropElement, this._config.backdropClass, true);
    }
    this._host.parentElement.insertBefore(this._backdropElement, this._host);
    this._backdropElement.addEventListener("click", this._backdropClickHandler);
    if (!this._animationsDisabled && typeof requestAnimationFrame !== "undefined") {
      this._ngZone.runOutsideAngular(() => {
        requestAnimationFrame(() => {
          if (this._backdropElement) {
            this._backdropElement.classList.add(showingClass);
          }
        });
      });
    } else {
      this._backdropElement.classList.add(showingClass);
    }
  }
  /**
   * Updates the stacking order of the element, moving it to the top if necessary.
   * This is required in cases where one overlay was detached, while another one,
   * that should be behind it, was destroyed. The next time both of them are opened,
   * the stacking will be wrong, because the detached element's pane will still be
   * in its original DOM position.
   */
  _updateStackingOrder() {
    if (this._host.nextSibling) {
      this._host.parentNode.appendChild(this._host);
    }
  }
  /** Detaches the backdrop (if any) associated with the overlay. */
  detachBackdrop() {
    const backdropToDetach = this._backdropElement;
    if (!backdropToDetach) {
      return;
    }
    if (this._animationsDisabled) {
      this._disposeBackdrop(backdropToDetach);
      return;
    }
    backdropToDetach.classList.remove("cdk-overlay-backdrop-showing");
    this._ngZone.runOutsideAngular(() => {
      backdropToDetach.addEventListener("transitionend", this._backdropTransitionendHandler);
    });
    backdropToDetach.style.pointerEvents = "none";
    this._backdropTimeout = this._ngZone.runOutsideAngular(() => setTimeout(() => {
      this._disposeBackdrop(backdropToDetach);
    }, 500));
  }
  /** Toggles a single CSS class or an array of classes on an element. */
  _toggleClasses(element, cssClasses, isAdd) {
    const classes = coerceArray(cssClasses || []).filter((c) => !!c);
    if (classes.length) {
      isAdd ? element.classList.add(...classes) : element.classList.remove(...classes);
    }
  }
  /** Detaches the overlay content next time the zone stabilizes. */
  _detachContentWhenStable() {
    this._ngZone.runOutsideAngular(() => {
      const subscription = this._ngZone.onStable.pipe(takeUntil(merge(this._attachments, this._detachments))).subscribe(() => {
        if (!this._pane || !this._host || this._pane.children.length === 0) {
          if (this._pane && this._config.panelClass) {
            this._toggleClasses(this._pane, this._config.panelClass, false);
          }
          if (this._host && this._host.parentElement) {
            this._previousHostParent = this._host.parentElement;
            this._host.remove();
          }
          subscription.unsubscribe();
        }
      });
    });
  }
  /** Disposes of a scroll strategy. */
  _disposeScrollStrategy() {
    const scrollStrategy = this._scrollStrategy;
    if (scrollStrategy) {
      scrollStrategy.disable();
      if (scrollStrategy.detach) {
        scrollStrategy.detach();
      }
    }
  }
  /** Removes a backdrop element from the DOM. */
  _disposeBackdrop(backdrop) {
    if (backdrop) {
      backdrop.removeEventListener("click", this._backdropClickHandler);
      backdrop.removeEventListener("transitionend", this._backdropTransitionendHandler);
      backdrop.remove();
      if (this._backdropElement === backdrop) {
        this._backdropElement = null;
      }
    }
    if (this._backdropTimeout) {
      clearTimeout(this._backdropTimeout);
      this._backdropTimeout = void 0;
    }
  }
};
var boundingBoxClass = "cdk-overlay-connected-position-bounding-box";
var cssUnitPattern = /([A-Za-z%]+)$/;
var FlexibleConnectedPositionStrategy = class {
  /** Ordered list of preferred positions, from most to least desirable. */
  get positions() {
    return this._preferredPositions;
  }
  constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {
    this._viewportRuler = _viewportRuler;
    this._document = _document;
    this._platform = _platform;
    this._overlayContainer = _overlayContainer;
    this._lastBoundingBoxSize = {
      width: 0,
      height: 0
    };
    this._isPushed = false;
    this._canPush = true;
    this._growAfterOpen = false;
    this._hasFlexibleDimensions = true;
    this._positionLocked = false;
    this._viewportMargin = 0;
    this._scrollables = [];
    this._preferredPositions = [];
    this._positionChanges = new Subject();
    this._resizeSubscription = Subscription.EMPTY;
    this._offsetX = 0;
    this._offsetY = 0;
    this._appliedPanelClasses = [];
    this.positionChanges = this._positionChanges;
    this.setOrigin(connectedTo);
  }
  /** Attaches this position strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && overlayRef !== this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("This position strategy is already attached to an overlay");
    }
    this._validatePositions();
    overlayRef.hostElement.classList.add(boundingBoxClass);
    this._overlayRef = overlayRef;
    this._boundingBox = overlayRef.hostElement;
    this._pane = overlayRef.overlayElement;
    this._isDisposed = false;
    this._isInitialRender = true;
    this._lastPosition = null;
    this._resizeSubscription.unsubscribe();
    this._resizeSubscription = this._viewportRuler.change().subscribe(() => {
      this._isInitialRender = true;
      this.apply();
    });
  }
  /**
   * Updates the position of the overlay element, using whichever preferred position relative
   * to the origin best fits on-screen.
   *
   * The selection of a position goes as follows:
   *  - If any positions fit completely within the viewport as-is,
   *      choose the first position that does so.
   *  - If flexible dimensions are enabled and at least one satisfies the given minimum width/height,
   *      choose the position with the greatest available size modified by the positions' weight.
   *  - If pushing is enabled, take the position that went off-screen the least and push it
   *      on-screen.
   *  - If none of the previous criteria were met, use the position that goes off-screen the least.
   * @docs-private
   */
  apply() {
    if (this._isDisposed || !this._platform.isBrowser) {
      return;
    }
    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
      this.reapplyLastPosition();
      return;
    }
    this._clearPanelClasses();
    this._resetOverlayElementStyles();
    this._resetBoundingBoxStyles();
    this._viewportRect = this._getNarrowedViewportRect();
    this._originRect = this._getOriginRect();
    this._overlayRect = this._pane.getBoundingClientRect();
    this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
    const originRect = this._originRect;
    const overlayRect = this._overlayRect;
    const viewportRect = this._viewportRect;
    const containerRect = this._containerRect;
    const flexibleFits = [];
    let fallback;
    for (let pos of this._preferredPositions) {
      let originPoint = this._getOriginPoint(originRect, containerRect, pos);
      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);
      let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);
      if (overlayFit.isCompletelyWithinViewport) {
        this._isPushed = false;
        this._applyPosition(pos, originPoint);
        return;
      }
      if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {
        flexibleFits.push({
          position: pos,
          origin: originPoint,
          overlayRect,
          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
        });
        continue;
      }
      if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {
        fallback = {
          overlayFit,
          overlayPoint,
          originPoint,
          position: pos,
          overlayRect
        };
      }
    }
    if (flexibleFits.length) {
      let bestFit = null;
      let bestScore = -1;
      for (const fit of flexibleFits) {
        const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);
        if (score > bestScore) {
          bestScore = score;
          bestFit = fit;
        }
      }
      this._isPushed = false;
      this._applyPosition(bestFit.position, bestFit.origin);
      return;
    }
    if (this._canPush) {
      this._isPushed = true;
      this._applyPosition(fallback.position, fallback.originPoint);
      return;
    }
    this._applyPosition(fallback.position, fallback.originPoint);
  }
  detach() {
    this._clearPanelClasses();
    this._lastPosition = null;
    this._previousPushAmount = null;
    this._resizeSubscription.unsubscribe();
  }
  /** Cleanup after the element gets destroyed. */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    if (this._boundingBox) {
      extendStyles(this._boundingBox.style, {
        top: "",
        left: "",
        right: "",
        bottom: "",
        height: "",
        width: "",
        alignItems: "",
        justifyContent: ""
      });
    }
    if (this._pane) {
      this._resetOverlayElementStyles();
    }
    if (this._overlayRef) {
      this._overlayRef.hostElement.classList.remove(boundingBoxClass);
    }
    this.detach();
    this._positionChanges.complete();
    this._overlayRef = this._boundingBox = null;
    this._isDisposed = true;
  }
  /**
   * This re-aligns the overlay element with the trigger in its last calculated position,
   * even if a position higher in the "preferred positions" list would now fit. This
   * allows one to re-align the panel without changing the orientation of the panel.
   */
  reapplyLastPosition() {
    if (this._isDisposed || !this._platform.isBrowser) {
      return;
    }
    const lastPosition = this._lastPosition;
    if (lastPosition) {
      this._originRect = this._getOriginRect();
      this._overlayRect = this._pane.getBoundingClientRect();
      this._viewportRect = this._getNarrowedViewportRect();
      this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
      const originPoint = this._getOriginPoint(this._originRect, this._containerRect, lastPosition);
      this._applyPosition(lastPosition, originPoint);
    } else {
      this.apply();
    }
  }
  /**
   * Sets the list of Scrollable containers that host the origin element so that
   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
   * Scrollable must be an ancestor element of the strategy's origin element.
   */
  withScrollableContainers(scrollables) {
    this._scrollables = scrollables;
    return this;
  }
  /**
   * Adds new preferred positions.
   * @param positions List of positions options for this overlay.
   */
  withPositions(positions) {
    this._preferredPositions = positions;
    if (positions.indexOf(this._lastPosition) === -1) {
      this._lastPosition = null;
    }
    this._validatePositions();
    return this;
  }
  /**
   * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
   * @param margin Required margin between the overlay and the viewport edge in pixels.
   */
  withViewportMargin(margin) {
    this._viewportMargin = margin;
    return this;
  }
  /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */
  withFlexibleDimensions(flexibleDimensions = true) {
    this._hasFlexibleDimensions = flexibleDimensions;
    return this;
  }
  /** Sets whether the overlay can grow after the initial open via flexible width/height. */
  withGrowAfterOpen(growAfterOpen = true) {
    this._growAfterOpen = growAfterOpen;
    return this;
  }
  /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */
  withPush(canPush = true) {
    this._canPush = canPush;
    return this;
  }
  /**
   * Sets whether the overlay's position should be locked in after it is positioned
   * initially. When an overlay is locked in, it won't attempt to reposition itself
   * when the position is re-applied (e.g. when the user scrolls away).
   * @param isLocked Whether the overlay should locked in.
   */
  withLockedPosition(isLocked = true) {
    this._positionLocked = isLocked;
    return this;
  }
  /**
   * Sets the origin, relative to which to position the overlay.
   * Using an element origin is useful for building components that need to be positioned
   * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be
   * used for cases like contextual menus which open relative to the user's pointer.
   * @param origin Reference to the new origin.
   */
  setOrigin(origin) {
    this._origin = origin;
    return this;
  }
  /**
   * Sets the default offset for the overlay's connection point on the x-axis.
   * @param offset New offset in the X axis.
   */
  withDefaultOffsetX(offset) {
    this._offsetX = offset;
    return this;
  }
  /**
   * Sets the default offset for the overlay's connection point on the y-axis.
   * @param offset New offset in the Y axis.
   */
  withDefaultOffsetY(offset) {
    this._offsetY = offset;
    return this;
  }
  /**
   * Configures that the position strategy should set a `transform-origin` on some elements
   * inside the overlay, depending on the current position that is being applied. This is
   * useful for the cases where the origin of an animation can change depending on the
   * alignment of the overlay.
   * @param selector CSS selector that will be used to find the target
   *    elements onto which to set the transform origin.
   */
  withTransformOriginOn(selector) {
    this._transformOriginSelector = selector;
    return this;
  }
  /**
   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
   */
  _getOriginPoint(originRect, containerRect, pos) {
    let x;
    if (pos.originX == "center") {
      x = originRect.left + originRect.width / 2;
    } else {
      const startX = this._isRtl() ? originRect.right : originRect.left;
      const endX = this._isRtl() ? originRect.left : originRect.right;
      x = pos.originX == "start" ? startX : endX;
    }
    if (containerRect.left < 0) {
      x -= containerRect.left;
    }
    let y;
    if (pos.originY == "center") {
      y = originRect.top + originRect.height / 2;
    } else {
      y = pos.originY == "top" ? originRect.top : originRect.bottom;
    }
    if (containerRect.top < 0) {
      y -= containerRect.top;
    }
    return {
      x,
      y
    };
  }
  /**
   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
   * origin point to which the overlay should be connected.
   */
  _getOverlayPoint(originPoint, overlayRect, pos) {
    let overlayStartX;
    if (pos.overlayX == "center") {
      overlayStartX = -overlayRect.width / 2;
    } else if (pos.overlayX === "start") {
      overlayStartX = this._isRtl() ? -overlayRect.width : 0;
    } else {
      overlayStartX = this._isRtl() ? 0 : -overlayRect.width;
    }
    let overlayStartY;
    if (pos.overlayY == "center") {
      overlayStartY = -overlayRect.height / 2;
    } else {
      overlayStartY = pos.overlayY == "top" ? 0 : -overlayRect.height;
    }
    return {
      x: originPoint.x + overlayStartX,
      y: originPoint.y + overlayStartY
    };
  }
  /** Gets how well an overlay at the given point will fit within the viewport. */
  _getOverlayFit(point, rawOverlayRect, viewport, position) {
    const overlay = getRoundedBoundingClientRect(rawOverlayRect);
    let {
      x,
      y
    } = point;
    let offsetX = this._getOffset(position, "x");
    let offsetY = this._getOffset(position, "y");
    if (offsetX) {
      x += offsetX;
    }
    if (offsetY) {
      y += offsetY;
    }
    let leftOverflow = 0 - x;
    let rightOverflow = x + overlay.width - viewport.width;
    let topOverflow = 0 - y;
    let bottomOverflow = y + overlay.height - viewport.height;
    let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);
    let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);
    let visibleArea = visibleWidth * visibleHeight;
    return {
      visibleArea,
      isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,
      fitsInViewportVertically: visibleHeight === overlay.height,
      fitsInViewportHorizontally: visibleWidth == overlay.width
    };
  }
  /**
   * Whether the overlay can fit within the viewport when it may resize either its width or height.
   * @param fit How well the overlay fits in the viewport at some position.
   * @param point The (x, y) coordinates of the overlay at some position.
   * @param viewport The geometry of the viewport.
   */
  _canFitWithFlexibleDimensions(fit, point, viewport) {
    if (this._hasFlexibleDimensions) {
      const availableHeight = viewport.bottom - point.y;
      const availableWidth = viewport.right - point.x;
      const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);
      const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);
      const verticalFit = fit.fitsInViewportVertically || minHeight != null && minHeight <= availableHeight;
      const horizontalFit = fit.fitsInViewportHorizontally || minWidth != null && minWidth <= availableWidth;
      return verticalFit && horizontalFit;
    }
    return false;
  }
  /**
   * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
   * the viewport, the top-left corner will be pushed on-screen (with overflow occurring on the
   * right and bottom).
   *
   * @param start Starting point from which the overlay is pushed.
   * @param rawOverlayRect Dimensions of the overlay.
   * @param scrollPosition Current viewport scroll position.
   * @returns The point at which to position the overlay after pushing. This is effectively a new
   *     originPoint.
   */
  _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {
    if (this._previousPushAmount && this._positionLocked) {
      return {
        x: start.x + this._previousPushAmount.x,
        y: start.y + this._previousPushAmount.y
      };
    }
    const overlay = getRoundedBoundingClientRect(rawOverlayRect);
    const viewport = this._viewportRect;
    const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);
    const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);
    const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);
    const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);
    let pushX = 0;
    let pushY = 0;
    if (overlay.width <= viewport.width) {
      pushX = overflowLeft || -overflowRight;
    } else {
      pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;
    }
    if (overlay.height <= viewport.height) {
      pushY = overflowTop || -overflowBottom;
    } else {
      pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;
    }
    this._previousPushAmount = {
      x: pushX,
      y: pushY
    };
    return {
      x: start.x + pushX,
      y: start.y + pushY
    };
  }
  /**
   * Applies a computed position to the overlay and emits a position change.
   * @param position The position preference
   * @param originPoint The point on the origin element where the overlay is connected.
   */
  _applyPosition(position, originPoint) {
    this._setTransformOrigin(position);
    this._setOverlayElementStyles(originPoint, position);
    this._setBoundingBoxStyles(originPoint, position);
    if (position.panelClass) {
      this._addPanelClasses(position.panelClass);
    }
    if (this._positionChanges.observers.length) {
      const scrollVisibility = this._getScrollVisibility();
      if (position !== this._lastPosition || !this._lastScrollVisibility || !compareScrollVisibility(this._lastScrollVisibility, scrollVisibility)) {
        const changeEvent = new ConnectedOverlayPositionChange(position, scrollVisibility);
        this._positionChanges.next(changeEvent);
      }
      this._lastScrollVisibility = scrollVisibility;
    }
    this._lastPosition = position;
    this._isInitialRender = false;
  }
  /** Sets the transform origin based on the configured selector and the passed-in position.  */
  _setTransformOrigin(position) {
    if (!this._transformOriginSelector) {
      return;
    }
    const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);
    let xOrigin;
    let yOrigin = position.overlayY;
    if (position.overlayX === "center") {
      xOrigin = "center";
    } else if (this._isRtl()) {
      xOrigin = position.overlayX === "start" ? "right" : "left";
    } else {
      xOrigin = position.overlayX === "start" ? "left" : "right";
    }
    for (let i = 0; i < elements.length; i++) {
      elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;
    }
  }
  /**
   * Gets the position and size of the overlay's sizing container.
   *
   * This method does no measuring and applies no styles so that we can cheaply compute the
   * bounds for all positions and choose the best fit based on these results.
   */
  _calculateBoundingBoxRect(origin, position) {
    const viewport = this._viewportRect;
    const isRtl = this._isRtl();
    let height, top, bottom;
    if (position.overlayY === "top") {
      top = origin.y;
      height = viewport.height - top + this._viewportMargin;
    } else if (position.overlayY === "bottom") {
      bottom = viewport.height - origin.y + this._viewportMargin * 2;
      height = viewport.height - bottom + this._viewportMargin;
    } else {
      const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);
      const previousHeight = this._lastBoundingBoxSize.height;
      height = smallestDistanceToViewportEdge * 2;
      top = origin.y - smallestDistanceToViewportEdge;
      if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {
        top = origin.y - previousHeight / 2;
      }
    }
    const isBoundedByRightViewportEdge = position.overlayX === "start" && !isRtl || position.overlayX === "end" && isRtl;
    const isBoundedByLeftViewportEdge = position.overlayX === "end" && !isRtl || position.overlayX === "start" && isRtl;
    let width, left, right;
    if (isBoundedByLeftViewportEdge) {
      right = viewport.width - origin.x + this._viewportMargin * 2;
      width = origin.x - this._viewportMargin;
    } else if (isBoundedByRightViewportEdge) {
      left = origin.x;
      width = viewport.right - origin.x;
    } else {
      const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);
      const previousWidth = this._lastBoundingBoxSize.width;
      width = smallestDistanceToViewportEdge * 2;
      left = origin.x - smallestDistanceToViewportEdge;
      if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {
        left = origin.x - previousWidth / 2;
      }
    }
    return {
      top,
      left,
      bottom,
      right,
      width,
      height
    };
  }
  /**
   * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
   * origin's connection point and stretches to the bounds of the viewport.
   *
   * @param origin The point on the origin element where the overlay is connected.
   * @param position The position preference
   */
  _setBoundingBoxStyles(origin, position) {
    const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);
    if (!this._isInitialRender && !this._growAfterOpen) {
      boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);
      boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);
    }
    const styles = {};
    if (this._hasExactPosition()) {
      styles.top = styles.left = "0";
      styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = "";
      styles.width = styles.height = "100%";
    } else {
      const maxHeight = this._overlayRef.getConfig().maxHeight;
      const maxWidth = this._overlayRef.getConfig().maxWidth;
      styles.height = coerceCssPixelValue(boundingBoxRect.height);
      styles.top = coerceCssPixelValue(boundingBoxRect.top);
      styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);
      styles.width = coerceCssPixelValue(boundingBoxRect.width);
      styles.left = coerceCssPixelValue(boundingBoxRect.left);
      styles.right = coerceCssPixelValue(boundingBoxRect.right);
      if (position.overlayX === "center") {
        styles.alignItems = "center";
      } else {
        styles.alignItems = position.overlayX === "end" ? "flex-end" : "flex-start";
      }
      if (position.overlayY === "center") {
        styles.justifyContent = "center";
      } else {
        styles.justifyContent = position.overlayY === "bottom" ? "flex-end" : "flex-start";
      }
      if (maxHeight) {
        styles.maxHeight = coerceCssPixelValue(maxHeight);
      }
      if (maxWidth) {
        styles.maxWidth = coerceCssPixelValue(maxWidth);
      }
    }
    this._lastBoundingBoxSize = boundingBoxRect;
    extendStyles(this._boundingBox.style, styles);
  }
  /** Resets the styles for the bounding box so that a new positioning can be computed. */
  _resetBoundingBoxStyles() {
    extendStyles(this._boundingBox.style, {
      top: "0",
      left: "0",
      right: "0",
      bottom: "0",
      height: "",
      width: "",
      alignItems: "",
      justifyContent: ""
    });
  }
  /** Resets the styles for the overlay pane so that a new positioning can be computed. */
  _resetOverlayElementStyles() {
    extendStyles(this._pane.style, {
      top: "",
      left: "",
      bottom: "",
      right: "",
      position: "",
      transform: ""
    });
  }
  /** Sets positioning styles to the overlay element. */
  _setOverlayElementStyles(originPoint, position) {
    const styles = {};
    const hasExactPosition = this._hasExactPosition();
    const hasFlexibleDimensions = this._hasFlexibleDimensions;
    const config = this._overlayRef.getConfig();
    if (hasExactPosition) {
      const scrollPosition = this._viewportRuler.getViewportScrollPosition();
      extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));
      extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));
    } else {
      styles.position = "static";
    }
    let transformString = "";
    let offsetX = this._getOffset(position, "x");
    let offsetY = this._getOffset(position, "y");
    if (offsetX) {
      transformString += `translateX(${offsetX}px) `;
    }
    if (offsetY) {
      transformString += `translateY(${offsetY}px)`;
    }
    styles.transform = transformString.trim();
    if (config.maxHeight) {
      if (hasExactPosition) {
        styles.maxHeight = coerceCssPixelValue(config.maxHeight);
      } else if (hasFlexibleDimensions) {
        styles.maxHeight = "";
      }
    }
    if (config.maxWidth) {
      if (hasExactPosition) {
        styles.maxWidth = coerceCssPixelValue(config.maxWidth);
      } else if (hasFlexibleDimensions) {
        styles.maxWidth = "";
      }
    }
    extendStyles(this._pane.style, styles);
  }
  /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */
  _getExactOverlayY(position, originPoint, scrollPosition) {
    let styles = {
      top: "",
      bottom: ""
    };
    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
    if (this._isPushed) {
      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
    }
    if (position.overlayY === "bottom") {
      const documentHeight = this._document.documentElement.clientHeight;
      styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;
    } else {
      styles.top = coerceCssPixelValue(overlayPoint.y);
    }
    return styles;
  }
  /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */
  _getExactOverlayX(position, originPoint, scrollPosition) {
    let styles = {
      left: "",
      right: ""
    };
    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
    if (this._isPushed) {
      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
    }
    let horizontalStyleProperty;
    if (this._isRtl()) {
      horizontalStyleProperty = position.overlayX === "end" ? "left" : "right";
    } else {
      horizontalStyleProperty = position.overlayX === "end" ? "right" : "left";
    }
    if (horizontalStyleProperty === "right") {
      const documentWidth = this._document.documentElement.clientWidth;
      styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;
    } else {
      styles.left = coerceCssPixelValue(overlayPoint.x);
    }
    return styles;
  }
  /**
   * Gets the view properties of the trigger and overlay, including whether they are clipped
   * or completely outside the view of any of the strategy's scrollables.
   */
  _getScrollVisibility() {
    const originBounds = this._getOriginRect();
    const overlayBounds = this._pane.getBoundingClientRect();
    const scrollContainerBounds = this._scrollables.map((scrollable) => {
      return scrollable.getElementRef().nativeElement.getBoundingClientRect();
    });
    return {
      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)
    };
  }
  /** Subtracts the amount that an element is overflowing on an axis from its length. */
  _subtractOverflows(length, ...overflows) {
    return overflows.reduce((currentValue, currentOverflow) => {
      return currentValue - Math.max(currentOverflow, 0);
    }, length);
  }
  /** Narrows the given viewport rect by the current _viewportMargin. */
  _getNarrowedViewportRect() {
    const width = this._document.documentElement.clientWidth;
    const height = this._document.documentElement.clientHeight;
    const scrollPosition = this._viewportRuler.getViewportScrollPosition();
    return {
      top: scrollPosition.top + this._viewportMargin,
      left: scrollPosition.left + this._viewportMargin,
      right: scrollPosition.left + width - this._viewportMargin,
      bottom: scrollPosition.top + height - this._viewportMargin,
      width: width - 2 * this._viewportMargin,
      height: height - 2 * this._viewportMargin
    };
  }
  /** Whether the we're dealing with an RTL context */
  _isRtl() {
    return this._overlayRef.getDirection() === "rtl";
  }
  /** Determines whether the overlay uses exact or flexible positioning. */
  _hasExactPosition() {
    return !this._hasFlexibleDimensions || this._isPushed;
  }
  /** Retrieves the offset of a position along the x or y axis. */
  _getOffset(position, axis) {
    if (axis === "x") {
      return position.offsetX == null ? this._offsetX : position.offsetX;
    }
    return position.offsetY == null ? this._offsetY : position.offsetY;
  }
  /** Validates that the current position match the expected values. */
  _validatePositions() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!this._preferredPositions.length) {
        throw Error("FlexibleConnectedPositionStrategy: At least one position is required.");
      }
      this._preferredPositions.forEach((pair) => {
        validateHorizontalPosition("originX", pair.originX);
        validateVerticalPosition("originY", pair.originY);
        validateHorizontalPosition("overlayX", pair.overlayX);
        validateVerticalPosition("overlayY", pair.overlayY);
      });
    }
  }
  /** Adds a single CSS class or an array of classes on the overlay panel. */
  _addPanelClasses(cssClasses) {
    if (this._pane) {
      coerceArray(cssClasses).forEach((cssClass) => {
        if (cssClass !== "" && this._appliedPanelClasses.indexOf(cssClass) === -1) {
          this._appliedPanelClasses.push(cssClass);
          this._pane.classList.add(cssClass);
        }
      });
    }
  }
  /** Clears the classes that the position strategy has applied from the overlay panel. */
  _clearPanelClasses() {
    if (this._pane) {
      this._appliedPanelClasses.forEach((cssClass) => {
        this._pane.classList.remove(cssClass);
      });
      this._appliedPanelClasses = [];
    }
  }
  /** Returns the DOMRect of the current origin. */
  _getOriginRect() {
    const origin = this._origin;
    if (origin instanceof ElementRef) {
      return origin.nativeElement.getBoundingClientRect();
    }
    if (origin instanceof Element) {
      return origin.getBoundingClientRect();
    }
    const width = origin.width || 0;
    const height = origin.height || 0;
    return {
      top: origin.y,
      bottom: origin.y + height,
      left: origin.x,
      right: origin.x + width,
      height,
      width
    };
  }
};
function extendStyles(destination, source) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      destination[key] = source[key];
    }
  }
  return destination;
}
function getPixelValue(input) {
  if (typeof input !== "number" && input != null) {
    const [value, units] = input.split(cssUnitPattern);
    return !units || units === "px" ? parseFloat(value) : null;
  }
  return input || null;
}
function getRoundedBoundingClientRect(clientRect) {
  return {
    top: Math.floor(clientRect.top),
    right: Math.floor(clientRect.right),
    bottom: Math.floor(clientRect.bottom),
    left: Math.floor(clientRect.left),
    width: Math.floor(clientRect.width),
    height: Math.floor(clientRect.height)
  };
}
function compareScrollVisibility(a, b) {
  if (a === b) {
    return true;
  }
  return a.isOriginClipped === b.isOriginClipped && a.isOriginOutsideView === b.isOriginOutsideView && a.isOverlayClipped === b.isOverlayClipped && a.isOverlayOutsideView === b.isOverlayOutsideView;
}
var wrapperClass = "cdk-global-overlay-wrapper";
var GlobalPositionStrategy = class {
  constructor() {
    this._cssPosition = "static";
    this._topOffset = "";
    this._bottomOffset = "";
    this._alignItems = "";
    this._xPosition = "";
    this._xOffset = "";
    this._width = "";
    this._height = "";
    this._isDisposed = false;
  }
  attach(overlayRef) {
    const config = overlayRef.getConfig();
    this._overlayRef = overlayRef;
    if (this._width && !config.width) {
      overlayRef.updateSize({
        width: this._width
      });
    }
    if (this._height && !config.height) {
      overlayRef.updateSize({
        height: this._height
      });
    }
    overlayRef.hostElement.classList.add(wrapperClass);
    this._isDisposed = false;
  }
  /**
   * Sets the top position of the overlay. Clears any previously set vertical position.
   * @param value New top offset.
   */
  top(value = "") {
    this._bottomOffset = "";
    this._topOffset = value;
    this._alignItems = "flex-start";
    return this;
  }
  /**
   * Sets the left position of the overlay. Clears any previously set horizontal position.
   * @param value New left offset.
   */
  left(value = "") {
    this._xOffset = value;
    this._xPosition = "left";
    return this;
  }
  /**
   * Sets the bottom position of the overlay. Clears any previously set vertical position.
   * @param value New bottom offset.
   */
  bottom(value = "") {
    this._topOffset = "";
    this._bottomOffset = value;
    this._alignItems = "flex-end";
    return this;
  }
  /**
   * Sets the right position of the overlay. Clears any previously set horizontal position.
   * @param value New right offset.
   */
  right(value = "") {
    this._xOffset = value;
    this._xPosition = "right";
    return this;
  }
  /**
   * Sets the overlay to the start of the viewport, depending on the overlay direction.
   * This will be to the left in LTR layouts and to the right in RTL.
   * @param offset Offset from the edge of the screen.
   */
  start(value = "") {
    this._xOffset = value;
    this._xPosition = "start";
    return this;
  }
  /**
   * Sets the overlay to the end of the viewport, depending on the overlay direction.
   * This will be to the right in LTR layouts and to the left in RTL.
   * @param offset Offset from the edge of the screen.
   */
  end(value = "") {
    this._xOffset = value;
    this._xPosition = "end";
    return this;
  }
  /**
   * Sets the overlay width and clears any previously set width.
   * @param value New width for the overlay
   * @deprecated Pass the `width` through the `OverlayConfig`.
   * @breaking-change 8.0.0
   */
  width(value = "") {
    if (this._overlayRef) {
      this._overlayRef.updateSize({
        width: value
      });
    } else {
      this._width = value;
    }
    return this;
  }
  /**
   * Sets the overlay height and clears any previously set height.
   * @param value New height for the overlay
   * @deprecated Pass the `height` through the `OverlayConfig`.
   * @breaking-change 8.0.0
   */
  height(value = "") {
    if (this._overlayRef) {
      this._overlayRef.updateSize({
        height: value
      });
    } else {
      this._height = value;
    }
    return this;
  }
  /**
   * Centers the overlay horizontally with an optional offset.
   * Clears any previously set horizontal position.
   *
   * @param offset Overlay offset from the horizontal center.
   */
  centerHorizontally(offset = "") {
    this.left(offset);
    this._xPosition = "center";
    return this;
  }
  /**
   * Centers the overlay vertically with an optional offset.
   * Clears any previously set vertical position.
   *
   * @param offset Overlay offset from the vertical center.
   */
  centerVertically(offset = "") {
    this.top(offset);
    this._alignItems = "center";
    return this;
  }
  /**
   * Apply the position to the element.
   * @docs-private
   */
  apply() {
    if (!this._overlayRef || !this._overlayRef.hasAttached()) {
      return;
    }
    const styles = this._overlayRef.overlayElement.style;
    const parentStyles = this._overlayRef.hostElement.style;
    const config = this._overlayRef.getConfig();
    const {
      width,
      height,
      maxWidth,
      maxHeight
    } = config;
    const shouldBeFlushHorizontally = (width === "100%" || width === "100vw") && (!maxWidth || maxWidth === "100%" || maxWidth === "100vw");
    const shouldBeFlushVertically = (height === "100%" || height === "100vh") && (!maxHeight || maxHeight === "100%" || maxHeight === "100vh");
    const xPosition = this._xPosition;
    const xOffset = this._xOffset;
    const isRtl = this._overlayRef.getConfig().direction === "rtl";
    let marginLeft = "";
    let marginRight = "";
    let justifyContent = "";
    if (shouldBeFlushHorizontally) {
      justifyContent = "flex-start";
    } else if (xPosition === "center") {
      justifyContent = "center";
      if (isRtl) {
        marginRight = xOffset;
      } else {
        marginLeft = xOffset;
      }
    } else if (isRtl) {
      if (xPosition === "left" || xPosition === "end") {
        justifyContent = "flex-end";
        marginLeft = xOffset;
      } else if (xPosition === "right" || xPosition === "start") {
        justifyContent = "flex-start";
        marginRight = xOffset;
      }
    } else if (xPosition === "left" || xPosition === "start") {
      justifyContent = "flex-start";
      marginLeft = xOffset;
    } else if (xPosition === "right" || xPosition === "end") {
      justifyContent = "flex-end";
      marginRight = xOffset;
    }
    styles.position = this._cssPosition;
    styles.marginLeft = shouldBeFlushHorizontally ? "0" : marginLeft;
    styles.marginTop = shouldBeFlushVertically ? "0" : this._topOffset;
    styles.marginBottom = this._bottomOffset;
    styles.marginRight = shouldBeFlushHorizontally ? "0" : marginRight;
    parentStyles.justifyContent = justifyContent;
    parentStyles.alignItems = shouldBeFlushVertically ? "flex-start" : this._alignItems;
  }
  /**
   * Cleans up the DOM changes from the position strategy.
   * @docs-private
   */
  dispose() {
    if (this._isDisposed || !this._overlayRef) {
      return;
    }
    const styles = this._overlayRef.overlayElement.style;
    const parent = this._overlayRef.hostElement;
    const parentStyles = parent.style;
    parent.classList.remove(wrapperClass);
    parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop = styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = "";
    this._overlayRef = null;
    this._isDisposed = true;
  }
};
var _OverlayPositionBuilder = class _OverlayPositionBuilder {
  constructor(_viewportRuler, _document, _platform, _overlayContainer) {
    this._viewportRuler = _viewportRuler;
    this._document = _document;
    this._platform = _platform;
    this._overlayContainer = _overlayContainer;
  }
  /**
   * Creates a global position strategy.
   */
  global() {
    return new GlobalPositionStrategy();
  }
  /**
   * Creates a flexible position strategy.
   * @param origin Origin relative to which to position the overlay.
   */
  flexibleConnectedTo(origin) {
    return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
  }
};
_OverlayPositionBuilder.ɵfac = function OverlayPositionBuilder_Factory(t) {
  return new (t || _OverlayPositionBuilder)(ɵɵinject(ViewportRuler), ɵɵinject(DOCUMENT), ɵɵinject(Platform), ɵɵinject(OverlayContainer));
};
_OverlayPositionBuilder.ɵprov = ɵɵdefineInjectable({
  token: _OverlayPositionBuilder,
  factory: _OverlayPositionBuilder.ɵfac,
  providedIn: "root"
});
var OverlayPositionBuilder = _OverlayPositionBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayPositionBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ViewportRuler
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }, {
    type: OverlayContainer
  }], null);
})();
var nextUniqueId = 0;
var _Overlay = class _Overlay {
  constructor(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location, _outsideClickDispatcher, _animationsModuleType) {
    this.scrollStrategies = scrollStrategies;
    this._overlayContainer = _overlayContainer;
    this._componentFactoryResolver = _componentFactoryResolver;
    this._positionBuilder = _positionBuilder;
    this._keyboardDispatcher = _keyboardDispatcher;
    this._injector = _injector;
    this._ngZone = _ngZone;
    this._document = _document;
    this._directionality = _directionality;
    this._location = _location;
    this._outsideClickDispatcher = _outsideClickDispatcher;
    this._animationsModuleType = _animationsModuleType;
  }
  /**
   * Creates an overlay.
   * @param config Configuration applied to the overlay.
   * @returns Reference to the created overlay.
   */
  create(config) {
    const host = this._createHostElement();
    const pane = this._createPaneElement(host);
    const portalOutlet = this._createPortalOutlet(pane);
    const overlayConfig = new OverlayConfig(config);
    overlayConfig.direction = overlayConfig.direction || this._directionality.value;
    return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, this._animationsModuleType === "NoopAnimations");
  }
  /**
   * Gets a position builder that can be used, via fluent API,
   * to construct and configure a position strategy.
   * @returns An overlay position builder.
   */
  position() {
    return this._positionBuilder;
  }
  /**
   * Creates the DOM element for an overlay and appends it to the overlay container.
   * @returns Newly-created pane element
   */
  _createPaneElement(host) {
    const pane = this._document.createElement("div");
    pane.id = `cdk-overlay-${nextUniqueId++}`;
    pane.classList.add("cdk-overlay-pane");
    host.appendChild(pane);
    return pane;
  }
  /**
   * Creates the host element that wraps around an overlay
   * and can be used for advanced positioning.
   * @returns Newly-create host element.
   */
  _createHostElement() {
    const host = this._document.createElement("div");
    this._overlayContainer.getContainerElement().appendChild(host);
    return host;
  }
  /**
   * Create a DomPortalOutlet into which the overlay content can be loaded.
   * @param pane The DOM element to turn into a portal outlet.
   * @returns A portal outlet for the given DOM element.
   */
  _createPortalOutlet(pane) {
    if (!this._appRef) {
      this._appRef = this._injector.get(ApplicationRef);
    }
    return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);
  }
};
_Overlay.ɵfac = function Overlay_Factory(t) {
  return new (t || _Overlay)(ɵɵinject(ScrollStrategyOptions), ɵɵinject(OverlayContainer), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(OverlayPositionBuilder), ɵɵinject(OverlayKeyboardDispatcher), ɵɵinject(Injector), ɵɵinject(NgZone), ɵɵinject(DOCUMENT), ɵɵinject(Directionality), ɵɵinject(Location), ɵɵinject(OverlayOutsideClickDispatcher), ɵɵinject(ANIMATION_MODULE_TYPE, 8));
};
_Overlay.ɵprov = ɵɵdefineInjectable({
  token: _Overlay,
  factory: _Overlay.ɵfac,
  providedIn: "root"
});
var Overlay = _Overlay;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Overlay, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ScrollStrategyOptions
  }, {
    type: OverlayContainer
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: OverlayPositionBuilder
  }, {
    type: OverlayKeyboardDispatcher
  }, {
    type: Injector
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Directionality
  }, {
    type: Location
  }, {
    type: OverlayOutsideClickDispatcher
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [ANIMATION_MODULE_TYPE]
    }, {
      type: Optional
    }]
  }], null);
})();
var defaultPositionList = [{
  originX: "start",
  originY: "bottom",
  overlayX: "start",
  overlayY: "top"
}, {
  originX: "start",
  originY: "top",
  overlayX: "start",
  overlayY: "bottom"
}, {
  originX: "end",
  originY: "top",
  overlayX: "end",
  overlayY: "bottom"
}, {
  originX: "end",
  originY: "bottom",
  overlayX: "end",
  overlayY: "top"
}];
var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken("cdk-connected-overlay-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const overlay = inject(Overlay);
    return () => overlay.scrollStrategies.reposition();
  }
});
var _CdkOverlayOrigin = class _CdkOverlayOrigin {
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
};
_CdkOverlayOrigin.ɵfac = function CdkOverlayOrigin_Factory(t) {
  return new (t || _CdkOverlayOrigin)(ɵɵdirectiveInject(ElementRef));
};
_CdkOverlayOrigin.ɵdir = ɵɵdefineDirective({
  type: _CdkOverlayOrigin,
  selectors: [["", "cdk-overlay-origin", ""], ["", "overlay-origin", ""], ["", "cdkOverlayOrigin", ""]],
  exportAs: ["cdkOverlayOrigin"],
  standalone: true
});
var CdkOverlayOrigin = _CdkOverlayOrigin;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkOverlayOrigin, [{
    type: Directive,
    args: [{
      selector: "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]",
      exportAs: "cdkOverlayOrigin",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], null);
})();
var _CdkConnectedOverlay = class _CdkConnectedOverlay {
  /** The offset in pixels for the overlay connection point on the x-axis */
  get offsetX() {
    return this._offsetX;
  }
  set offsetX(offsetX) {
    this._offsetX = offsetX;
    if (this._position) {
      this._updatePositionStrategy(this._position);
    }
  }
  /** The offset in pixels for the overlay connection point on the y-axis */
  get offsetY() {
    return this._offsetY;
  }
  set offsetY(offsetY) {
    this._offsetY = offsetY;
    if (this._position) {
      this._updatePositionStrategy(this._position);
    }
  }
  /** Whether the overlay should be disposed of when the user goes backwards/forwards in history. */
  get disposeOnNavigation() {
    return this._disposeOnNavigation;
  }
  set disposeOnNavigation(value) {
    this._disposeOnNavigation = value;
  }
  // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
  constructor(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {
    this._overlay = _overlay;
    this._dir = _dir;
    this._backdropSubscription = Subscription.EMPTY;
    this._attachSubscription = Subscription.EMPTY;
    this._detachSubscription = Subscription.EMPTY;
    this._positionSubscription = Subscription.EMPTY;
    this._disposeOnNavigation = false;
    this._ngZone = inject(NgZone);
    this.viewportMargin = 0;
    this.open = false;
    this.disableClose = false;
    this.hasBackdrop = false;
    this.lockPosition = false;
    this.flexibleDimensions = false;
    this.growAfterOpen = false;
    this.push = false;
    this.backdropClick = new EventEmitter();
    this.positionChange = new EventEmitter();
    this.attach = new EventEmitter();
    this.detach = new EventEmitter();
    this.overlayKeydown = new EventEmitter();
    this.overlayOutsideClick = new EventEmitter();
    this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
    this._scrollStrategyFactory = scrollStrategyFactory;
    this.scrollStrategy = this._scrollStrategyFactory();
  }
  /** The associated overlay reference. */
  get overlayRef() {
    return this._overlayRef;
  }
  /** The element's layout direction. */
  get dir() {
    return this._dir ? this._dir.value : "ltr";
  }
  ngOnDestroy() {
    this._attachSubscription.unsubscribe();
    this._detachSubscription.unsubscribe();
    this._backdropSubscription.unsubscribe();
    this._positionSubscription.unsubscribe();
    if (this._overlayRef) {
      this._overlayRef.dispose();
    }
  }
  ngOnChanges(changes) {
    if (this._position) {
      this._updatePositionStrategy(this._position);
      this._overlayRef.updateSize({
        width: this.width,
        minWidth: this.minWidth,
        height: this.height,
        minHeight: this.minHeight
      });
      if (changes["origin"] && this.open) {
        this._position.apply();
      }
    }
    if (changes["open"]) {
      this.open ? this._attachOverlay() : this._detachOverlay();
    }
  }
  /** Creates an overlay */
  _createOverlay() {
    if (!this.positions || !this.positions.length) {
      this.positions = defaultPositionList;
    }
    const overlayRef = this._overlayRef = this._overlay.create(this._buildConfig());
    this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());
    this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());
    overlayRef.keydownEvents().subscribe((event) => {
      this.overlayKeydown.next(event);
      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {
        event.preventDefault();
        this._detachOverlay();
      }
    });
    this._overlayRef.outsidePointerEvents().subscribe((event) => {
      const origin = this._getOriginElement();
      const target = _getEventTarget(event);
      if (!origin || origin !== target && !origin.contains(target)) {
        this.overlayOutsideClick.next(event);
      }
    });
  }
  /** Builds the overlay config based on the directive's inputs */
  _buildConfig() {
    const positionStrategy = this._position = this.positionStrategy || this._createPositionStrategy();
    const overlayConfig = new OverlayConfig({
      direction: this._dir,
      positionStrategy,
      scrollStrategy: this.scrollStrategy,
      hasBackdrop: this.hasBackdrop,
      disposeOnNavigation: this.disposeOnNavigation
    });
    if (this.width || this.width === 0) {
      overlayConfig.width = this.width;
    }
    if (this.height || this.height === 0) {
      overlayConfig.height = this.height;
    }
    if (this.minWidth || this.minWidth === 0) {
      overlayConfig.minWidth = this.minWidth;
    }
    if (this.minHeight || this.minHeight === 0) {
      overlayConfig.minHeight = this.minHeight;
    }
    if (this.backdropClass) {
      overlayConfig.backdropClass = this.backdropClass;
    }
    if (this.panelClass) {
      overlayConfig.panelClass = this.panelClass;
    }
    return overlayConfig;
  }
  /** Updates the state of a position strategy, based on the values of the directive inputs. */
  _updatePositionStrategy(positionStrategy) {
    const positions = this.positions.map((currentPosition) => ({
      originX: currentPosition.originX,
      originY: currentPosition.originY,
      overlayX: currentPosition.overlayX,
      overlayY: currentPosition.overlayY,
      offsetX: currentPosition.offsetX || this.offsetX,
      offsetY: currentPosition.offsetY || this.offsetY,
      panelClass: currentPosition.panelClass || void 0
    }));
    return positionStrategy.setOrigin(this._getOrigin()).withPositions(positions).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector);
  }
  /** Returns the position strategy of the overlay to be set on the overlay config */
  _createPositionStrategy() {
    const strategy = this._overlay.position().flexibleConnectedTo(this._getOrigin());
    this._updatePositionStrategy(strategy);
    return strategy;
  }
  _getOrigin() {
    if (this.origin instanceof CdkOverlayOrigin) {
      return this.origin.elementRef;
    } else {
      return this.origin;
    }
  }
  _getOriginElement() {
    if (this.origin instanceof CdkOverlayOrigin) {
      return this.origin.elementRef.nativeElement;
    }
    if (this.origin instanceof ElementRef) {
      return this.origin.nativeElement;
    }
    if (typeof Element !== "undefined" && this.origin instanceof Element) {
      return this.origin;
    }
    return null;
  }
  /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */
  _attachOverlay() {
    if (!this._overlayRef) {
      this._createOverlay();
    } else {
      this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;
    }
    if (!this._overlayRef.hasAttached()) {
      this._overlayRef.attach(this._templatePortal);
    }
    if (this.hasBackdrop) {
      this._backdropSubscription = this._overlayRef.backdropClick().subscribe((event) => {
        this.backdropClick.emit(event);
      });
    } else {
      this._backdropSubscription.unsubscribe();
    }
    this._positionSubscription.unsubscribe();
    if (this.positionChange.observers.length > 0) {
      this._positionSubscription = this._position.positionChanges.pipe(takeWhile(() => this.positionChange.observers.length > 0)).subscribe((position) => {
        this._ngZone.run(() => this.positionChange.emit(position));
        if (this.positionChange.observers.length === 0) {
          this._positionSubscription.unsubscribe();
        }
      });
    }
  }
  /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */
  _detachOverlay() {
    if (this._overlayRef) {
      this._overlayRef.detach();
    }
    this._backdropSubscription.unsubscribe();
    this._positionSubscription.unsubscribe();
  }
};
_CdkConnectedOverlay.ɵfac = function CdkConnectedOverlay_Factory(t) {
  return new (t || _CdkConnectedOverlay)(ɵɵdirectiveInject(Overlay), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY), ɵɵdirectiveInject(Directionality, 8));
};
_CdkConnectedOverlay.ɵdir = ɵɵdefineDirective({
  type: _CdkConnectedOverlay,
  selectors: [["", "cdk-connected-overlay", ""], ["", "connected-overlay", ""], ["", "cdkConnectedOverlay", ""]],
  inputs: {
    origin: [InputFlags.None, "cdkConnectedOverlayOrigin", "origin"],
    positions: [InputFlags.None, "cdkConnectedOverlayPositions", "positions"],
    positionStrategy: [InputFlags.None, "cdkConnectedOverlayPositionStrategy", "positionStrategy"],
    offsetX: [InputFlags.None, "cdkConnectedOverlayOffsetX", "offsetX"],
    offsetY: [InputFlags.None, "cdkConnectedOverlayOffsetY", "offsetY"],
    width: [InputFlags.None, "cdkConnectedOverlayWidth", "width"],
    height: [InputFlags.None, "cdkConnectedOverlayHeight", "height"],
    minWidth: [InputFlags.None, "cdkConnectedOverlayMinWidth", "minWidth"],
    minHeight: [InputFlags.None, "cdkConnectedOverlayMinHeight", "minHeight"],
    backdropClass: [InputFlags.None, "cdkConnectedOverlayBackdropClass", "backdropClass"],
    panelClass: [InputFlags.None, "cdkConnectedOverlayPanelClass", "panelClass"],
    viewportMargin: [InputFlags.None, "cdkConnectedOverlayViewportMargin", "viewportMargin"],
    scrollStrategy: [InputFlags.None, "cdkConnectedOverlayScrollStrategy", "scrollStrategy"],
    open: [InputFlags.None, "cdkConnectedOverlayOpen", "open"],
    disableClose: [InputFlags.None, "cdkConnectedOverlayDisableClose", "disableClose"],
    transformOriginSelector: [InputFlags.None, "cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"],
    hasBackdrop: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayHasBackdrop", "hasBackdrop", booleanAttribute],
    lockPosition: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayLockPosition", "lockPosition", booleanAttribute],
    flexibleDimensions: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions", booleanAttribute],
    growAfterOpen: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayGrowAfterOpen", "growAfterOpen", booleanAttribute],
    push: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayPush", "push", booleanAttribute],
    disposeOnNavigation: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayDisposeOnNavigation", "disposeOnNavigation", booleanAttribute]
  },
  outputs: {
    backdropClick: "backdropClick",
    positionChange: "positionChange",
    attach: "attach",
    detach: "detach",
    overlayKeydown: "overlayKeydown",
    overlayOutsideClick: "overlayOutsideClick"
  },
  exportAs: ["cdkConnectedOverlay"],
  standalone: true,
  features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
});
var CdkConnectedOverlay = _CdkConnectedOverlay;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkConnectedOverlay, [{
    type: Directive,
    args: [{
      selector: "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]",
      exportAs: "cdkConnectedOverlay",
      standalone: true
    }]
  }], () => [{
    type: Overlay
  }, {
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    origin: [{
      type: Input,
      args: ["cdkConnectedOverlayOrigin"]
    }],
    positions: [{
      type: Input,
      args: ["cdkConnectedOverlayPositions"]
    }],
    positionStrategy: [{
      type: Input,
      args: ["cdkConnectedOverlayPositionStrategy"]
    }],
    offsetX: [{
      type: Input,
      args: ["cdkConnectedOverlayOffsetX"]
    }],
    offsetY: [{
      type: Input,
      args: ["cdkConnectedOverlayOffsetY"]
    }],
    width: [{
      type: Input,
      args: ["cdkConnectedOverlayWidth"]
    }],
    height: [{
      type: Input,
      args: ["cdkConnectedOverlayHeight"]
    }],
    minWidth: [{
      type: Input,
      args: ["cdkConnectedOverlayMinWidth"]
    }],
    minHeight: [{
      type: Input,
      args: ["cdkConnectedOverlayMinHeight"]
    }],
    backdropClass: [{
      type: Input,
      args: ["cdkConnectedOverlayBackdropClass"]
    }],
    panelClass: [{
      type: Input,
      args: ["cdkConnectedOverlayPanelClass"]
    }],
    viewportMargin: [{
      type: Input,
      args: ["cdkConnectedOverlayViewportMargin"]
    }],
    scrollStrategy: [{
      type: Input,
      args: ["cdkConnectedOverlayScrollStrategy"]
    }],
    open: [{
      type: Input,
      args: ["cdkConnectedOverlayOpen"]
    }],
    disableClose: [{
      type: Input,
      args: ["cdkConnectedOverlayDisableClose"]
    }],
    transformOriginSelector: [{
      type: Input,
      args: ["cdkConnectedOverlayTransformOriginOn"]
    }],
    hasBackdrop: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayHasBackdrop",
        transform: booleanAttribute
      }]
    }],
    lockPosition: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayLockPosition",
        transform: booleanAttribute
      }]
    }],
    flexibleDimensions: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayFlexibleDimensions",
        transform: booleanAttribute
      }]
    }],
    growAfterOpen: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayGrowAfterOpen",
        transform: booleanAttribute
      }]
    }],
    push: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayPush",
        transform: booleanAttribute
      }]
    }],
    disposeOnNavigation: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayDisposeOnNavigation",
        transform: booleanAttribute
      }]
    }],
    backdropClick: [{
      type: Output
    }],
    positionChange: [{
      type: Output
    }],
    attach: [{
      type: Output
    }],
    detach: [{
      type: Output
    }],
    overlayKeydown: [{
      type: Output
    }],
    overlayOutsideClick: [{
      type: Output
    }]
  });
})();
function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
  return () => overlay.scrollStrategies.reposition();
}
var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
  provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY
};
var _OverlayModule = class _OverlayModule {
};
_OverlayModule.ɵfac = function OverlayModule_Factory(t) {
  return new (t || _OverlayModule)();
};
_OverlayModule.ɵmod = ɵɵdefineNgModule({
  type: _OverlayModule,
  imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],
  exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule]
});
_OverlayModule.ɵinj = ɵɵdefineInjector({
  providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],
  imports: [BidiModule, PortalModule, ScrollingModule, ScrollingModule]
});
var OverlayModule = _OverlayModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],
      exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],
      providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER]
    }]
  }], null, null);
})();
var _FullscreenOverlayContainer = class _FullscreenOverlayContainer extends OverlayContainer {
  constructor(_document, platform) {
    super(_document, platform);
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (this._fullScreenEventName && this._fullScreenListener) {
      this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);
    }
  }
  _createContainer() {
    super._createContainer();
    this._adjustParentForFullscreenChange();
    this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());
  }
  _adjustParentForFullscreenChange() {
    if (!this._containerElement) {
      return;
    }
    const fullscreenElement = this.getFullscreenElement();
    const parent = fullscreenElement || this._document.body;
    parent.appendChild(this._containerElement);
  }
  _addFullscreenChangeListener(fn) {
    const eventName = this._getEventName();
    if (eventName) {
      if (this._fullScreenListener) {
        this._document.removeEventListener(eventName, this._fullScreenListener);
      }
      this._document.addEventListener(eventName, fn);
      this._fullScreenListener = fn;
    }
  }
  _getEventName() {
    if (!this._fullScreenEventName) {
      const _document = this._document;
      if (_document.fullscreenEnabled) {
        this._fullScreenEventName = "fullscreenchange";
      } else if (_document.webkitFullscreenEnabled) {
        this._fullScreenEventName = "webkitfullscreenchange";
      } else if (_document.mozFullScreenEnabled) {
        this._fullScreenEventName = "mozfullscreenchange";
      } else if (_document.msFullscreenEnabled) {
        this._fullScreenEventName = "MSFullscreenChange";
      }
    }
    return this._fullScreenEventName;
  }
  /**
   * When the page is put into fullscreen mode, a specific element is specified.
   * Only that element and its children are visible when in fullscreen mode.
   */
  getFullscreenElement() {
    const _document = this._document;
    return _document.fullscreenElement || _document.webkitFullscreenElement || _document.mozFullScreenElement || _document.msFullscreenElement || null;
  }
};
_FullscreenOverlayContainer.ɵfac = function FullscreenOverlayContainer_Factory(t) {
  return new (t || _FullscreenOverlayContainer)(ɵɵinject(DOCUMENT), ɵɵinject(Platform));
};
_FullscreenOverlayContainer.ɵprov = ɵɵdefineInjectable({
  token: _FullscreenOverlayContainer,
  factory: _FullscreenOverlayContainer.ɵfac,
  providedIn: "root"
});
var FullscreenOverlayContainer = _FullscreenOverlayContainer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FullscreenOverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }], null);
})();

// node_modules/@angular/cdk/fesm2022/table.mjs
var _c02 = [[["caption"]], [["colgroup"], ["col"]], "*"];
var _c12 = ["caption", "colgroup, col", "*"];
function CdkTable_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2);
  }
}
function CdkTable_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "thead", 0);
    ɵɵelementContainer(1, 1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "tbody", 0);
    ɵɵelementContainer(3, 2)(4, 3);
    ɵɵelementEnd();
    ɵɵelementStart(5, "tfoot", 0);
    ɵɵelementContainer(6, 4);
    ɵɵelementEnd();
  }
}
function CdkTable_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 1)(1, 2)(2, 3)(3, 4);
  }
}
function CdkTextColumn_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("text-align", ctx_r0.justify);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.headerText, " ");
  }
}
function CdkTextColumn_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("text-align", ctx_r0.justify);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.dataAccessor(data_r2, ctx_r0.name), " ");
  }
}
var CDK_TABLE = new InjectionToken("CDK_TABLE");
var TEXT_COLUMN_OPTIONS = new InjectionToken("text-column-options");
var _CdkCellDef = class _CdkCellDef {
  constructor(template) {
    this.template = template;
  }
};
_CdkCellDef.ɵfac = function CdkCellDef_Factory(t) {
  return new (t || _CdkCellDef)(ɵɵdirectiveInject(TemplateRef));
};
_CdkCellDef.ɵdir = ɵɵdefineDirective({
  type: _CdkCellDef,
  selectors: [["", "cdkCellDef", ""]],
  standalone: true
});
var CdkCellDef = _CdkCellDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkCellDef]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _CdkHeaderCellDef = class _CdkHeaderCellDef {
  constructor(template) {
    this.template = template;
  }
};
_CdkHeaderCellDef.ɵfac = function CdkHeaderCellDef_Factory(t) {
  return new (t || _CdkHeaderCellDef)(ɵɵdirectiveInject(TemplateRef));
};
_CdkHeaderCellDef.ɵdir = ɵɵdefineDirective({
  type: _CdkHeaderCellDef,
  selectors: [["", "cdkHeaderCellDef", ""]],
  standalone: true
});
var CdkHeaderCellDef = _CdkHeaderCellDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkHeaderCellDef]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _CdkFooterCellDef = class _CdkFooterCellDef {
  constructor(template) {
    this.template = template;
  }
};
_CdkFooterCellDef.ɵfac = function CdkFooterCellDef_Factory(t) {
  return new (t || _CdkFooterCellDef)(ɵɵdirectiveInject(TemplateRef));
};
_CdkFooterCellDef.ɵdir = ɵɵdefineDirective({
  type: _CdkFooterCellDef,
  selectors: [["", "cdkFooterCellDef", ""]],
  standalone: true
});
var CdkFooterCellDef = _CdkFooterCellDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkFooterCellDef]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _CdkColumnDef = class _CdkColumnDef {
  /** Unique name for this column. */
  get name() {
    return this._name;
  }
  set name(name) {
    this._setNameInput(name);
  }
  /** Whether the cell is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  /**
   * Whether this column should be sticky positioned on the end of the row. Should make sure
   * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
   * has been changed.
   */
  get stickyEnd() {
    return this._stickyEnd;
  }
  set stickyEnd(value) {
    if (value !== this._stickyEnd) {
      this._stickyEnd = value;
      this._hasStickyChanged = true;
    }
  }
  constructor(_table) {
    this._table = _table;
    this._hasStickyChanged = false;
    this._sticky = false;
    this._stickyEnd = false;
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
  /**
   * Overridable method that sets the css classes that will be added to every cell in this
   * column.
   * In the future, columnCssClassName will change from type string[] to string and this
   * will set a single string value.
   * @docs-private
   */
  _updateColumnCssClassName() {
    this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`];
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setNameInput(value) {
    if (value) {
      this._name = value;
      this.cssClassFriendlyName = value.replace(/[^a-z0-9_-]/gi, "-");
      this._updateColumnCssClassName();
    }
  }
};
_CdkColumnDef.ɵfac = function CdkColumnDef_Factory(t) {
  return new (t || _CdkColumnDef)(ɵɵdirectiveInject(CDK_TABLE, 8));
};
_CdkColumnDef.ɵdir = ɵɵdefineDirective({
  type: _CdkColumnDef,
  selectors: [["", "cdkColumnDef", ""]],
  contentQueries: function CdkColumnDef_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CdkCellDef, 5);
      ɵɵcontentQuery(dirIndex, CdkHeaderCellDef, 5);
      ɵɵcontentQuery(dirIndex, CdkFooterCellDef, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cell = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerCell = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerCell = _t.first);
    }
  },
  inputs: {
    name: [InputFlags.None, "cdkColumnDef", "name"],
    sticky: [InputFlags.HasDecoratorInputTransform, "sticky", "sticky", booleanAttribute],
    stickyEnd: [InputFlags.HasDecoratorInputTransform, "stickyEnd", "stickyEnd", booleanAttribute]
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: "MAT_SORT_HEADER_COLUMN_DEF",
    useExisting: _CdkColumnDef
  }]), ɵɵInputTransformsFeature]
});
var CdkColumnDef = _CdkColumnDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkColumnDef, [{
    type: Directive,
    args: [{
      selector: "[cdkColumnDef]",
      providers: [{
        provide: "MAT_SORT_HEADER_COLUMN_DEF",
        useExisting: CdkColumnDef
      }],
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_TABLE]
    }, {
      type: Optional
    }]
  }], {
    name: [{
      type: Input,
      args: ["cdkColumnDef"]
    }],
    sticky: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    stickyEnd: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    cell: [{
      type: ContentChild,
      args: [CdkCellDef]
    }],
    headerCell: [{
      type: ContentChild,
      args: [CdkHeaderCellDef]
    }],
    footerCell: [{
      type: ContentChild,
      args: [CdkFooterCellDef]
    }]
  });
})();
var BaseCdkCell = class {
  constructor(columnDef, elementRef) {
    elementRef.nativeElement.classList.add(...columnDef._columnCssClassName);
  }
};
var _CdkHeaderCell = class _CdkHeaderCell extends BaseCdkCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
  }
};
_CdkHeaderCell.ɵfac = function CdkHeaderCell_Factory(t) {
  return new (t || _CdkHeaderCell)(ɵɵdirectiveInject(CdkColumnDef), ɵɵdirectiveInject(ElementRef));
};
_CdkHeaderCell.ɵdir = ɵɵdefineDirective({
  type: _CdkHeaderCell,
  selectors: [["cdk-header-cell"], ["th", "cdk-header-cell", ""]],
  hostAttrs: ["role", "columnheader", 1, "cdk-header-cell"],
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkHeaderCell = _CdkHeaderCell;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderCell, [{
    type: Directive,
    args: [{
      selector: "cdk-header-cell, th[cdk-header-cell]",
      host: {
        "class": "cdk-header-cell",
        "role": "columnheader"
      },
      standalone: true
    }]
  }], () => [{
    type: CdkColumnDef
  }, {
    type: ElementRef
  }], null);
})();
var _CdkFooterCell = class _CdkFooterCell extends BaseCdkCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    const role = columnDef._table?._getCellRole();
    if (role) {
      elementRef.nativeElement.setAttribute("role", role);
    }
  }
};
_CdkFooterCell.ɵfac = function CdkFooterCell_Factory(t) {
  return new (t || _CdkFooterCell)(ɵɵdirectiveInject(CdkColumnDef), ɵɵdirectiveInject(ElementRef));
};
_CdkFooterCell.ɵdir = ɵɵdefineDirective({
  type: _CdkFooterCell,
  selectors: [["cdk-footer-cell"], ["td", "cdk-footer-cell", ""]],
  hostAttrs: [1, "cdk-footer-cell"],
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkFooterCell = _CdkFooterCell;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterCell, [{
    type: Directive,
    args: [{
      selector: "cdk-footer-cell, td[cdk-footer-cell]",
      host: {
        "class": "cdk-footer-cell"
      },
      standalone: true
    }]
  }], () => [{
    type: CdkColumnDef
  }, {
    type: ElementRef
  }], null);
})();
var _CdkCell = class _CdkCell extends BaseCdkCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    const role = columnDef._table?._getCellRole();
    if (role) {
      elementRef.nativeElement.setAttribute("role", role);
    }
  }
};
_CdkCell.ɵfac = function CdkCell_Factory(t) {
  return new (t || _CdkCell)(ɵɵdirectiveInject(CdkColumnDef), ɵɵdirectiveInject(ElementRef));
};
_CdkCell.ɵdir = ɵɵdefineDirective({
  type: _CdkCell,
  selectors: [["cdk-cell"], ["td", "cdk-cell", ""]],
  hostAttrs: [1, "cdk-cell"],
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkCell = _CdkCell;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCell, [{
    type: Directive,
    args: [{
      selector: "cdk-cell, td[cdk-cell]",
      host: {
        "class": "cdk-cell"
      },
      standalone: true
    }]
  }], () => [{
    type: CdkColumnDef
  }, {
    type: ElementRef
  }], null);
})();
var _Schedule = class {
  constructor() {
    this.tasks = [];
    this.endTasks = [];
  }
};
var _COALESCED_STYLE_SCHEDULER = new InjectionToken("_COALESCED_STYLE_SCHEDULER");
var __CoalescedStyleScheduler = class __CoalescedStyleScheduler {
  constructor(_ngZone) {
    this._ngZone = _ngZone;
    this._currentSchedule = null;
    this._destroyed = new Subject();
  }
  /**
   * Schedules the specified task to run at the end of the current VM turn.
   */
  schedule(task) {
    this._createScheduleIfNeeded();
    this._currentSchedule.tasks.push(task);
  }
  /**
   * Schedules the specified task to run after other scheduled tasks at the end of the current
   * VM turn.
   */
  scheduleEnd(task) {
    this._createScheduleIfNeeded();
    this._currentSchedule.endTasks.push(task);
  }
  /** Prevent any further tasks from running. */
  ngOnDestroy() {
    this._destroyed.next();
    this._destroyed.complete();
  }
  _createScheduleIfNeeded() {
    if (this._currentSchedule) {
      return;
    }
    this._currentSchedule = new _Schedule();
    this._getScheduleObservable().pipe(takeUntil(this._destroyed)).subscribe(() => {
      while (this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length) {
        const schedule = this._currentSchedule;
        this._currentSchedule = new _Schedule();
        for (const task of schedule.tasks) {
          task();
        }
        for (const task of schedule.endTasks) {
          task();
        }
      }
      this._currentSchedule = null;
    });
  }
  _getScheduleObservable() {
    return this._ngZone.isStable ? from(Promise.resolve(void 0)) : this._ngZone.onStable.pipe(take(1));
  }
};
__CoalescedStyleScheduler.ɵfac = function _CoalescedStyleScheduler_Factory(t) {
  return new (t || __CoalescedStyleScheduler)(ɵɵinject(NgZone));
};
__CoalescedStyleScheduler.ɵprov = ɵɵdefineInjectable({
  token: __CoalescedStyleScheduler,
  factory: __CoalescedStyleScheduler.ɵfac
});
var _CoalescedStyleScheduler = __CoalescedStyleScheduler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CoalescedStyleScheduler, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }], null);
})();
var CDK_ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;
var _BaseRowDef = class _BaseRowDef {
  constructor(template, _differs) {
    this.template = template;
    this._differs = _differs;
  }
  ngOnChanges(changes) {
    if (!this._columnsDiffer) {
      const columns = changes["columns"] && changes["columns"].currentValue || [];
      this._columnsDiffer = this._differs.find(columns).create();
      this._columnsDiffer.diff(columns);
    }
  }
  /**
   * Returns the difference between the current columns and the columns from the last diff, or null
   * if there is no difference.
   */
  getColumnsDiff() {
    return this._columnsDiffer.diff(this.columns);
  }
  /** Gets this row def's relevant cell template from the provided column def. */
  extractCellTemplate(column) {
    if (this instanceof CdkHeaderRowDef) {
      return column.headerCell.template;
    }
    if (this instanceof CdkFooterRowDef) {
      return column.footerCell.template;
    } else {
      return column.cell.template;
    }
  }
};
_BaseRowDef.ɵfac = function BaseRowDef_Factory(t) {
  return new (t || _BaseRowDef)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers));
};
_BaseRowDef.ɵdir = ɵɵdefineDirective({
  type: _BaseRowDef,
  features: [ɵɵNgOnChangesFeature]
});
var BaseRowDef = _BaseRowDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseRowDef, [{
    type: Directive
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }], null);
})();
var _CdkHeaderRowDef = class _CdkHeaderRowDef extends BaseRowDef {
  /** Whether the row is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  constructor(template, _differs, _table) {
    super(template, _differs);
    this._table = _table;
    this._hasStickyChanged = false;
    this._sticky = false;
  }
  // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
  // Explicitly define it so that the method is called as part of the Angular lifecycle.
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
};
_CdkHeaderRowDef.ɵfac = function CdkHeaderRowDef_Factory(t) {
  return new (t || _CdkHeaderRowDef)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(CDK_TABLE, 8));
};
_CdkHeaderRowDef.ɵdir = ɵɵdefineDirective({
  type: _CdkHeaderRowDef,
  selectors: [["", "cdkHeaderRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "cdkHeaderRowDef", "columns"],
    sticky: [InputFlags.HasDecoratorInputTransform, "cdkHeaderRowDefSticky", "sticky", booleanAttribute]
  },
  standalone: true,
  features: [ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var CdkHeaderRowDef = _CdkHeaderRowDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkHeaderRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkHeaderRowDef"
      }],
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_TABLE]
    }, {
      type: Optional
    }]
  }], {
    sticky: [{
      type: Input,
      args: [{
        alias: "cdkHeaderRowDefSticky",
        transform: booleanAttribute
      }]
    }]
  });
})();
var _CdkFooterRowDef = class _CdkFooterRowDef extends BaseRowDef {
  /** Whether the row is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  constructor(template, _differs, _table) {
    super(template, _differs);
    this._table = _table;
    this._hasStickyChanged = false;
    this._sticky = false;
  }
  // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
  // Explicitly define it so that the method is called as part of the Angular lifecycle.
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
};
_CdkFooterRowDef.ɵfac = function CdkFooterRowDef_Factory(t) {
  return new (t || _CdkFooterRowDef)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(CDK_TABLE, 8));
};
_CdkFooterRowDef.ɵdir = ɵɵdefineDirective({
  type: _CdkFooterRowDef,
  selectors: [["", "cdkFooterRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "cdkFooterRowDef", "columns"],
    sticky: [InputFlags.HasDecoratorInputTransform, "cdkFooterRowDefSticky", "sticky", booleanAttribute]
  },
  standalone: true,
  features: [ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var CdkFooterRowDef = _CdkFooterRowDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkFooterRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkFooterRowDef"
      }],
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_TABLE]
    }, {
      type: Optional
    }]
  }], {
    sticky: [{
      type: Input,
      args: [{
        alias: "cdkFooterRowDefSticky",
        transform: booleanAttribute
      }]
    }]
  });
})();
var _CdkRowDef = class _CdkRowDef extends BaseRowDef {
  // TODO(andrewseguin): Add an input for providing a switch function to determine
  //   if this template should be used.
  constructor(template, _differs, _table) {
    super(template, _differs);
    this._table = _table;
  }
};
_CdkRowDef.ɵfac = function CdkRowDef_Factory(t) {
  return new (t || _CdkRowDef)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(CDK_TABLE, 8));
};
_CdkRowDef.ɵdir = ɵɵdefineDirective({
  type: _CdkRowDef,
  selectors: [["", "cdkRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "cdkRowDefColumns", "columns"],
    when: [InputFlags.None, "cdkRowDefWhen", "when"]
  },
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkRowDef = _CdkRowDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkRowDefColumns"
      }, {
        name: "when",
        alias: "cdkRowDefWhen"
      }],
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_TABLE]
    }, {
      type: Optional
    }]
  }], null);
})();
var _CdkCellOutlet = class _CdkCellOutlet {
  constructor(_viewContainer) {
    this._viewContainer = _viewContainer;
    _CdkCellOutlet.mostRecentCellOutlet = this;
  }
  ngOnDestroy() {
    if (_CdkCellOutlet.mostRecentCellOutlet === this) {
      _CdkCellOutlet.mostRecentCellOutlet = null;
    }
  }
};
_CdkCellOutlet.mostRecentCellOutlet = null;
_CdkCellOutlet.ɵfac = function CdkCellOutlet_Factory(t) {
  return new (t || _CdkCellOutlet)(ɵɵdirectiveInject(ViewContainerRef));
};
_CdkCellOutlet.ɵdir = ɵɵdefineDirective({
  type: _CdkCellOutlet,
  selectors: [["", "cdkCellOutlet", ""]],
  standalone: true
});
var CdkCellOutlet = _CdkCellOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCellOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkCellOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], null);
})();
var _CdkHeaderRow = class _CdkHeaderRow {
};
_CdkHeaderRow.ɵfac = function CdkHeaderRow_Factory(t) {
  return new (t || _CdkHeaderRow)();
};
_CdkHeaderRow.ɵcmp = ɵɵdefineComponent({
  type: _CdkHeaderRow,
  selectors: [["cdk-header-row"], ["tr", "cdk-header-row", ""]],
  hostAttrs: ["role", "row", 1, "cdk-header-row"],
  standalone: true,
  features: [ɵɵStandaloneFeature],
  decls: 1,
  vars: 0,
  consts: [["cdkCellOutlet", ""]],
  template: function CdkHeaderRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [CdkCellOutlet],
  encapsulation: 2
});
var CdkHeaderRow = _CdkHeaderRow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderRow, [{
    type: Component,
    args: [{
      selector: "cdk-header-row, tr[cdk-header-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-header-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var _CdkFooterRow = class _CdkFooterRow {
};
_CdkFooterRow.ɵfac = function CdkFooterRow_Factory(t) {
  return new (t || _CdkFooterRow)();
};
_CdkFooterRow.ɵcmp = ɵɵdefineComponent({
  type: _CdkFooterRow,
  selectors: [["cdk-footer-row"], ["tr", "cdk-footer-row", ""]],
  hostAttrs: ["role", "row", 1, "cdk-footer-row"],
  standalone: true,
  features: [ɵɵStandaloneFeature],
  decls: 1,
  vars: 0,
  consts: [["cdkCellOutlet", ""]],
  template: function CdkFooterRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [CdkCellOutlet],
  encapsulation: 2
});
var CdkFooterRow = _CdkFooterRow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterRow, [{
    type: Component,
    args: [{
      selector: "cdk-footer-row, tr[cdk-footer-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-footer-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var _CdkRow = class _CdkRow {
};
_CdkRow.ɵfac = function CdkRow_Factory(t) {
  return new (t || _CdkRow)();
};
_CdkRow.ɵcmp = ɵɵdefineComponent({
  type: _CdkRow,
  selectors: [["cdk-row"], ["tr", "cdk-row", ""]],
  hostAttrs: ["role", "row", 1, "cdk-row"],
  standalone: true,
  features: [ɵɵStandaloneFeature],
  decls: 1,
  vars: 0,
  consts: [["cdkCellOutlet", ""]],
  template: function CdkRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [CdkCellOutlet],
  encapsulation: 2
});
var CdkRow = _CdkRow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRow, [{
    type: Component,
    args: [{
      selector: "cdk-row, tr[cdk-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var _CdkNoDataRow = class _CdkNoDataRow {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this._contentClassName = "cdk-no-data-row";
  }
};
_CdkNoDataRow.ɵfac = function CdkNoDataRow_Factory(t) {
  return new (t || _CdkNoDataRow)(ɵɵdirectiveInject(TemplateRef));
};
_CdkNoDataRow.ɵdir = ɵɵdefineDirective({
  type: _CdkNoDataRow,
  selectors: [["ng-template", "cdkNoDataRow", ""]],
  standalone: true
});
var CdkNoDataRow = _CdkNoDataRow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkNoDataRow, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkNoDataRow]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var STICKY_DIRECTIONS = ["top", "bottom", "left", "right"];
var StickyStyler = class {
  /**
   * @param _isNativeHtmlTable Whether the sticky logic should be based on a table
   *     that uses the native `<table>` element.
   * @param _stickCellCss The CSS class that will be applied to every row/cell that has
   *     sticky positioning applied.
   * @param direction The directionality context of the table (ltr/rtl); affects column positioning
   *     by reversing left/right positions.
   * @param _isBrowser Whether the table is currently being rendered on the server or the client.
   * @param _needsPositionStickyOnElement Whether we need to specify position: sticky on cells
   *     using inline styles. If false, it is assumed that position: sticky is included in
   *     the component stylesheet for _stickCellCss.
   * @param _positionListener A listener that is notified of changes to sticky rows/columns
   *     and their dimensions.
   */
  constructor(_isNativeHtmlTable, _stickCellCss, direction, _coalescedStyleScheduler, _isBrowser = true, _needsPositionStickyOnElement = true, _positionListener) {
    this._isNativeHtmlTable = _isNativeHtmlTable;
    this._stickCellCss = _stickCellCss;
    this.direction = direction;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._isBrowser = _isBrowser;
    this._needsPositionStickyOnElement = _needsPositionStickyOnElement;
    this._positionListener = _positionListener;
    this._cachedCellWidths = [];
    this._borderCellCss = {
      "top": `${_stickCellCss}-border-elem-top`,
      "bottom": `${_stickCellCss}-border-elem-bottom`,
      "left": `${_stickCellCss}-border-elem-left`,
      "right": `${_stickCellCss}-border-elem-right`
    };
  }
  /**
   * Clears the sticky positioning styles from the row and its cells by resetting the `position`
   * style, setting the zIndex to 0, and unsetting each provided sticky direction.
   * @param rows The list of rows that should be cleared from sticking in the provided directions
   * @param stickyDirections The directions that should no longer be set as sticky on the rows.
   */
  clearStickyPositioning(rows, stickyDirections) {
    const elementsToClear = [];
    for (const row of rows) {
      if (row.nodeType !== row.ELEMENT_NODE) {
        continue;
      }
      elementsToClear.push(row);
      for (let i = 0; i < row.children.length; i++) {
        elementsToClear.push(row.children[i]);
      }
    }
    this._coalescedStyleScheduler.schedule(() => {
      for (const element of elementsToClear) {
        this._removeStickyStyle(element, stickyDirections);
      }
    });
  }
  /**
   * Applies sticky left and right positions to the cells of each row according to the sticky
   * states of the rendered column definitions.
   * @param rows The rows that should have its set of cells stuck according to the sticky states.
   * @param stickyStartStates A list of boolean states where each state represents whether the cell
   *     in this index position should be stuck to the start of the row.
   * @param stickyEndStates A list of boolean states where each state represents whether the cell
   *     in this index position should be stuck to the end of the row.
   * @param recalculateCellWidths Whether the sticky styler should recalculate the width of each
   *     column cell. If `false` cached widths will be used instead.
   */
  updateStickyColumns(rows, stickyStartStates, stickyEndStates, recalculateCellWidths = true) {
    if (!rows.length || !this._isBrowser || !(stickyStartStates.some((state2) => state2) || stickyEndStates.some((state2) => state2))) {
      if (this._positionListener) {
        this._positionListener.stickyColumnsUpdated({
          sizes: []
        });
        this._positionListener.stickyEndColumnsUpdated({
          sizes: []
        });
      }
      return;
    }
    this._coalescedStyleScheduler.schedule(() => {
      const firstRow = rows[0];
      const numCells = firstRow.children.length;
      const cellWidths = this._getCellWidths(firstRow, recalculateCellWidths);
      const startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);
      const endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);
      const lastStickyStart = stickyStartStates.lastIndexOf(true);
      const firstStickyEnd = stickyEndStates.indexOf(true);
      const isRtl = this.direction === "rtl";
      const start = isRtl ? "right" : "left";
      const end = isRtl ? "left" : "right";
      for (const row of rows) {
        for (let i = 0; i < numCells; i++) {
          const cell = row.children[i];
          if (stickyStartStates[i]) {
            this._addStickyStyle(cell, start, startPositions[i], i === lastStickyStart);
          }
          if (stickyEndStates[i]) {
            this._addStickyStyle(cell, end, endPositions[i], i === firstStickyEnd);
          }
        }
      }
      if (this._positionListener) {
        this._positionListener.stickyColumnsUpdated({
          sizes: lastStickyStart === -1 ? [] : cellWidths.slice(0, lastStickyStart + 1).map((width, index) => stickyStartStates[index] ? width : null)
        });
        this._positionListener.stickyEndColumnsUpdated({
          sizes: firstStickyEnd === -1 ? [] : cellWidths.slice(firstStickyEnd).map((width, index) => stickyEndStates[index + firstStickyEnd] ? width : null).reverse()
        });
      }
    });
  }
  /**
   * Applies sticky positioning to the row's cells if using the native table layout, and to the
   * row itself otherwise.
   * @param rowsToStick The list of rows that should be stuck according to their corresponding
   *     sticky state and to the provided top or bottom position.
   * @param stickyStates A list of boolean states where each state represents whether the row
   *     should be stuck in the particular top or bottom position.
   * @param position The position direction in which the row should be stuck if that row should be
   *     sticky.
   *
   */
  stickRows(rowsToStick, stickyStates, position) {
    if (!this._isBrowser) {
      return;
    }
    this._coalescedStyleScheduler.schedule(() => {
      const rows = position === "bottom" ? rowsToStick.slice().reverse() : rowsToStick;
      const states = position === "bottom" ? stickyStates.slice().reverse() : stickyStates;
      const stickyOffsets = [];
      const stickyCellHeights = [];
      const elementsToStick = [];
      for (let rowIndex = 0, stickyOffset = 0; rowIndex < rows.length; rowIndex++) {
        if (!states[rowIndex]) {
          continue;
        }
        stickyOffsets[rowIndex] = stickyOffset;
        const row = rows[rowIndex];
        elementsToStick[rowIndex] = this._isNativeHtmlTable ? Array.from(row.children) : [row];
        const height = row.getBoundingClientRect().height;
        stickyOffset += height;
        stickyCellHeights[rowIndex] = height;
      }
      const borderedRowIndex = states.lastIndexOf(true);
      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        if (!states[rowIndex]) {
          continue;
        }
        const offset = stickyOffsets[rowIndex];
        const isBorderedRowIndex = rowIndex === borderedRowIndex;
        for (const element of elementsToStick[rowIndex]) {
          this._addStickyStyle(element, position, offset, isBorderedRowIndex);
        }
      }
      if (position === "top") {
        this._positionListener?.stickyHeaderRowsUpdated({
          sizes: stickyCellHeights,
          offsets: stickyOffsets,
          elements: elementsToStick
        });
      } else {
        this._positionListener?.stickyFooterRowsUpdated({
          sizes: stickyCellHeights,
          offsets: stickyOffsets,
          elements: elementsToStick
        });
      }
    });
  }
  /**
   * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
   * footer rows is to apply sticky styling to the tfoot container. This should only be done if
   * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
   * the tfoot element.
   */
  updateStickyFooterContainer(tableElement, stickyStates) {
    if (!this._isNativeHtmlTable) {
      return;
    }
    this._coalescedStyleScheduler.schedule(() => {
      const tfoot = tableElement.querySelector("tfoot");
      if (tfoot) {
        if (stickyStates.some((state2) => !state2)) {
          this._removeStickyStyle(tfoot, ["bottom"]);
        } else {
          this._addStickyStyle(tfoot, "bottom", 0, false);
        }
      }
    });
  }
  /**
   * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
   * the zIndex, removing each of the provided sticky directions, and removing the
   * sticky position if there are no more directions.
   */
  _removeStickyStyle(element, stickyDirections) {
    for (const dir of stickyDirections) {
      element.style[dir] = "";
      element.classList.remove(this._borderCellCss[dir]);
    }
    const hasDirection = STICKY_DIRECTIONS.some((dir) => stickyDirections.indexOf(dir) === -1 && element.style[dir]);
    if (hasDirection) {
      element.style.zIndex = this._getCalculatedZIndex(element);
    } else {
      element.style.zIndex = "";
      if (this._needsPositionStickyOnElement) {
        element.style.position = "";
      }
      element.classList.remove(this._stickCellCss);
    }
  }
  /**
   * Adds the sticky styling to the element by adding the sticky style class, changing position
   * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
   * direction and value.
   */
  _addStickyStyle(element, dir, dirValue, isBorderElement) {
    element.classList.add(this._stickCellCss);
    if (isBorderElement) {
      element.classList.add(this._borderCellCss[dir]);
    }
    element.style[dir] = `${dirValue}px`;
    element.style.zIndex = this._getCalculatedZIndex(element);
    if (this._needsPositionStickyOnElement) {
      element.style.cssText += "position: -webkit-sticky; position: sticky; ";
    }
  }
  /**
   * Calculate what the z-index should be for the element, depending on what directions (top,
   * bottom, left, right) have been set. It should be true that elements with a top direction
   * should have the highest index since these are elements like a table header. If any of those
   * elements are also sticky in another direction, then they should appear above other elements
   * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
   * (e.g. footer rows) should then be next in the ordering such that they are below the header
   * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
   * should minimally increment so that they are above non-sticky elements but below top and bottom
   * elements.
   */
  _getCalculatedZIndex(element) {
    const zIndexIncrements = {
      top: 100,
      bottom: 10,
      left: 1,
      right: 1
    };
    let zIndex = 0;
    for (const dir of STICKY_DIRECTIONS) {
      if (element.style[dir]) {
        zIndex += zIndexIncrements[dir];
      }
    }
    return zIndex ? `${zIndex}` : "";
  }
  /** Gets the widths for each cell in the provided row. */
  _getCellWidths(row, recalculateCellWidths = true) {
    if (!recalculateCellWidths && this._cachedCellWidths.length) {
      return this._cachedCellWidths;
    }
    const cellWidths = [];
    const firstRowCells = row.children;
    for (let i = 0; i < firstRowCells.length; i++) {
      let cell = firstRowCells[i];
      cellWidths.push(cell.getBoundingClientRect().width);
    }
    this._cachedCellWidths = cellWidths;
    return cellWidths;
  }
  /**
   * Determines the left and right positions of each sticky column cell, which will be the
   * accumulation of all sticky column cell widths to the left and right, respectively.
   * Non-sticky cells do not need to have a value set since their positions will not be applied.
   */
  _getStickyStartColumnPositions(widths, stickyStates) {
    const positions = [];
    let nextPosition = 0;
    for (let i = 0; i < widths.length; i++) {
      if (stickyStates[i]) {
        positions[i] = nextPosition;
        nextPosition += widths[i];
      }
    }
    return positions;
  }
  /**
   * Determines the left and right positions of each sticky column cell, which will be the
   * accumulation of all sticky column cell widths to the left and right, respectively.
   * Non-sticky cells do not need to have a value set since their positions will not be applied.
   */
  _getStickyEndColumnPositions(widths, stickyStates) {
    const positions = [];
    let nextPosition = 0;
    for (let i = widths.length; i > 0; i--) {
      if (stickyStates[i]) {
        positions[i] = nextPosition;
        nextPosition += widths[i];
      }
    }
    return positions;
  }
};
function getTableUnknownColumnError(id) {
  return Error(`Could not find column with id "${id}".`);
}
function getTableDuplicateColumnNameError(name) {
  return Error(`Duplicate column definition name provided: "${name}".`);
}
function getTableMultipleDefaultRowDefsError() {
  return Error(`There can only be one default row without a when predicate function.`);
}
function getTableMissingMatchingRowDefError(data) {
  return Error(`Could not find a matching row definition for theprovided row data: ${JSON.stringify(data)}`);
}
function getTableMissingRowDefsError() {
  return Error("Missing definitions for header, footer, and row; cannot determine which columns should be rendered.");
}
function getTableUnknownDataSourceError() {
  return Error(`Provided data source did not match an array, Observable, or DataSource`);
}
function getTableTextColumnMissingParentTableError() {
  return Error(`Text column could not find a parent table for registration.`);
}
function getTableTextColumnMissingNameError() {
  return Error(`Table text column must have a name.`);
}
var STICKY_POSITIONING_LISTENER = new InjectionToken("CDK_SPL");
var _CdkRecycleRows = class _CdkRecycleRows {
};
_CdkRecycleRows.ɵfac = function CdkRecycleRows_Factory(t) {
  return new (t || _CdkRecycleRows)();
};
_CdkRecycleRows.ɵdir = ɵɵdefineDirective({
  type: _CdkRecycleRows,
  selectors: [["cdk-table", "recycleRows", ""], ["table", "cdk-table", "", "recycleRows", ""]],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: _VIEW_REPEATER_STRATEGY,
    useClass: _RecycleViewRepeaterStrategy
  }])]
});
var CdkRecycleRows = _CdkRecycleRows;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRecycleRows, [{
    type: Directive,
    args: [{
      selector: "cdk-table[recycleRows], table[cdk-table][recycleRows]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }],
      standalone: true
    }]
  }], null, null);
})();
var _DataRowOutlet = class _DataRowOutlet {
  constructor(viewContainer, elementRef) {
    this.viewContainer = viewContainer;
    this.elementRef = elementRef;
    const table = inject(CDK_TABLE);
    table._rowOutlet = this;
    table._outletAssigned();
  }
};
_DataRowOutlet.ɵfac = function DataRowOutlet_Factory(t) {
  return new (t || _DataRowOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef));
};
_DataRowOutlet.ɵdir = ɵɵdefineDirective({
  type: _DataRowOutlet,
  selectors: [["", "rowOutlet", ""]],
  standalone: true
});
var DataRowOutlet = _DataRowOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[rowOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ElementRef
  }], null);
})();
var _HeaderRowOutlet = class _HeaderRowOutlet {
  constructor(viewContainer, elementRef) {
    this.viewContainer = viewContainer;
    this.elementRef = elementRef;
    const table = inject(CDK_TABLE);
    table._headerRowOutlet = this;
    table._outletAssigned();
  }
};
_HeaderRowOutlet.ɵfac = function HeaderRowOutlet_Factory(t) {
  return new (t || _HeaderRowOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef));
};
_HeaderRowOutlet.ɵdir = ɵɵdefineDirective({
  type: _HeaderRowOutlet,
  selectors: [["", "headerRowOutlet", ""]],
  standalone: true
});
var HeaderRowOutlet = _HeaderRowOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[headerRowOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ElementRef
  }], null);
})();
var _FooterRowOutlet = class _FooterRowOutlet {
  constructor(viewContainer, elementRef) {
    this.viewContainer = viewContainer;
    this.elementRef = elementRef;
    const table = inject(CDK_TABLE);
    table._footerRowOutlet = this;
    table._outletAssigned();
  }
};
_FooterRowOutlet.ɵfac = function FooterRowOutlet_Factory(t) {
  return new (t || _FooterRowOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef));
};
_FooterRowOutlet.ɵdir = ɵɵdefineDirective({
  type: _FooterRowOutlet,
  selectors: [["", "footerRowOutlet", ""]],
  standalone: true
});
var FooterRowOutlet = _FooterRowOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[footerRowOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ElementRef
  }], null);
})();
var _NoDataRowOutlet = class _NoDataRowOutlet {
  constructor(viewContainer, elementRef) {
    this.viewContainer = viewContainer;
    this.elementRef = elementRef;
    const table = inject(CDK_TABLE);
    table._noDataRowOutlet = this;
    table._outletAssigned();
  }
};
_NoDataRowOutlet.ɵfac = function NoDataRowOutlet_Factory(t) {
  return new (t || _NoDataRowOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef));
};
_NoDataRowOutlet.ɵdir = ɵɵdefineDirective({
  type: _NoDataRowOutlet,
  selectors: [["", "noDataRowOutlet", ""]],
  standalone: true
});
var NoDataRowOutlet = _NoDataRowOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoDataRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[noDataRowOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ElementRef
  }], null);
})();
var CDK_TABLE_TEMPLATE = (
  // Note that according to MDN, the `caption` element has to be projected as the **first**
  // element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption
  `
  <ng-content select="caption"/>
  <ng-content select="colgroup, col"/>

  <!--
    Unprojected content throws a hydration error so we need this to capture it.
    It gets removed on the client so it doesn't affect the layout.
  -->
  @if (_isServer) {
    <ng-content/>
  }

  @if (_isNativeHtmlTable) {
    <thead role="rowgroup">
      <ng-container headerRowOutlet/>
    </thead>
    <tbody role="rowgroup">
      <ng-container rowOutlet/>
      <ng-container noDataRowOutlet/>
    </tbody>
    <tfoot role="rowgroup">
      <ng-container footerRowOutlet/>
    </tfoot>
  } @else {
    <ng-container headerRowOutlet/>
    <ng-container rowOutlet/>
    <ng-container noDataRowOutlet/>
    <ng-container footerRowOutlet/>
  }
`
);
var _CdkTable = class _CdkTable {
  /** Aria role to apply to the table's cells based on the table's own role. */
  _getCellRole() {
    if (this._cellRoleInternal === void 0) {
      const role = this._elementRef.nativeElement.getAttribute("role");
      const cellRole = role === "grid" || role === "treegrid" ? "gridcell" : "cell";
      this._cellRoleInternal = this._isNativeHtmlTable && cellRole === "cell" ? null : cellRole;
    }
    return this._cellRoleInternal;
  }
  /**
   * Tracking function that will be used to check the differences in data changes. Used similarly
   * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
   * relative to the function to know if a row should be added/removed/moved.
   * Accepts a function that takes two parameters, `index` and `item`.
   */
  get trackBy() {
    return this._trackByFn;
  }
  set trackBy(fn) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._trackByFn = fn;
  }
  /**
   * The table's source of data, which can be provided in three ways (in order of complexity):
   *   - Simple data array (each object represents one table row)
   *   - Stream that emits a data array each time the array changes
   *   - `DataSource` object that implements the connect/disconnect interface.
   *
   * If a data array is provided, the table must be notified when the array's objects are
   * added, removed, or moved. This can be done by calling the `renderRows()` function which will
   * render the diff since the last table render. If the data array reference is changed, the table
   * will automatically trigger an update to the rows.
   *
   * When providing an Observable stream, the table will trigger an update automatically when the
   * stream emits a new array of data.
   *
   * Finally, when providing a `DataSource` object, the table will use the Observable stream
   * provided by the connect function and trigger updates when that stream emits new data array
   * values. During the table's ngOnDestroy or when the data source is removed from the table, the
   * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
   * subscriptions registered during the connect process).
   */
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(dataSource) {
    if (this._dataSource !== dataSource) {
      this._switchDataSource(dataSource);
    }
  }
  /**
   * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
   * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
   * dataobject will render the first row that evaluates its when predicate to true, in the order
   * defined in the table, or otherwise the default row which does not have a when predicate.
   */
  get multiTemplateDataRows() {
    return this._multiTemplateDataRows;
  }
  set multiTemplateDataRows(value) {
    this._multiTemplateDataRows = value;
    if (this._rowOutlet && this._rowOutlet.viewContainer.length) {
      this._forceRenderDataRows();
      this.updateStickyColumnStyles();
    }
  }
  /**
   * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths
   * and optimize rendering sticky styles for native tables. No-op for flex tables.
   */
  get fixedLayout() {
    return this._fixedLayout;
  }
  set fixedLayout(value) {
    this._fixedLayout = value;
    this._forceRecalculateCellWidths = true;
    this._stickyColumnStylesNeedReset = true;
  }
  constructor(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, _platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener, _ngZone) {
    this._differs = _differs;
    this._changeDetectorRef = _changeDetectorRef;
    this._elementRef = _elementRef;
    this._dir = _dir;
    this._platform = _platform;
    this._viewRepeater = _viewRepeater;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._viewportRuler = _viewportRuler;
    this._stickyPositioningListener = _stickyPositioningListener;
    this._ngZone = _ngZone;
    this._onDestroy = new Subject();
    this._columnDefsByName = /* @__PURE__ */ new Map();
    this._customColumnDefs = /* @__PURE__ */ new Set();
    this._customRowDefs = /* @__PURE__ */ new Set();
    this._customHeaderRowDefs = /* @__PURE__ */ new Set();
    this._customFooterRowDefs = /* @__PURE__ */ new Set();
    this._headerRowDefChanged = true;
    this._footerRowDefChanged = true;
    this._stickyColumnStylesNeedReset = true;
    this._forceRecalculateCellWidths = true;
    this._cachedRenderRowsMap = /* @__PURE__ */ new Map();
    this.stickyCssClass = "cdk-table-sticky";
    this.needsPositionStickyOnElement = true;
    this._isShowingNoDataRow = false;
    this._hasAllOutlets = false;
    this._hasInitialized = false;
    this._cellRoleInternal = void 0;
    this._multiTemplateDataRows = false;
    this._fixedLayout = false;
    this.contentChanged = new EventEmitter();
    this.viewChange = new BehaviorSubject({
      start: 0,
      end: Number.MAX_VALUE
    });
    if (!role) {
      _elementRef.nativeElement.setAttribute("role", "table");
    }
    this._document = _document;
    this._isServer = !_platform.isBrowser;
    this._isNativeHtmlTable = _elementRef.nativeElement.nodeName === "TABLE";
  }
  ngOnInit() {
    this._setupStickyStyler();
    this._dataDiffer = this._differs.find([]).create((_i, dataRow) => {
      return this.trackBy ? this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;
    });
    this._viewportRuler.change().pipe(takeUntil(this._onDestroy)).subscribe(() => {
      this._forceRecalculateCellWidths = true;
    });
  }
  ngAfterContentInit() {
    this._hasInitialized = true;
  }
  ngAfterContentChecked() {
    if (this._canRender()) {
      this._render();
    }
  }
  ngOnDestroy() {
    [this._rowOutlet?.viewContainer, this._headerRowOutlet?.viewContainer, this._footerRowOutlet?.viewContainer, this._cachedRenderRowsMap, this._customColumnDefs, this._customRowDefs, this._customHeaderRowDefs, this._customFooterRowDefs, this._columnDefsByName].forEach((def) => {
      def?.clear();
    });
    this._headerRowDefs = [];
    this._footerRowDefs = [];
    this._defaultRowDef = null;
    this._onDestroy.next();
    this._onDestroy.complete();
    if (isDataSource(this.dataSource)) {
      this.dataSource.disconnect(this);
    }
  }
  /**
   * Renders rows based on the table's latest set of data, which was either provided directly as an
   * input or retrieved through an Observable stream (directly or from a DataSource).
   * Checks for differences in the data since the last diff to perform only the necessary
   * changes (add/remove/move rows).
   *
   * If the table's data source is a DataSource or Observable, this will be invoked automatically
   * each time the provided Observable stream emits a new data array. Otherwise if your data is
   * an array, this function will need to be called to render any changes.
   */
  renderRows() {
    this._renderRows = this._getAllRenderRows();
    const changes = this._dataDiffer.diff(this._renderRows);
    if (!changes) {
      this._updateNoDataRow();
      this.contentChanged.next();
      return;
    }
    const viewContainer = this._rowOutlet.viewContainer;
    this._viewRepeater.applyChanges(changes, viewContainer, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record.item, currentIndex), (record) => record.item.data, (change) => {
      if (change.operation === _ViewRepeaterOperation.INSERTED && change.context) {
        this._renderCellTemplateForItem(change.record.item.rowDef, change.context);
      }
    });
    this._updateRowIndexContext();
    changes.forEachIdentityChange((record) => {
      const rowView = viewContainer.get(record.currentIndex);
      rowView.context.$implicit = record.item.data;
    });
    this._updateNoDataRow();
    if (this._ngZone && NgZone.isInAngularZone()) {
      this._ngZone.onStable.pipe(take(1), takeUntil(this._onDestroy)).subscribe(() => {
        this.updateStickyColumnStyles();
      });
    } else {
      this.updateStickyColumnStyles();
    }
    this.contentChanged.next();
  }
  /** Adds a column definition that was not included as part of the content children. */
  addColumnDef(columnDef) {
    this._customColumnDefs.add(columnDef);
  }
  /** Removes a column definition that was not included as part of the content children. */
  removeColumnDef(columnDef) {
    this._customColumnDefs.delete(columnDef);
  }
  /** Adds a row definition that was not included as part of the content children. */
  addRowDef(rowDef) {
    this._customRowDefs.add(rowDef);
  }
  /** Removes a row definition that was not included as part of the content children. */
  removeRowDef(rowDef) {
    this._customRowDefs.delete(rowDef);
  }
  /** Adds a header row definition that was not included as part of the content children. */
  addHeaderRowDef(headerRowDef) {
    this._customHeaderRowDefs.add(headerRowDef);
    this._headerRowDefChanged = true;
  }
  /** Removes a header row definition that was not included as part of the content children. */
  removeHeaderRowDef(headerRowDef) {
    this._customHeaderRowDefs.delete(headerRowDef);
    this._headerRowDefChanged = true;
  }
  /** Adds a footer row definition that was not included as part of the content children. */
  addFooterRowDef(footerRowDef) {
    this._customFooterRowDefs.add(footerRowDef);
    this._footerRowDefChanged = true;
  }
  /** Removes a footer row definition that was not included as part of the content children. */
  removeFooterRowDef(footerRowDef) {
    this._customFooterRowDefs.delete(footerRowDef);
    this._footerRowDefChanged = true;
  }
  /** Sets a no data row definition that was not included as a part of the content children. */
  setNoDataRow(noDataRow) {
    this._customNoDataRow = noDataRow;
  }
  /**
   * Updates the header sticky styles. First resets all applied styles with respect to the cells
   * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
   * automatically called when the header row changes its displayed set of columns, or if its
   * sticky input changes. May be called manually for cases where the cell content changes outside
   * of these events.
   */
  updateStickyHeaderRowStyles() {
    const headerRows = this._getRenderedRows(this._headerRowOutlet);
    if (this._isNativeHtmlTable) {
      const thead = closestTableSection(this._headerRowOutlet, "thead");
      if (thead) {
        thead.style.display = headerRows.length ? "" : "none";
      }
    }
    const stickyStates = this._headerRowDefs.map((def) => def.sticky);
    this._stickyStyler.clearStickyPositioning(headerRows, ["top"]);
    this._stickyStyler.stickRows(headerRows, stickyStates, "top");
    this._headerRowDefs.forEach((def) => def.resetStickyChanged());
  }
  /**
   * Updates the footer sticky styles. First resets all applied styles with respect to the cells
   * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
   * automatically called when the footer row changes its displayed set of columns, or if its
   * sticky input changes. May be called manually for cases where the cell content changes outside
   * of these events.
   */
  updateStickyFooterRowStyles() {
    const footerRows = this._getRenderedRows(this._footerRowOutlet);
    if (this._isNativeHtmlTable) {
      const tfoot = closestTableSection(this._footerRowOutlet, "tfoot");
      if (tfoot) {
        tfoot.style.display = footerRows.length ? "" : "none";
      }
    }
    const stickyStates = this._footerRowDefs.map((def) => def.sticky);
    this._stickyStyler.clearStickyPositioning(footerRows, ["bottom"]);
    this._stickyStyler.stickRows(footerRows, stickyStates, "bottom");
    this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);
    this._footerRowDefs.forEach((def) => def.resetStickyChanged());
  }
  /**
   * Updates the column sticky styles. First resets all applied styles with respect to the cells
   * sticking to the left and right. Then sticky styles are added for the left and right according
   * to the column definitions for each cell in each row. This is automatically called when
   * the data source provides a new set of data or when a column definition changes its sticky
   * input. May be called manually for cases where the cell content changes outside of these events.
   */
  updateStickyColumnStyles() {
    const headerRows = this._getRenderedRows(this._headerRowOutlet);
    const dataRows = this._getRenderedRows(this._rowOutlet);
    const footerRows = this._getRenderedRows(this._footerRowOutlet);
    if (this._isNativeHtmlTable && !this._fixedLayout || this._stickyColumnStylesNeedReset) {
      this._stickyStyler.clearStickyPositioning([...headerRows, ...dataRows, ...footerRows], ["left", "right"]);
      this._stickyColumnStylesNeedReset = false;
    }
    headerRows.forEach((headerRow, i) => {
      this._addStickyColumnStyles([headerRow], this._headerRowDefs[i]);
    });
    this._rowDefs.forEach((rowDef) => {
      const rows = [];
      for (let i = 0; i < dataRows.length; i++) {
        if (this._renderRows[i].rowDef === rowDef) {
          rows.push(dataRows[i]);
        }
      }
      this._addStickyColumnStyles(rows, rowDef);
    });
    footerRows.forEach((footerRow, i) => {
      this._addStickyColumnStyles([footerRow], this._footerRowDefs[i]);
    });
    Array.from(this._columnDefsByName.values()).forEach((def) => def.resetStickyChanged());
  }
  /** Invoked whenever an outlet is created and has been assigned to the table. */
  _outletAssigned() {
    if (!this._hasAllOutlets && this._rowOutlet && this._headerRowOutlet && this._footerRowOutlet && this._noDataRowOutlet) {
      this._hasAllOutlets = true;
      if (this._canRender()) {
        this._render();
      }
    }
  }
  /** Whether the table has all the information to start rendering. */
  _canRender() {
    return this._hasAllOutlets && this._hasInitialized;
  }
  /** Renders the table if its state has changed. */
  _render() {
    this._cacheRowDefs();
    this._cacheColumnDefs();
    if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMissingRowDefsError();
    }
    const columnsChanged = this._renderUpdatedColumns();
    const rowDefsChanged = columnsChanged || this._headerRowDefChanged || this._footerRowDefChanged;
    this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || rowDefsChanged;
    this._forceRecalculateCellWidths = rowDefsChanged;
    if (this._headerRowDefChanged) {
      this._forceRenderHeaderRows();
      this._headerRowDefChanged = false;
    }
    if (this._footerRowDefChanged) {
      this._forceRenderFooterRows();
      this._footerRowDefChanged = false;
    }
    if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {
      this._observeRenderChanges();
    } else if (this._stickyColumnStylesNeedReset) {
      this.updateStickyColumnStyles();
    }
    this._checkStickyStates();
  }
  /**
   * Get the list of RenderRow objects to render according to the current list of data and defined
   * row definitions. If the previous list already contained a particular pair, it should be reused
   * so that the differ equates their references.
   */
  _getAllRenderRows() {
    const renderRows = [];
    const prevCachedRenderRows = this._cachedRenderRowsMap;
    this._cachedRenderRowsMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < this._data.length; i++) {
      let data = this._data[i];
      const renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));
      if (!this._cachedRenderRowsMap.has(data)) {
        this._cachedRenderRowsMap.set(data, /* @__PURE__ */ new WeakMap());
      }
      for (let j = 0; j < renderRowsForData.length; j++) {
        let renderRow = renderRowsForData[j];
        const cache = this._cachedRenderRowsMap.get(renderRow.data);
        if (cache.has(renderRow.rowDef)) {
          cache.get(renderRow.rowDef).push(renderRow);
        } else {
          cache.set(renderRow.rowDef, [renderRow]);
        }
        renderRows.push(renderRow);
      }
    }
    return renderRows;
  }
  /**
   * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
   * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
   * `(T, CdkRowDef)` pair.
   */
  _getRenderRowsForData(data, dataIndex, cache) {
    const rowDefs = this._getRowDefs(data, dataIndex);
    return rowDefs.map((rowDef) => {
      const cachedRenderRows = cache && cache.has(rowDef) ? cache.get(rowDef) : [];
      if (cachedRenderRows.length) {
        const dataRow = cachedRenderRows.shift();
        dataRow.dataIndex = dataIndex;
        return dataRow;
      } else {
        return {
          data,
          rowDef,
          dataIndex
        };
      }
    });
  }
  /** Update the map containing the content's column definitions. */
  _cacheColumnDefs() {
    this._columnDefsByName.clear();
    const columnDefs = mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs);
    columnDefs.forEach((columnDef) => {
      if (this._columnDefsByName.has(columnDef.name) && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableDuplicateColumnNameError(columnDef.name);
      }
      this._columnDefsByName.set(columnDef.name, columnDef);
    });
  }
  /** Update the list of all available row definitions that can be used. */
  _cacheRowDefs() {
    this._headerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs);
    this._footerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs);
    this._rowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);
    const defaultRowDefs = this._rowDefs.filter((def) => !def.when);
    if (!this.multiTemplateDataRows && defaultRowDefs.length > 1 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMultipleDefaultRowDefsError();
    }
    this._defaultRowDef = defaultRowDefs[0];
  }
  /**
   * Check if the header, data, or footer rows have changed what columns they want to display or
   * whether the sticky states have changed for the header or footer. If there is a diff, then
   * re-render that section.
   */
  _renderUpdatedColumns() {
    const columnsDiffReducer = (acc, def) => acc || !!def.getColumnsDiff();
    const dataColumnsChanged = this._rowDefs.reduce(columnsDiffReducer, false);
    if (dataColumnsChanged) {
      this._forceRenderDataRows();
    }
    const headerColumnsChanged = this._headerRowDefs.reduce(columnsDiffReducer, false);
    if (headerColumnsChanged) {
      this._forceRenderHeaderRows();
    }
    const footerColumnsChanged = this._footerRowDefs.reduce(columnsDiffReducer, false);
    if (footerColumnsChanged) {
      this._forceRenderFooterRows();
    }
    return dataColumnsChanged || headerColumnsChanged || footerColumnsChanged;
  }
  /**
   * Switch to the provided data source by resetting the data and unsubscribing from the current
   * render change subscription if one exists. If the data source is null, interpret this by
   * clearing the row outlet. Otherwise start listening for new data.
   */
  _switchDataSource(dataSource) {
    this._data = [];
    if (isDataSource(this.dataSource)) {
      this.dataSource.disconnect(this);
    }
    if (this._renderChangeSubscription) {
      this._renderChangeSubscription.unsubscribe();
      this._renderChangeSubscription = null;
    }
    if (!dataSource) {
      if (this._dataDiffer) {
        this._dataDiffer.diff([]);
      }
      if (this._rowOutlet) {
        this._rowOutlet.viewContainer.clear();
      }
    }
    this._dataSource = dataSource;
  }
  /** Set up a subscription for the data provided by the data source. */
  _observeRenderChanges() {
    if (!this.dataSource) {
      return;
    }
    let dataStream;
    if (isDataSource(this.dataSource)) {
      dataStream = this.dataSource.connect(this);
    } else if (isObservable(this.dataSource)) {
      dataStream = this.dataSource;
    } else if (Array.isArray(this.dataSource)) {
      dataStream = of(this.dataSource);
    }
    if (dataStream === void 0 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableUnknownDataSourceError();
    }
    this._renderChangeSubscription = dataStream.pipe(takeUntil(this._onDestroy)).subscribe((data) => {
      this._data = data || [];
      this.renderRows();
    });
  }
  /**
   * Clears any existing content in the header row outlet and creates a new embedded view
   * in the outlet using the header row definition.
   */
  _forceRenderHeaderRows() {
    if (this._headerRowOutlet.viewContainer.length > 0) {
      this._headerRowOutlet.viewContainer.clear();
    }
    this._headerRowDefs.forEach((def, i) => this._renderRow(this._headerRowOutlet, def, i));
    this.updateStickyHeaderRowStyles();
  }
  /**
   * Clears any existing content in the footer row outlet and creates a new embedded view
   * in the outlet using the footer row definition.
   */
  _forceRenderFooterRows() {
    if (this._footerRowOutlet.viewContainer.length > 0) {
      this._footerRowOutlet.viewContainer.clear();
    }
    this._footerRowDefs.forEach((def, i) => this._renderRow(this._footerRowOutlet, def, i));
    this.updateStickyFooterRowStyles();
  }
  /** Adds the sticky column styles for the rows according to the columns' stick states. */
  _addStickyColumnStyles(rows, rowDef) {
    const columnDefs = Array.from(rowDef.columns || []).map((columnName) => {
      const columnDef = this._columnDefsByName.get(columnName);
      if (!columnDef && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableUnknownColumnError(columnName);
      }
      return columnDef;
    });
    const stickyStartStates = columnDefs.map((columnDef) => columnDef.sticky);
    const stickyEndStates = columnDefs.map((columnDef) => columnDef.stickyEnd);
    this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates, !this._fixedLayout || this._forceRecalculateCellWidths);
  }
  /** Gets the list of rows that have been rendered in the row outlet. */
  _getRenderedRows(rowOutlet) {
    const renderedRows = [];
    for (let i = 0; i < rowOutlet.viewContainer.length; i++) {
      const viewRef = rowOutlet.viewContainer.get(i);
      renderedRows.push(viewRef.rootNodes[0]);
    }
    return renderedRows;
  }
  /**
   * Get the matching row definitions that should be used for this row data. If there is only
   * one row definition, it is returned. Otherwise, find the row definitions that has a when
   * predicate that returns true with the data. If none return true, return the default row
   * definition.
   */
  _getRowDefs(data, dataIndex) {
    if (this._rowDefs.length == 1) {
      return [this._rowDefs[0]];
    }
    let rowDefs = [];
    if (this.multiTemplateDataRows) {
      rowDefs = this._rowDefs.filter((def) => !def.when || def.when(dataIndex, data));
    } else {
      let rowDef = this._rowDefs.find((def) => def.when && def.when(dataIndex, data)) || this._defaultRowDef;
      if (rowDef) {
        rowDefs.push(rowDef);
      }
    }
    if (!rowDefs.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMissingMatchingRowDefError(data);
    }
    return rowDefs;
  }
  _getEmbeddedViewArgs(renderRow, index) {
    const rowDef = renderRow.rowDef;
    const context = {
      $implicit: renderRow.data
    };
    return {
      templateRef: rowDef.template,
      context,
      index
    };
  }
  /**
   * Creates a new row template in the outlet and fills it with the set of cell templates.
   * Optionally takes a context to provide to the row and cells, as well as an optional index
   * of where to place the new row template in the outlet.
   */
  _renderRow(outlet, rowDef, index, context = {}) {
    const view = outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);
    this._renderCellTemplateForItem(rowDef, context);
    return view;
  }
  _renderCellTemplateForItem(rowDef, context) {
    for (let cellTemplate of this._getCellTemplates(rowDef)) {
      if (CdkCellOutlet.mostRecentCellOutlet) {
        CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);
      }
    }
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Updates the index-related context for each row to reflect any changes in the index of the rows,
   * e.g. first/last/even/odd.
   */
  _updateRowIndexContext() {
    const viewContainer = this._rowOutlet.viewContainer;
    for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {
      const viewRef = viewContainer.get(renderIndex);
      const context = viewRef.context;
      context.count = count;
      context.first = renderIndex === 0;
      context.last = renderIndex === count - 1;
      context.even = renderIndex % 2 === 0;
      context.odd = !context.even;
      if (this.multiTemplateDataRows) {
        context.dataIndex = this._renderRows[renderIndex].dataIndex;
        context.renderIndex = renderIndex;
      } else {
        context.index = this._renderRows[renderIndex].dataIndex;
      }
    }
  }
  /** Gets the column definitions for the provided row def. */
  _getCellTemplates(rowDef) {
    if (!rowDef || !rowDef.columns) {
      return [];
    }
    return Array.from(rowDef.columns, (columnId) => {
      const column = this._columnDefsByName.get(columnId);
      if (!column && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableUnknownColumnError(columnId);
      }
      return rowDef.extractCellTemplate(column);
    });
  }
  /**
   * Forces a re-render of the data rows. Should be called in cases where there has been an input
   * change that affects the evaluation of which rows should be rendered, e.g. toggling
   * `multiTemplateDataRows` or adding/removing row definitions.
   */
  _forceRenderDataRows() {
    this._dataDiffer.diff([]);
    this._rowOutlet.viewContainer.clear();
    this.renderRows();
  }
  /**
   * Checks if there has been a change in sticky states since last check and applies the correct
   * sticky styles. Since checking resets the "dirty" state, this should only be performed once
   * during a change detection and after the inputs are settled (after content check).
   */
  _checkStickyStates() {
    const stickyCheckReducer = (acc, d) => {
      return acc || d.hasStickyChanged();
    };
    if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {
      this.updateStickyHeaderRowStyles();
    }
    if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {
      this.updateStickyFooterRowStyles();
    }
    if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {
      this._stickyColumnStylesNeedReset = true;
      this.updateStickyColumnStyles();
    }
  }
  /**
   * Creates the sticky styler that will be used for sticky rows and columns. Listens
   * for directionality changes and provides the latest direction to the styler. Re-applies column
   * stickiness when directionality changes.
   */
  _setupStickyStyler() {
    const direction = this._dir ? this._dir.value : "ltr";
    this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement, this._stickyPositioningListener);
    (this._dir ? this._dir.change : of()).pipe(takeUntil(this._onDestroy)).subscribe((value) => {
      this._stickyStyler.direction = value;
      this.updateStickyColumnStyles();
    });
  }
  /** Filters definitions that belong to this table from a QueryList. */
  _getOwnDefs(items) {
    return items.filter((item) => !item._table || item._table === this);
  }
  /** Creates or removes the no data row, depending on whether any data is being shown. */
  _updateNoDataRow() {
    const noDataRow = this._customNoDataRow || this._noDataRow;
    if (!noDataRow) {
      return;
    }
    const shouldShow = this._rowOutlet.viewContainer.length === 0;
    if (shouldShow === this._isShowingNoDataRow) {
      return;
    }
    const container = this._noDataRowOutlet.viewContainer;
    if (shouldShow) {
      const view = container.createEmbeddedView(noDataRow.templateRef);
      const rootNode = view.rootNodes[0];
      if (view.rootNodes.length === 1 && rootNode?.nodeType === this._document.ELEMENT_NODE) {
        rootNode.setAttribute("role", "row");
        rootNode.classList.add(noDataRow._contentClassName);
      }
    } else {
      container.clear();
    }
    this._isShowingNoDataRow = shouldShow;
    this._changeDetectorRef.markForCheck();
  }
};
_CdkTable.ɵfac = function CdkTable_Factory(t) {
  return new (t || _CdkTable)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵinjectAttribute("role"), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(STICKY_POSITIONING_LISTENER, 12), ɵɵdirectiveInject(NgZone, 8));
};
_CdkTable.ɵcmp = ɵɵdefineComponent({
  type: _CdkTable,
  selectors: [["cdk-table"], ["table", "cdk-table", ""]],
  contentQueries: function CdkTable_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CdkNoDataRow, 5);
      ɵɵcontentQuery(dirIndex, CdkColumnDef, 5);
      ɵɵcontentQuery(dirIndex, CdkRowDef, 5);
      ɵɵcontentQuery(dirIndex, CdkHeaderRowDef, 5);
      ɵɵcontentQuery(dirIndex, CdkFooterRowDef, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._noDataRow = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentColumnDefs = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentRowDefs = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentHeaderRowDefs = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentFooterRowDefs = _t);
    }
  },
  hostAttrs: [1, "cdk-table"],
  hostVars: 2,
  hostBindings: function CdkTable_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cdk-table-fixed-layout", ctx.fixedLayout);
    }
  },
  inputs: {
    trackBy: "trackBy",
    dataSource: "dataSource",
    multiTemplateDataRows: [InputFlags.HasDecoratorInputTransform, "multiTemplateDataRows", "multiTemplateDataRows", booleanAttribute],
    fixedLayout: [InputFlags.HasDecoratorInputTransform, "fixedLayout", "fixedLayout", booleanAttribute]
  },
  outputs: {
    contentChanged: "contentChanged"
  },
  exportAs: ["cdkTable"],
  standalone: true,
  features: [ɵɵProvidersFeature([
    {
      provide: CDK_TABLE,
      useExisting: _CdkTable
    },
    {
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _DisposeViewRepeaterStrategy
    },
    {
      provide: _COALESCED_STYLE_SCHEDULER,
      useClass: _CoalescedStyleScheduler
    },
    // Prevent nested tables from seeing this table's StickyPositioningListener.
    {
      provide: STICKY_POSITIONING_LISTENER,
      useValue: null
    }
  ]), ɵɵInputTransformsFeature, ɵɵStandaloneFeature],
  ngContentSelectors: _c12,
  decls: 5,
  vars: 2,
  consts: [["role", "rowgroup"], ["headerRowOutlet", ""], ["rowOutlet", ""], ["noDataRowOutlet", ""], ["footerRowOutlet", ""]],
  template: function CdkTable_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c02);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
      ɵɵtemplate(2, CdkTable_Conditional_2_Template, 1, 0)(3, CdkTable_Conditional_3_Template, 7, 0)(4, CdkTable_Conditional_4_Template, 4, 0);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵconditional(2, ctx._isServer ? 2 : -1);
      ɵɵadvance();
      ɵɵconditional(3, ctx._isNativeHtmlTable ? 3 : 4);
    }
  },
  dependencies: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],
  styles: [".cdk-table-fixed-layout{table-layout:fixed}"],
  encapsulation: 2
});
var CdkTable = _CdkTable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTable, [{
    type: Component,
    args: [{
      selector: "cdk-table, table[cdk-table]",
      exportAs: "cdkTable",
      template: CDK_TABLE_TEMPLATE,
      host: {
        "class": "cdk-table",
        "[class.cdk-table-fixed-layout]": "fixedLayout"
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.Default,
      providers: [
        {
          provide: CDK_TABLE,
          useExisting: CdkTable
        },
        {
          provide: _VIEW_REPEATER_STRATEGY,
          useClass: _DisposeViewRepeaterStrategy
        },
        {
          provide: _COALESCED_STYLE_SCHEDULER,
          useClass: _CoalescedStyleScheduler
        },
        // Prevent nested tables from seeing this table's StickyPositioningListener.
        {
          provide: STICKY_POSITIONING_LISTENER,
          useValue: null
        }
      ],
      standalone: true,
      imports: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],
      styles: [".cdk-table-fixed-layout{table-layout:fixed}"]
    }]
  }], () => [{
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["role"]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: _CoalescedStyleScheduler,
    decorators: [{
      type: Inject,
      args: [_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: ViewportRuler
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [STICKY_POSITIONING_LISTENER]
    }]
  }, {
    type: NgZone,
    decorators: [{
      type: Optional
    }]
  }], {
    trackBy: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    multiTemplateDataRows: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    fixedLayout: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    contentChanged: [{
      type: Output
    }],
    _contentColumnDefs: [{
      type: ContentChildren,
      args: [CdkColumnDef, {
        descendants: true
      }]
    }],
    _contentRowDefs: [{
      type: ContentChildren,
      args: [CdkRowDef, {
        descendants: true
      }]
    }],
    _contentHeaderRowDefs: [{
      type: ContentChildren,
      args: [CdkHeaderRowDef, {
        descendants: true
      }]
    }],
    _contentFooterRowDefs: [{
      type: ContentChildren,
      args: [CdkFooterRowDef, {
        descendants: true
      }]
    }],
    _noDataRow: [{
      type: ContentChild,
      args: [CdkNoDataRow]
    }]
  });
})();
function mergeArrayAndSet(array, set) {
  return array.concat(Array.from(set));
}
function closestTableSection(outlet, section) {
  const uppercaseSection = section.toUpperCase();
  let current = outlet.viewContainer.element.nativeElement;
  while (current) {
    const nodeName = current.nodeType === 1 ? current.nodeName : null;
    if (nodeName === uppercaseSection) {
      return current;
    } else if (nodeName === "TABLE") {
      break;
    }
    current = current.parentNode;
  }
  return null;
}
var _CdkTextColumn = class _CdkTextColumn {
  /** Column name that should be used to reference this column. */
  get name() {
    return this._name;
  }
  set name(name) {
    this._name = name;
    this._syncColumnDefName();
  }
  constructor(_table, _options) {
    this._table = _table;
    this._options = _options;
    this.justify = "start";
    this._options = _options || {};
  }
  ngOnInit() {
    this._syncColumnDefName();
    if (this.headerText === void 0) {
      this.headerText = this._createDefaultHeaderText();
    }
    if (!this.dataAccessor) {
      this.dataAccessor = this._options.defaultDataAccessor || ((data, name) => data[name]);
    }
    if (this._table) {
      this.columnDef.cell = this.cell;
      this.columnDef.headerCell = this.headerCell;
      this._table.addColumnDef(this.columnDef);
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw getTableTextColumnMissingParentTableError();
    }
  }
  ngOnDestroy() {
    if (this._table) {
      this._table.removeColumnDef(this.columnDef);
    }
  }
  /**
   * Creates a default header text. Use the options' header text transformation function if one
   * has been provided. Otherwise simply capitalize the column name.
   */
  _createDefaultHeaderText() {
    const name = this.name;
    if (!name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableTextColumnMissingNameError();
    }
    if (this._options && this._options.defaultHeaderTextTransform) {
      return this._options.defaultHeaderTextTransform(name);
    }
    return name[0].toUpperCase() + name.slice(1);
  }
  /** Synchronizes the column definition name with the text column name. */
  _syncColumnDefName() {
    if (this.columnDef) {
      this.columnDef.name = this.name;
    }
  }
};
_CdkTextColumn.ɵfac = function CdkTextColumn_Factory(t) {
  return new (t || _CdkTextColumn)(ɵɵdirectiveInject(CdkTable, 8), ɵɵdirectiveInject(TEXT_COLUMN_OPTIONS, 8));
};
_CdkTextColumn.ɵcmp = ɵɵdefineComponent({
  type: _CdkTextColumn,
  selectors: [["cdk-text-column"]],
  viewQuery: function CdkTextColumn_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(CdkColumnDef, 7);
      ɵɵviewQuery(CdkCellDef, 7);
      ɵɵviewQuery(CdkHeaderCellDef, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnDef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cell = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerCell = _t.first);
    }
  },
  inputs: {
    name: "name",
    headerText: "headerText",
    dataAccessor: "dataAccessor",
    justify: "justify"
  },
  standalone: true,
  features: [ɵɵStandaloneFeature],
  decls: 3,
  vars: 0,
  consts: [["cdkColumnDef", ""], ["cdk-header-cell", "", 3, "text-align", 4, "cdkHeaderCellDef"], ["cdk-cell", "", 3, "text-align", 4, "cdkCellDef"], ["cdk-header-cell", ""], ["cdk-cell", ""]],
  template: function CdkTextColumn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0, 0);
      ɵɵtemplate(1, CdkTextColumn_th_1_Template, 2, 3, "th", 1)(2, CdkTextColumn_td_2_Template, 2, 3, "td", 2);
      ɵɵelementContainerEnd();
    }
  },
  dependencies: [CdkColumnDef, CdkHeaderCellDef, CdkHeaderCell, CdkCellDef, CdkCell],
  encapsulation: 2
});
var CdkTextColumn = _CdkTextColumn;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTextColumn, [{
    type: Component,
    args: [{
      selector: "cdk-text-column",
      template: `
    <ng-container cdkColumnDef>
      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]="justify">
        {{headerText}}
      </th>
      <td cdk-cell *cdkCellDef="let data" [style.text-align]="justify">
        {{dataAccessor(data, name)}}
      </td>
    </ng-container>
  `,
      encapsulation: ViewEncapsulation$1.None,
      // Change detection is intentionally not set to OnPush. This component's template will be provided
      // to the table to be inserted into its view. This is problematic when change detection runs since
      // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
      // mean's the template in the table's view will not have the updated value (and in fact will cause
      // an ExpressionChangedAfterItHasBeenCheckedError).
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      standalone: true,
      imports: [CdkColumnDef, CdkHeaderCellDef, CdkHeaderCell, CdkCellDef, CdkCell]
    }]
  }], () => [{
    type: CdkTable,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [TEXT_COLUMN_OPTIONS]
    }]
  }], {
    name: [{
      type: Input
    }],
    headerText: [{
      type: Input
    }],
    dataAccessor: [{
      type: Input
    }],
    justify: [{
      type: Input
    }],
    columnDef: [{
      type: ViewChild,
      args: [CdkColumnDef, {
        static: true
      }]
    }],
    cell: [{
      type: ViewChild,
      args: [CdkCellDef, {
        static: true
      }]
    }],
    headerCell: [{
      type: ViewChild,
      args: [CdkHeaderCellDef, {
        static: true
      }]
    }]
  });
})();
var EXPORTED_DECLARATIONS = [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet];
var _CdkTableModule = class _CdkTableModule {
};
_CdkTableModule.ɵfac = function CdkTableModule_Factory(t) {
  return new (t || _CdkTableModule)();
};
_CdkTableModule.ɵmod = ɵɵdefineNgModule({
  type: _CdkTableModule,
  imports: [ScrollingModule, CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet],
  exports: [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet]
});
_CdkTableModule.ɵinj = ɵɵdefineInjector({
  imports: [ScrollingModule]
});
var CdkTableModule = _CdkTableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTableModule, [{
    type: NgModule,
    args: [{
      exports: EXPORTED_DECLARATIONS,
      imports: [ScrollingModule, ...EXPORTED_DECLARATIONS]
    }]
  }], null, null);
})();

// node_modules/@nebular/theme/fesm2022/nebular-theme.mjs
function NbOverlayContainerComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.content);
  }
}
function NbOverlayContainerComponent_ng_template_1_Template(rf, ctx) {
}
var _c03 = ["*"];
var _c13 = [[["nb-card-header"]], [["nb-card-body"]], "*", [["nb-card-footer"]]];
var _c2 = ["nb-card-header", "nb-card-body", "*", "nb-card-footer"];
var _c3 = [[["nb-card-front"]], [["nb-card-back"]]];
var _c4 = ["nb-card-front", "nb-card-back"];
function NbRevealCardComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 2);
    ɵɵlistener("click", function NbRevealCardComponent_a_3_Template_a_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵelement(1, "nb-icon", 3);
    ɵɵelementEnd();
  }
}
function NbFlipCardComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 4);
    ɵɵlistener("click", function NbFlipCardComponent_a_3_Template_a_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵelement(1, "nb-icon", 5);
    ɵɵelementEnd();
  }
}
function NbFlipCardComponent_a_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 4);
    ɵɵlistener("click", function NbFlipCardComponent_a_6_Template_a_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵelement(1, "nb-icon", 5);
    ɵɵelementEnd();
  }
}
var _c5 = [[["nb-card"]]];
var _c6 = ["nb-card"];
var _c7 = ["nbButton", ""];
function NbCalendarPickerRowComponent_ng_template_0_Template(rf, ctx) {
}
function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-picker-row", 1);
    ɵɵlistener("select", function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template_nb_calendar_picker_row_select_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.select.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("row", row_r3)("visibleDate", ctx_r1.visibleDate)("selectedValue", ctx_r1.selectedValue)("component", ctx_r1.cellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("size", ctx_r1.size);
  }
}
function NbCalendarDaysNamesComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r1 = ctx.$implicit;
    ɵɵclassProp("holiday", day_r1.isHoliday);
    ɵɵadvance();
    ɵɵtextInterpolate(day_r1.name);
  }
}
function NbCalendarWeekNumberComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const weekNumber_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(weekNumber_r1);
  }
}
var _c8 = "\n\n\n\n\n[_nghost-%COMP%]{display:flex;flex-direction:column}";
function NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-calendar-week-numbers", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("weeks", ctx_r0.weeks)("size", ctx_r0.size)("weekNumberSymbol", ctx_r0.weekNumberSymbol);
  }
}
function NbBaseCalendarComponent_nb_card_header_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-card-header", 5)(1, "nb-calendar-view-mode", 6);
    ɵɵlistener("changeMode", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_view_mode_changeMode_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChangeViewMode());
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "nb-calendar-pageable-navigation", 7);
    ɵɵlistener("prev", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_pageable_navigation_prev_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigatePrev());
    })("next", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_pageable_navigation_next_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigateNext());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("date", ctx_r1.visibleDate)("viewMode", ctx_r1.activeViewMode);
  }
}
function NbBaseCalendarComponent_nb_calendar_day_picker_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-day-picker", 8);
    ɵɵlistener("dateChange", function NbBaseCalendarComponent_nb_calendar_day_picker_3_Template_nb_calendar_day_picker_dateChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.dateChange.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("boundingMonths", ctx_r1.boundingMonth)("cellComponent", ctx_r1.dayCellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("visibleDate", ctx_r1.visibleDate)("size", ctx_r1.size)("date", ctx_r1.date)("showWeekNumber", ctx_r1.showWeekNumber)("firstDayOfWeek", ctx_r1.firstDayOfWeek)("weekNumberSymbol", ctx_r1.weekNumberSymbol);
  }
}
function NbBaseCalendarComponent_nb_calendar_year_picker_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-year-picker", 9);
    ɵɵlistener("yearChange", function NbBaseCalendarComponent_nb_calendar_year_picker_4_Template_nb_calendar_year_picker_yearChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ctx_r1.setVisibleDate($event);
      return ɵɵresetView(ctx_r1.setViewMode(ctx_r1.ViewMode.MONTH));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("cellComponent", ctx_r1.yearCellComponent)("date", ctx_r1.date)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("size", ctx_r1.size)("year", ctx_r1.visibleDate);
  }
}
function NbBaseCalendarComponent_nb_calendar_month_picker_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-month-picker", 10);
    ɵɵlistener("monthChange", function NbBaseCalendarComponent_nb_calendar_month_picker_5_Template_nb_calendar_month_picker_monthChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      ctx_r1.setVisibleDate($event);
      return ɵɵresetView(ctx_r1.setViewMode(ctx_r1.ViewMode.DATE));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("cellComponent", ctx_r1.monthCellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("size", ctx_r1.size)("month", ctx_r1.visibleDate)("date", ctx_r1.date);
  }
}
function NbCalendarActionsComponent_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 2);
    ɵɵlistener("click", function NbCalendarActionsComponent_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.setCurrentTime.emit());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.currentTimeText, "");
  }
}
var _c9 = [[["nb-list-item"]]];
var _c10 = ["nb-list-item"];
var _c11 = ["valueContainer"];
function NbTimePickerComponent_nb_card_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 8);
    ɵɵtext(2, "Time");
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.secondsText);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_5_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵtextInterpolate(ctx_r0.ampmText);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_3_div_5_ng_template_1_Template, 1, 1, "ng-template", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showAmPmLabel);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "div", 8);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbTimePickerComponent_nb_card_0_ng_template_3_div_4_Template, 2, 1, "div", 9)(5, NbTimePickerComponent_nb_card_0_ng_template_3_div_5_Template, 2, 1, "div", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.hoursText);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.minutesText);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.withSeconds);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.twelveHoursFormat);
  }
}
function NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template_nb_timepicker_cell_select_1_listener() {
      const item_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.selectFullTime(item_r3));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassProp("selected", ctx_r0.isSelectedFullTimeValue(item_r3));
    ɵɵadvance();
    ɵɵproperty("value", ctx_r0.getFullTimeString(item_r3))("selected", ctx_r0.isSelectedFullTimeValue(item_r3));
  }
}
function NbTimePickerComponent_nb_card_0_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "nb-list", 11);
    ɵɵtemplate(2, NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r0.fullTimeOptions)("ngForTrackBy", ctx_r0.trackBySingleColumnValue.bind(ctx_r0));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const item_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.setHour(item_r5.value));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassProp("selected", ctx_r0.isSelectedHour(item_r5.value));
    ɵɵadvance();
    ɵɵproperty("value", item_r5.text)("selected", ctx_r0.isSelectedHour(item_r5.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template_nb_timepicker_cell_select_1_listener() {
      const item_r7 = ɵɵrestoreView(_r6).$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.setMinute(item_r7.value));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r7 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassProp("selected", ctx_r0.isSelectedMinute(item_r7.value));
    ɵɵadvance();
    ɵɵproperty("value", item_r7.text)("selected", ctx_r0.isSelectedMinute(item_r7.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const item_r9 = ɵɵrestoreView(_r8).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0.setSecond(item_r9.value));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r9 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassProp("selected", ctx_r0.isSelectedSecond(item_r9.value));
    ɵɵadvance();
    ɵɵproperty("value", item_r9.text)("selected", ctx_r0.isSelectedSecond(item_r9.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-list", 11);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.secondsColumnOptions)("ngForTrackBy", ctx_r0.trackByTimeValues);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 17)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const dayPeriod_r11 = ɵɵrestoreView(_r10).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0.changeDayPeriod(dayPeriod_r11));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const dayPeriod_r11 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassProp("selected", ctx_r0.isSelectedDayPeriod(dayPeriod_r11));
    ɵɵadvance();
    ɵɵproperty("value", dayPeriod_r11)("selected", ctx_r0.isSelectedDayPeriod(dayPeriod_r11));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-list", 11);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template, 2, 4, "nb-list-item", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.dayPeriodColumnOptions)("ngForTrackBy", ctx_r0.trackByDayPeriod);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-list", 11);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
    ɵɵelementStart(2, "nb-list", 11);
    ɵɵtemplate(3, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_Template, 2, 2, "nb-list", 15)(5, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_Template, 2, 2, "nb-list", 15);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.hoursColumnOptions)("ngForTrackBy", ctx_r0.trackByTimeValues);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r0.minutesColumnOptions)("ngForTrackBy", ctx_r0.trackByTimeValues);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showSeconds());
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.twelveHoursFormat);
  }
}
function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-card-footer", 18)(1, "nb-calendar-actions", 19);
    ɵɵlistener("setCurrentTime", function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template_nb_calendar_actions_setCurrentTime_1_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.setCurrentTime());
    })("saveValue", function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template_nb_calendar_actions_saveValue_1_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.saveValue());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("applyButtonText", ctx_r0.applyButtonText)("currentTimeButtonText", ctx_r0.currentTimeButtonText);
  }
}
function NbTimePickerComponent_nb_card_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-card", 3)(1, "nb-card-header", 4);
    ɵɵtemplate(2, NbTimePickerComponent_nb_card_0_ng_container_2_Template, 3, 0, "ng-container", 5)(3, NbTimePickerComponent_nb_card_0_ng_template_3_Template, 6, 4, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 6);
    ɵɵtemplate(6, NbTimePickerComponent_nb_card_0_ng_container_6_Template, 3, 2, "ng-container", 5)(7, NbTimePickerComponent_nb_card_0_ng_template_7_Template, 6, 6, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵtemplate(9, NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template, 2, 2, "nb-card-footer", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const fullTimeHeadersBlock_r13 = ɵɵreference(4);
    const fullTimeColumnBlock_r14 = ɵɵreference(8);
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("supports-scrollbar-theming", !ctx_r0.isFirefox());
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.singleColumn)("ngIfElse", fullTimeHeadersBlock_r13);
    ɵɵadvance(4);
    ɵɵproperty("ngIf", ctx_r0.singleColumn)("ngIfElse", fullTimeColumnBlock_r14);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.showFooter);
  }
}
var _c122 = ["layoutTopDynamicArea"];
var _c132 = ["scrollableContainer"];
var _c14 = ["layoutContainer"];
var _c15 = [[["nb-layout-header", 3, "subheader", ""]], [["nb-sidebar"]], [["nb-layout-header", "subheader", ""]], [["nb-layout-column"]], [["nb-layout-footer"]]];
var _c16 = ["nb-layout-header:not([subheader])", "nb-sidebar", "nb-layout-header[subheader]", "nb-layout-column", "nb-layout-footer"];
var _c17 = ["nbMenuItem", ""];
function NbMenuItemComponent_span_0_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, NbMenuItemComponent_span_0_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.menuItem.title, "\n");
  }
}
function NbMenuItemComponent_a_1_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const badgeTemplate_r3 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 8);
    ɵɵlistener("mouseenter", function NbMenuItemComponent_a_1_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    })("click", function NbMenuItemComponent_a_1_Template_a_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onItemClick(ctx_r0.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_1_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_1_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r0.menuItem.selected);
    ɵɵproperty("routerLink", ctx_r0.menuItem.link)("queryParams", ctx_r0.menuItem.queryParams)("fragment", ctx_r0.menuItem.fragment)("queryParamsHandling", ctx_r0.menuItem.queryParamsHandling)("preserveFragment", ctx_r0.menuItem.preserveFragment)("skipLocationChange", ctx_r0.menuItem.skipLocationChange);
    ɵɵattribute("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("role", ctx_r0.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badge);
  }
}
function NbMenuItemComponent_a_2_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const badgeTemplate_r3 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 12);
    ɵɵlistener("mouseenter", function NbMenuItemComponent_a_2_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    })("click", function NbMenuItemComponent_a_2_Template_a_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onSelectItem(ctx_r0.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_2_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r0.menuItem.selected);
    ɵɵattribute("href", ctx_r0.menuItem.url, ɵɵsanitizeUrl)("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("role", ctx_r0.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badge);
  }
}
function NbMenuItemComponent_a_3_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const badgeTemplate_r3 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 12);
    ɵɵlistener("mouseenter", function NbMenuItemComponent_a_3_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    })("click", function NbMenuItemComponent_a_3_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext();
      $event.preventDefault();
      return ɵɵresetView(ctx_r0.onItemClick(ctx_r0.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_3_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_3_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r0.menuItem.selected);
    ɵɵattribute("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("role", ctx_r0.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badge);
  }
}
function NbMenuItemComponent_a_4_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_4_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const badgeTemplate_r3 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 13);
    ɵɵlistener("click", function NbMenuItemComponent_a_4_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r0 = ɵɵnextContext();
      $event.preventDefault();
      return ɵɵresetView(ctx_r0.onToggleSubMenu(ctx_r0.menuItem));
    })("mouseenter", function NbMenuItemComponent_a_4_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_4_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_4_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelement(5, "nb-icon", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    let tmp_5_0;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r0.menuItem.selected);
    ɵɵattribute("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("aria-expanded", (tmp_5_0 = ctx_r0.menuItem.expanded) !== null && tmp_5_0 !== void 0 ? tmp_5_0 : false)("role", ctx_r0.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badge);
    ɵɵadvance();
    ɵɵproperty("icon", ctx_r0.getExpandStateIcon());
  }
}
function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 18);
    ɵɵlistener("hoverItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.onHoverItem($event));
    })("toggleSubMenu", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.onToggleSubMenu($event));
    })("selectItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_selectItem_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.onSelectItem($event));
    })("itemClick", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_itemClick_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.onItemClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r8 = ɵɵnextContext().$implicit;
    ɵɵclassProp("menu-group", item_r8.group);
    ɵɵproperty("menuItem", item_r8)("badge", item_r8.badge);
  }
}
function NbMenuItemComponent_ul_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbMenuItemComponent_ul_5_ng_container_1_li_1_Template, 1, 4, "li", 17);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r8 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !item_r8.hidden);
  }
}
function NbMenuItemComponent_ul_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 15);
    ɵɵtemplate(1, NbMenuItemComponent_ul_5_ng_container_1_Template, 2, 1, "ng-container", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("collapsed", !(ctx_r0.menuItem.children && ctx_r0.menuItem.expanded))("expanded", ctx_r0.menuItem.expanded);
    ɵɵproperty("@toggle", ctx_r0.toggleState);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.menuItem.children);
  }
}
function NbMenuItemComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 19);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r0.badge.text)("dotMode", ctx_r0.badge.dotMode)("status", ctx_r0.badge.status);
  }
}
function NbMenuComponent_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 3);
    ɵɵlistener("hoverItem", function NbMenuComponent_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onHoverItem($event));
    })("toggleSubMenu", function NbMenuComponent_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onToggleSubMenu($event));
    })("selectItem", function NbMenuComponent_ng_container_1_li_1_Template_li_selectItem_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectItem($event));
    })("itemClick", function NbMenuComponent_ng_container_1_li_1_Template_li_itemClick_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onItemClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    ɵɵclassProp("menu-group", item_r3.group);
    ɵɵproperty("menuItem", item_r3)("badge", item_r3.badge);
  }
}
function NbMenuComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbMenuComponent_ng_container_1_li_1_Template, 1, 4, "li", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !item_r3.hidden);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("config", tab_r1.icon);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 4)(1, "a", 5);
    ɵɵtemplate(2, NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 6)(3, NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template, 2, 1, "span", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext().$implicit;
    ɵɵclassProp("responsive", tab_r1.responsive);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", tab_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("config", tab_r1.icon);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 10);
    ɵɵpipe(1, "nbMergeConfigs");
    ɵɵelementStart(2, "a", 11);
    ɵɵlistener("click", function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template_a_click_2_listener() {
      ɵɵrestoreView(_r2);
      const tab_r1 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.selectTab(tab_r1));
    });
    ɵɵtemplate(3, NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_3_Template, 1, 1, "nb-icon", 6)(4, NbRouteTabsetComponent_ng_container_1_ng_template_2_span_4_Template, 2, 1, "span", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("routerLinkActiveOptions", ɵɵpipeBind2(1, 13, ctx_r2.activeLinkOptions, tab_r1.activeLinkOptions));
    ɵɵadvance(2);
    ɵɵclassProp("responsive", tab_r1.responsive);
    ɵɵproperty("routerLink", tab_r1.route)("queryParams", tab_r1.queryParams)("queryParamsHandling", tab_r1.queryParamsHandling)("fragment", tab_r1.fragment)("preserveFragment", tab_r1.preserveFragment)("skipLocationChange", tab_r1.skipLocationChange)("replaceUrl", tab_r1.replaceUrl)("state", tab_r1.state);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbRouteTabsetComponent_ng_container_1_li_1_Template, 4, 4, "li", 3)(2, NbRouteTabsetComponent_ng_container_1_ng_template_2_Template, 5, 16, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    const enabled_r4 = ɵɵreference(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.disabled)("ngIfElse", enabled_r4);
  }
}
var _c18 = [[["nb-sidebar-header"]], "*", [["nb-sidebar-footer"]]];
var _c19 = ["nb-sidebar-header", "*", "nb-sidebar-footer"];
function NbTabComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.tabContentDirective.templateRef);
  }
}
function NbTabComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c20 = [[["nb-tab"]]];
var _c21 = ["nb-tab"];
function NbTabsetComponent_li_1_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("config", tab_r2.tabIcon);
  }
}
function NbTabsetComponent_li_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 9);
  }
  if (rf & 2) {
    const tab_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", tab_r2.tabTitleDirective.templateRef);
  }
}
function NbTabsetComponent_li_1_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(tab_r2.tabTitle);
  }
}
function NbTabsetComponent_li_1_nb_badge_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 11);
  }
  if (rf & 2) {
    const tab_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("text", tab_r2.badgeText)("dotMode", tab_r2.badgeDot)("status", tab_r2.badgeStatus)("position", tab_r2.badgePosition);
  }
}
function NbTabsetComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 3);
    ɵɵlistener("click", function NbTabsetComponent_li_1_Template_li_click_0_listener() {
      const tab_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.selectTab(tab_r2));
    })("keyup.space", function NbTabsetComponent_li_1_Template_li_keyup_space_0_listener() {
      const tab_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.selectTab(tab_r2));
    })("keyup.enter", function NbTabsetComponent_li_1_Template_li_keyup_enter_0_listener() {
      const tab_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.selectTab(tab_r2));
    });
    ɵɵelementStart(1, "a", 4);
    ɵɵlistener("click", function NbTabsetComponent_li_1_Template_a_click_1_listener($event) {
      ɵɵrestoreView(_r1);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵtemplate(2, NbTabsetComponent_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 5)(3, NbTabsetComponent_li_1_ng_container_3_Template, 1, 1, "ng-container", 6)(4, NbTabsetComponent_li_1_ng_template_4_Template, 2, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵtemplate(6, NbTabsetComponent_li_1_nb_badge_6_Template, 1, 4, "nb-badge", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r2 = ctx.$implicit;
    const textTitleTemplate_r4 = ɵɵreference(5);
    ɵɵclassProp("responsive", tab_r2.responsive)("active", tab_r2.active)("disabled", tab_r2.disabled);
    ɵɵattribute("tabindex", tab_r2.disabled ? -1 : 0)("data-tab-id", tab_r2.tabId);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", tab_r2.tabIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r2.tabTitleDirective)("ngIfElse", textTitleTemplate_r4);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", tab_r2.badgeText || tab_r2.badgeDot);
  }
}
function NbUserComponent_div_1_nb_badge_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("text", ctx_r0.badgeText)("status", ctx_r0.badgeStatus)("position", ctx_r0.badgePosition);
  }
}
function NbUserComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, NbUserComponent_div_1_nb_badge_1_Template, 1, 3, "nb-badge", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("background-image", ctx_r0.imageBackgroundStyle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badgeText);
  }
}
function NbUserComponent_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.getInitials(), " ");
  }
}
function NbUserComponent_div_2_nb_badge_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("text", ctx_r0.badgeText)("status", ctx_r0.badgeStatus)("position", ctx_r0.badgePosition);
  }
}
function NbUserComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵtemplate(1, NbUserComponent_div_2_ng_container_1_Template, 2, 1, "ng-container", 10)(2, NbUserComponent_div_2_nb_badge_2_Template, 1, 3, "nb-badge", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("background-color", ctx_r0.color);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showInitials);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badgeText);
  }
}
function NbUserComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.name);
  }
}
function NbUserComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function NbActionComponent_ng_container_0_a_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 6);
    ɵɵelement(1, "nb-icon", 7);
    ɵɵelementContainer(2, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    const badgeTemplate_r2 = ɵɵreference(4);
    ɵɵproperty("routerLink", ctx_r0.link)("title", ctx_r0.title);
    ɵɵadvance();
    ɵɵproperty("config", ctx_r0.icon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_container_0_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 9);
    ɵɵelement(1, "nb-icon", 7);
    ɵɵelementContainer(2, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    const badgeTemplate_r2 = ɵɵreference(4);
    ɵɵproperty("href", ctx_r0.href, ɵɵsanitizeUrl)("title", ctx_r0.title);
    ɵɵadvance();
    ɵɵproperty("config", ctx_r0.icon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_container_0_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 10);
    ɵɵlistener("click", function NbActionComponent_ng_container_0_a_3_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelement(1, "nb-icon", 7);
    ɵɵelementContainer(2, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    const badgeTemplate_r2 = ɵɵreference(4);
    ɵɵproperty("title", ctx_r0.title);
    ɵɵadvance();
    ɵɵproperty("config", ctx_r0.icon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbActionComponent_ng_container_0_a_1_Template, 3, 4, "a", 3)(2, NbActionComponent_ng_container_0_a_2_Template, 3, 4, "a", 4)(3, NbActionComponent_ng_container_0_a_3_Template, 3, 3, "a", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.link);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.href && !ctx_r0.link);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.href && !ctx_r0.link);
  }
}
function NbActionComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
    ɵɵelementContainer(1, 8);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const badgeTemplate_r2 = ɵɵreference(4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_template_3_nb_badge_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("text", ctx_r0.badgeText)("dotMode", ctx_r0.badgeDot)("status", ctx_r0.badgeStatus)("position", ctx_r0.badgePosition);
  }
}
function NbActionComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, NbActionComponent_ng_template_3_nb_badge_0_Template, 1, 4, "nb-badge", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r0.badgeText || ctx_r0.badgeDot);
  }
}
var _c22 = [[["nb-action"]]];
var _c23 = ["nb-action"];
var _c24 = ["searchInput"];
var _c25 = ["searchButton"];
function NbSearchComponent_nb_search_field_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-search-field", 4);
    ɵɵlistener("search", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_search_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.search($event));
    })("searchInput", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_searchInput_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.emitInput($event));
    })("close", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_close_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.emitDeactivate());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("show", ctx_r2.showSearchField)("type", ctx_r2.type)("placeholder", ctx_r2.placeholder)("hint", ctx_r2.hint);
  }
}
function NbCheckboxComponent_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 6);
  }
}
function NbCheckboxComponent_nb_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
}
function NbProgressBarComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.value, "%");
  }
}
function NbAlertComponent_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 1);
    ɵɵlistener("click", function NbAlertComponent_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClose());
    });
    ɵɵelementStart(1, "span", 2);
    ɵɵtext(2, "×");
    ɵɵelementEnd()();
  }
}
function NbChatFormComponent_div_0_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div")(1, "span", 9);
    ɵɵlistener("click", function NbChatFormComponent_div_0_ng_container_1_div_1_Template_span_click_1_listener() {
      ɵɵrestoreView(_r1);
      const file_r2 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.removeFile(file_r2));
    });
    ɵɵtext(2, "×");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const file_r2 = ɵɵnextContext().$implicit;
    ɵɵstyleProp("background-image", file_r2.urlStyle);
  }
}
function NbChatFormComponent_div_0_ng_container_1_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div");
    ɵɵelement(1, "nb-icon", 10);
    ɵɵelementStart(2, "span", 9);
    ɵɵlistener("click", function NbChatFormComponent_div_0_ng_container_1_div_2_Template_span_click_2_listener() {
      ɵɵrestoreView(_r4);
      const file_r2 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.removeFile(file_r2));
    });
    ɵɵtext(3, "×");
    ɵɵelementEnd()();
  }
}
function NbChatFormComponent_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbChatFormComponent_div_0_ng_container_1_div_1_Template, 3, 2, "div", 7)(2, NbChatFormComponent_div_0_ng_container_1_div_2_Template, 4, 0, "div", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const file_r2 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", file_r2.urlStyle);
    ɵɵadvance();
    ɵɵproperty("ngIf", !file_r2.urlStyle);
  }
}
function NbChatFormComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtemplate(1, NbChatFormComponent_div_0_ng_container_1_Template, 3, 2, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.droppedFiles);
  }
}
function NbChatFormComponent_button_3_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 13);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("icon", ctx_r2.buttonIcon);
  }
}
function NbChatFormComponent_button_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r2.buttonTitle);
  }
}
function NbChatFormComponent_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 11);
    ɵɵlistener("click", function NbChatFormComponent_button_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.sendMessage());
    });
    ɵɵtemplate(1, NbChatFormComponent_button_3_nb_icon_1_Template, 1, 1, "nb-icon", 12)(2, NbChatFormComponent_button_3_ng_template_2_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const title_r6 = ɵɵreference(3);
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("with-icon", !ctx_r2.buttonTitle);
    ɵɵproperty("status", ctx_r2.getButtonStatus());
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.buttonTitle)("ngIfElse", title_r6);
  }
}
function NbChatMessageTextComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 2);
    ɵɵtext(1);
    ɵɵelementStart(2, "time");
    ɵɵtext(3);
    ɵɵpipe(4, "date");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.sender, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind2(4, 2, ctx_r0.date, ctx_r0.dateFormat));
  }
}
function NbChatMessageTextComponent_p_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.message);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const file_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("icon", file_r1.icon);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const file_r1 = ɵɵnextContext().$implicit;
    ɵɵstyleProp("background-image", file_r1.urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 4);
    ɵɵtemplate(1, NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 5)(2, NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template, 1, 2, "div", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const file_r1 = ctx.$implicit;
    ɵɵproperty("href", file_r1.url, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngIf", !file_r1.urlStyle && file_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", file_r1.urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 2);
    ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_a_2_Template, 3, 3, "a", 3);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.readyFiles);
  }
}
function NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("icon", ctx_r1.readyFiles[0].icon);
  }
}
function NbChatMessageFileComponent_ng_container_3_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("background-image", ctx_r1.readyFiles[0].urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "a", 4);
    ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template, 1, 1, "nb-icon", 5)(3, NbChatMessageFileComponent_ng_container_3_div_3_Template, 1, 2, "div", 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("href", ctx_r1.readyFiles[0].url, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.readyFiles[0].urlStyle && ctx_r1.readyFiles[0].icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.readyFiles[0].urlStyle);
  }
}
function NbChatMessageQuoteComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 3);
    ɵɵtext(1);
    ɵɵelementStart(2, "time");
    ɵɵtext(3);
    ɵɵpipe(4, "date");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.sender, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind2(4, 2, ctx_r0.date, ctx_r0.dateFormat));
  }
}
var _c26 = (a0) => [a0];
function NbChatAvatarComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.initials, " ");
  }
}
function NbChatMessageComponent_nb_chat_avatar_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-avatar", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("initials", ctx_r0.getInitials())("avatarStyle", ctx_r0.avatarStyle);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_file_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-file", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message)("files", ctx_r0.files);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_quote_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-quote", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message)("quote", ctx_r0.quote);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_map_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-map", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r0.sender)("date", ctx_r0.date)("message", ctx_r0.message)("latitude", ctx_r0.latitude)("longitude", ctx_r0.longitude);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_text_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-text", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message);
  }
}
function NbChatMessageComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 5);
    ɵɵtemplate(1, NbChatMessageComponent_ng_container_2_nb_chat_message_file_1_Template, 1, 5, "nb-chat-message-file", 6)(2, NbChatMessageComponent_ng_container_2_nb_chat_message_quote_2_Template, 1, 5, "nb-chat-message-quote", 7)(3, NbChatMessageComponent_ng_container_2_nb_chat_message_map_3_Template, 1, 5, "nb-chat-message-map", 8)(4, NbChatMessageComponent_ng_container_2_nb_chat_message_text_4_Template, 1, 4, "nb-chat-message-text", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngSwitch", ctx_r0.type);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "file");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "quote");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "map");
  }
}
function NbChatMessageComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-text", 13);
    ɵɵelementStart(1, "div");
    ɵɵelementContainer(2, 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message);
    ɵɵadvance();
    ɵɵclassProp("nb-custom-message", ctx_r0._areDefaultStylesEnabled())("nb-custom-message-no-space", ctx_r0._addNoSpaceClass)("nb-custom-message-reply", ctx_r0._addReplyClass)("nb-custom-message-not-reply", ctx_r0._addNotReplyClass)("nb-custom-message-full-width", !ctx_r0._areDefaultStylesEnabled());
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0._getTemplate())("ngTemplateOutletContext", ctx_r0._getTemplateContext());
  }
}
var _c27 = ["scrollable"];
var _c28 = [[["nb-chat-message"]], [["nb-chat-form"]]];
var _c29 = ["nb-chat-message", "nb-chat-form"];
var _c30 = (a0) => ({
  $implicit: a0
});
function NbChatComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.titleTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c30, ctx_r0.titleTemplate.context));
  }
}
function NbChatComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.title, " ");
  }
}
function NbChatComponent_p_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.noMessagesPlaceholder);
  }
}
function NbSpinnerComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.message);
  }
}
function NbStepComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c31 = [[["nb-step"]]];
var _c32 = ["nb-step"];
function NbStepperComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function NbStepperComponent_ng_container_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 6);
  }
  if (rf & 2) {
    const index_r1 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("connector-past", index_r1 <= ctx_r1.selectedIndex);
  }
}
function NbStepperComponent_ng_container_2_div_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const index_r1 = ɵɵnextContext(2).index;
    ɵɵadvance();
    ɵɵtextInterpolate(index_r1 + 1);
  }
}
function NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 12);
  }
}
function NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function NbStepperComponent_ng_container_2_div_2_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const step_r4 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.getStepTemplate(step_r4));
  }
}
function NbStepperComponent_ng_container_2_div_2_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r4 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(step_r4.label);
  }
}
function NbStepperComponent_ng_container_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7);
    ɵɵlistener("click", function NbStepperComponent_ng_container_2_div_2_Template_div_click_0_listener() {
      ɵɵrestoreView(_r3);
      const step_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changeStep(step_r4));
    });
    ɵɵelementStart(1, "div", 8);
    ɵɵtemplate(2, NbStepperComponent_ng_container_2_div_2_span_2_Template, 2, 1, "span", 9)(3, NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template, 1, 0, "nb-icon", 10);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 11);
    ɵɵtemplate(5, NbStepperComponent_ng_container_2_div_2_ng_container_5_Template, 2, 1, "ng-container", 9)(6, NbStepperComponent_ng_container_2_div_2_span_6_Template, 2, 1, "span", 9);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const step_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("selected", ctx_r1.isStepSelected(step_r4))("completed", !ctx_r1.isStepSelected(step_r4) && step_r4.completed)("noninteractive", ctx_r1.disableStepNavigation);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !step_r4.completed || ctx_r1.isStepSelected(step_r4));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isStepSelected(step_r4) && step_r4.completed);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", step_r4.isLabelTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !step_r4.isLabelTemplate);
  }
}
function NbStepperComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbStepperComponent_ng_container_2_div_1_Template, 1, 2, "div", 4)(2, NbStepperComponent_ng_container_2_div_2_Template, 7, 10, "div", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const step_r4 = ctx.$implicit;
    const first_r5 = ctx.first;
    ɵɵadvance();
    ɵɵproperty("ngIf", !first_r5 && !step_r4.hidden);
    ɵɵadvance();
    ɵɵproperty("ngIf", !step_r4.hidden);
  }
}
var _c33 = [[["nb-accordion-item"]]];
var _c34 = ["nb-accordion-item"];
var _c35 = [[["nb-accordion-item-header"]], [["nb-accordion-item-body"]]];
var _c36 = ["nb-accordion-item-header", "nb-accordion-item-body"];
var _c37 = (a0) => ({
  value: a0
});
var _c38 = [[["nb-accordion-item-title"]], [["nb-accordion-item-description"]], "*"];
var _c39 = ["nb-accordion-item-title", "nb-accordion-item-description", "*"];
function NbAccordionItemHeaderComponent_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("@expansionIndicator", ctx_r0.state);
  }
}
function NbDialogContainerComponent_ng_template_0_Template(rf, ctx) {
}
function NbToastComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵelement(1, "nb-icon", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("config", ctx_r0.icon);
  }
}
function NbToastrContainerComponent_nb_toast_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-toast", 1);
  }
  if (rf & 2) {
    const toast_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("@fadeIn", ctx_r1.fadeIn)("toast", toast_r1);
  }
}
function NbTooltipComponent_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("config", ctx_r0.context.icon);
  }
}
function NbTooltipComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.content);
  }
}
function NbOptionComponent_nb_checkbox_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-checkbox", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("checked", ctx_r0.selected)("disabled", ctx_r0.disabled);
  }
}
var _c40 = ["selectButton"];
var _c41 = [[["nb-select-label"]], [["nb-option"], ["nb-option-group"]]];
var _c42 = ["nb-select-label", "nb-option, nb-option-group"];
function NbSelectComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementContainerEnd();
  }
}
function NbSelectComponent_ng_container_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r1.selectionView);
  }
}
function NbSelectComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbSelectComponent_ng_container_3_ng_container_1_Template, 2, 0, "ng-container", 5)(2, NbSelectComponent_ng_container_3_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const defaultSelectionTemplate_r3 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.customLabel)("ngIfElse", defaultSelectionTemplate_r3);
  }
}
function NbSelectComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r1.placeholder);
  }
}
function NbSelectComponent_nb_option_list_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-option-list", 8);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r1.optionsWidth, "px");
    ɵɵproperty("size", ctx_r1.size)("position", ctx_r1.overlayPosition)("ngClass", ctx_r1.optionsListClass);
  }
}
var _c43 = [[["nb-option"], ["ng-container"]]];
var _c44 = ["nb-option, ng-container"];
var _c45 = ["*", [["", "nbPrefix", ""]], [["", "nbSuffix", ""]]];
var _c46 = ["*", "[nbPrefix]", "[nbSuffix]"];
function NbFormFieldComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵpipe(1, "async");
    ɵɵprojection(2, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpipeBind1(1, 1, ctx_r0.prefixClasses$));
  }
}
function NbFormFieldComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵpipe(1, "async");
    ɵɵprojection(2, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpipeBind1(1, 1, ctx_r0.suffixClasses$));
  }
}
var _c47 = ["optionsAutocompleteInput"];
function NbSelectWithAutocompleteComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementContainerEnd();
  }
}
function NbSelectWithAutocompleteComponent_ng_container_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r1.selectionView);
  }
}
function NbSelectWithAutocompleteComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbSelectWithAutocompleteComponent_ng_container_3_ng_container_1_Template, 2, 0, "ng-container", 6)(2, NbSelectWithAutocompleteComponent_ng_container_3_ng_template_2_Template, 1, 1, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const defaultSelectionTemplate_r3 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.customLabel)("ngIfElse", defaultSelectionTemplate_r3);
  }
}
function NbSelectWithAutocompleteComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r1.placeholder);
  }
}
function NbSelectWithAutocompleteComponent_nb_option_list_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-option-list", 12);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r1.optionsWidth, "px");
    ɵɵproperty("size", ctx_r1.size)("position", ctx_r1.overlayPosition)("ngClass", ctx_r1.optionsListClass);
  }
}
var _c48 = [[["nb-option"], ["nb-option-group"]]];
var _c49 = ["nb-option, nb-option-group"];
function NbAutocompleteComponent_nb_option_list_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-option-list", 1);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r0.optionsWidth, "px");
    ɵɵclassProp("empty", !(ctx_r0.options == null ? null : ctx_r0.options.length));
    ɵɵproperty("size", ctx_r0.size)("position", ctx_r0.overlayPosition)("id", ctx_r0.id)("ngClass", ctx_r0.optionsListClass);
  }
}
var _c50 = ["viewContainerRef"];
function NbWindowComponent_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function NbWindowComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtemplate(1, NbWindowComponent_div_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.config.titleTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c30, ctx_r0.config.titleTemplateContext));
  }
}
function NbWindowComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.config.title);
  }
}
function NbWindowComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_6_Template_button_click_1_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.minimize());
    });
    ɵɵelement(2, "nb-icon", 8);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function NbWindowComponent_ng_container_7_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_7_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.maximize());
    });
    ɵɵelement(1, "nb-icon", 10);
    ɵɵelementEnd();
  }
}
function NbWindowComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbWindowComponent_ng_container_7_button_1_Template, 2, 0, "button", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isFullScreen);
  }
}
function NbWindowComponent_ng_container_8_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_8_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.maximizeOrFullScreen());
    });
    ɵɵelement(1, "nb-icon", 11);
    ɵɵelementEnd();
  }
}
function NbWindowComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbWindowComponent_ng_container_8_button_1_Template, 2, 0, "button", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.minimized || ctx_r0.maximized);
  }
}
function NbWindowComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_9_Template_button_click_1_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.close());
    });
    ɵɵelement(2, "nb-icon", 12);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function NbWindowComponent_nb_card_body_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-card-body");
    ɵɵelement(1, "nb-overlay-container");
    ɵɵelementEnd();
  }
}
var _c51 = ["input"];
var _c52 = [[["nb-radio"]]];
var _c53 = ["nb-radio"];
function NbTagComponent_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-icon", 1);
    ɵɵlistener("click", function NbTagComponent_nb_icon_1_Template_nb_icon_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._remove());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMapInterpolate1("nb-tag-remove size-", ctx_r1.size, "");
  }
}
var _c54 = [[["nb-tag"], ["input", "nbTagInput", ""]]];
var _c55 = ["nb-tag, input[nbTagInput]"];
function NbSortIconComponent_ng_container_0_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 3);
  }
}
function NbSortIconComponent_ng_container_0_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 4);
  }
}
function NbSortIconComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbSortIconComponent_ng_container_0_nb_icon_1_Template, 1, 0, "nb-icon", 1)(2, NbSortIconComponent_ng_container_0_nb_icon_2_Template, 1, 0, "nb-icon", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isAscending());
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isDescending());
  }
}
var _c56 = ["nbSortHeader", ""];
function NbSortHeaderComponent_nb_sort_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-sort-icon", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("direction", ctx_r1.direction);
  }
}
function NbSortHeaderComponent_ng_template_3_Template(rf, ctx) {
}
var _c57 = ["nbTreeGrid", ""];
var _c58 = ["nbTreeGridRow", ""];
var _c59 = ["nbTreeGridHeaderRow", ""];
var _c60 = ["nbTreeGridFooterRow", ""];
function NbToggleComponent_nb_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 6);
  }
}
var NB_THEME_OPTIONS = new InjectionToken("Nebular Theme Options");
var NB_MEDIA_BREAKPOINTS = new InjectionToken("Nebular Media Breakpoints");
var NB_BUILT_IN_JS_THEMES = new InjectionToken("Nebular Built-in JS Themes");
var NB_JS_THEMES = new InjectionToken("Nebular JS Themes");
var NB_WINDOW = new InjectionToken("Window");
var NB_DOCUMENT = new InjectionToken("Document");
var DEFAULT_MEDIA_BREAKPOINTS = [{
  name: "xs",
  width: 0
}, {
  name: "is",
  width: 400
}, {
  name: "sm",
  width: 576
}, {
  name: "md",
  width: 768
}, {
  name: "lg",
  width: 992
}, {
  name: "xl",
  width: 1200
}, {
  name: "xxl",
  width: 1400
}, {
  name: "xxxl",
  width: 1600
}];
var _NbMediaBreakpointsService = class _NbMediaBreakpointsService {
  constructor(breakpoints) {
    this.breakpoints = breakpoints;
    this.breakpointsMap = this.breakpoints.reduce((res, b) => {
      res[b.name] = b.width;
      return res;
    }, {});
  }
  /**
   * Returns a configured breakpoint by width
   * @param width number
   * @returns {Z|{name: string, width: number}}
   */
  getByWidth(width) {
    const unknown = {
      name: "unknown",
      width
    };
    const breakpoints = this.getBreakpoints();
    return breakpoints.find((point, index) => {
      const next = breakpoints[index + 1];
      return width >= point.width && (!next || width < next.width);
    }) || unknown;
  }
  /**
   * Returns a configured breakpoint by name
   * @param name string
   * @returns NbMediaBreakpoint
   */
  getByName(name) {
    const unknown = {
      name: "unknown",
      width: NaN
    };
    const breakpoints = this.getBreakpoints();
    return breakpoints.find((point) => name === point.name) || unknown;
  }
  /**
   * Returns a list of configured breakpoints for the theme
   * @returns NbMediaBreakpoint[]
   */
  getBreakpoints() {
    return this.breakpoints;
  }
  /**
   * Returns a map of configured breakpoints for the theme
   * @returns {[p: string]: number}
   */
  getBreakpointsMap() {
    return this.breakpointsMap;
  }
};
_NbMediaBreakpointsService.ɵfac = function NbMediaBreakpointsService_Factory(t) {
  return new (t || _NbMediaBreakpointsService)(ɵɵinject(NB_MEDIA_BREAKPOINTS));
};
_NbMediaBreakpointsService.ɵprov = ɵɵdefineInjectable({
  token: _NbMediaBreakpointsService,
  factory: _NbMediaBreakpointsService.ɵfac
});
var NbMediaBreakpointsService = _NbMediaBreakpointsService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMediaBreakpointsService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_MEDIA_BREAKPOINTS]
    }]
  }], null);
})();
var palette$3 = {
  primary: "#3366ff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var DEFAULT_THEME = {
  name: "default",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#ffffff",
    bg2: "#f7f9fc",
    bg3: "#edf1f7",
    bg4: "#e4e9f2",
    border: "#ffffff",
    border2: "#f7f9fc",
    border3: "#edf1f7",
    border4: "#e4e9f2",
    border5: "#c5cee0",
    fg: "#8f9bb3",
    fgHeading: "#1a2138",
    fgText: "#1a2138",
    fgHighlight: palette$3.primary,
    layoutBg: "#f7f9fc",
    separator: "#edf1f7",
    primary: palette$3.primary,
    success: palette$3.success,
    info: palette$3.info,
    warning: palette$3.warning,
    danger: palette$3.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette$2 = {
  primary: "#a16eff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var COSMIC_THEME = {
  name: "cosmic",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#323259",
    bg2: "#252547",
    bg3: "#1b1b38",
    bg4: "#13132b",
    border: "#323259",
    border2: "#252547",
    border3: "#1b1b38",
    border4: "#13132b",
    border5: "#13132b",
    fg: "#b4b4db",
    fgHeading: "#ffffff",
    fgText: "#ffffff",
    fgHighlight: palette$2.primary,
    layoutBg: "#151a30",
    separator: "#151a30",
    primary: palette$2.primary,
    success: palette$2.success,
    info: palette$2.info,
    warning: palette$2.warning,
    danger: palette$2.danger,
    primaryLight: "#b18aff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette$1 = {
  primary: "#73a1ff",
  success: "#5dcfe3",
  info: "#ba7fec",
  warning: "#ffa36b",
  danger: "#ff6b83"
};
var CORPORATE_THEME = {
  name: "corporate",
  base: "default",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#ffffff",
    bg2: "#f7f9fc",
    bg3: "#edf1f7",
    bg4: "#e4e9f2",
    border: "#ffffff",
    border2: "#f7f9fc",
    border3: "#edf1f7",
    border4: "#e4e9f2",
    border5: "#c5cee0",
    fg: "#8f9bb3",
    fgHeading: "#1a2138",
    fgText: "#1a2138",
    fgHighlight: palette$1.primary,
    layoutBg: "#f7f9fc",
    separator: "#edf1f7",
    primary: palette$1.primary,
    success: palette$1.success,
    info: palette$1.info,
    warning: palette$1.warning,
    danger: palette$1.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette = {
  primary: "#3366ff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var DARK_THEME = {
  name: "dark",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#222b45",
    bg2: "#1a2138",
    bg3: "#151a30",
    bg4: "#101426",
    border: "#222b45",
    border2: "#1a2138",
    border3: "#151a30",
    border4: "#101426",
    border5: "#101426",
    fg: "#8f9bb3",
    fgHeading: "#ffffff",
    fgText: "#ffffff",
    fgHighlight: palette.primary,
    layoutBg: "#1b1b38",
    separator: "#1b1b38",
    primary: palette.primary,
    success: palette.success,
    info: palette.info,
    warning: palette.warning,
    danger: palette.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var BUILT_IN_THEMES = [DEFAULT_THEME, COSMIC_THEME, CORPORATE_THEME, DARK_THEME];
var _NbJSThemesRegistry = class _NbJSThemesRegistry {
  constructor(builtInThemes, newThemes = []) {
    this.themes = {};
    const themes = this.combineByNames(newThemes, builtInThemes);
    themes.forEach((theme) => {
      this.register(theme, theme.name, theme.base);
    });
  }
  /**
   * Registers a new JS theme
   * @param config any
   * @param themeName string
   * @param baseTheme string
   */
  register(config, themeName, baseTheme) {
    const base = this.has(baseTheme) ? this.get(baseTheme) : {};
    this.themes[themeName] = this.mergeDeep({}, base, config);
  }
  /**
   * Checks whether the theme is registered
   * @param themeName
   * @returns boolean
   */
  has(themeName) {
    return !!this.themes[themeName];
  }
  /**
   * Return a theme
   * @param themeName
   * @returns NbJSThemeOptions
   */
  get(themeName) {
    if (!this.themes[themeName]) {
      throw Error(`NbThemeConfig: no theme '${themeName}' found registered.`);
    }
    return JSON.parse(JSON.stringify(this.themes[themeName]));
  }
  combineByNames(newThemes, oldThemes) {
    if (newThemes) {
      const mergedThemes = [];
      newThemes.forEach((theme) => {
        const sameOld = oldThemes.find((tm) => tm.name === theme.name) || {};
        const mergedTheme = this.mergeDeep({}, sameOld, theme);
        mergedThemes.push(mergedTheme);
      });
      oldThemes.forEach((theme) => {
        if (!mergedThemes.find((tm) => tm.name === theme.name)) {
          mergedThemes.push(theme);
        }
      });
      return mergedThemes;
    }
    return oldThemes;
  }
  isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
  // TODO: move to helpers
  mergeDeep(target, ...sources) {
    if (!sources.length) {
      return target;
    }
    const source = sources.shift();
    if (this.isObject(target) && this.isObject(source)) {
      for (const key in source) {
        if (this.isObject(source[key])) {
          if (!target[key]) {
            Object.assign(target, {
              [key]: {}
            });
          }
          this.mergeDeep(target[key], source[key]);
        } else {
          Object.assign(target, {
            [key]: source[key]
          });
        }
      }
    }
    return this.mergeDeep(target, ...sources);
  }
};
_NbJSThemesRegistry.ɵfac = function NbJSThemesRegistry_Factory(t) {
  return new (t || _NbJSThemesRegistry)(ɵɵinject(NB_BUILT_IN_JS_THEMES), ɵɵinject(NB_JS_THEMES));
};
_NbJSThemesRegistry.ɵprov = ɵɵdefineInjectable({
  token: _NbJSThemesRegistry,
  factory: _NbJSThemesRegistry.ɵfac
});
var NbJSThemesRegistry = _NbJSThemesRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbJSThemesRegistry, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_BUILT_IN_JS_THEMES]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_JS_THEMES]
    }]
  }], null);
})();
var _NbThemeService = class _NbThemeService {
  constructor(options, breakpointService, jsThemesRegistry) {
    this.options = options;
    this.breakpointService = breakpointService;
    this.jsThemesRegistry = jsThemesRegistry;
    this.themeChanges$ = new ReplaySubject(1);
    this.appendLayoutClass$ = new Subject();
    this.removeLayoutClass$ = new Subject();
    this.changeWindowWidth$ = new ReplaySubject(2);
    if (options && options.name) {
      this.changeTheme(options.name);
    }
  }
  /**
   * Change current application theme
   * @param {string} name
   */
  changeTheme(name) {
    this.themeChanges$.next({
      name,
      previous: this.currentTheme
    });
    this.currentTheme = name;
  }
  changeWindowWidth(width) {
    this.changeWindowWidth$.next(width);
  }
  /**
   * Returns a theme object with variables (color/paddings/etc) on a theme change.
   * Once subscribed - returns current theme.
   *
   * @returns {Observable<NbJSThemeOptions>}
   */
  getJsTheme() {
    return this.onThemeChange().pipe(map((theme) => {
      return this.jsThemesRegistry.get(theme.name);
    }));
  }
  /**
   * Triggers media query breakpoint change
   * Returns a pair where the first item is previous media breakpoint and the second item is current breakpoit.
   * ```ts
   *  [{ name: 'xs', width: 0 }, { name: 'md', width: 768 }] // change from `xs` to `md`
   * ```
   * @returns {Observable<[NbMediaBreakpoint, NbMediaBreakpoint]>}
   */
  onMediaQueryChange() {
    return this.changeWindowWidth$.pipe(startWith(void 0), pairwise(), map(([prevWidth, width]) => {
      return [this.breakpointService.getByWidth(prevWidth), this.breakpointService.getByWidth(width)];
    }), filter(([prevPoint, point]) => {
      return prevPoint.name !== point.name;
    }), distinctUntilChanged(null, (params) => params[0].name + params[1].name), share());
  }
  /**
   * Triggered when current theme is changed
   * @returns {Observable<any>}
   */
  onThemeChange() {
    return this.themeChanges$.pipe(share());
  }
  /**
   * Append a class to nb-layout
   * @param {string} className
   */
  appendLayoutClass(className) {
    this.appendLayoutClass$.next(className);
  }
  /**
   * Triggered when a new class is added to nb-layout through `appendLayoutClass` method
   * @returns {Observable<any>}
   */
  onAppendLayoutClass() {
    return this.appendLayoutClass$.pipe(share());
  }
  /**
   * Removes a class from nb-layout
   * @param {string} className
   */
  removeLayoutClass(className) {
    this.removeLayoutClass$.next(className);
  }
  /**
   * Triggered when a class is removed from nb-layout through `removeLayoutClass` method
   * @returns {Observable<any>}
   */
  onRemoveLayoutClass() {
    return this.removeLayoutClass$.pipe(share());
  }
};
_NbThemeService.ɵfac = function NbThemeService_Factory(t) {
  return new (t || _NbThemeService)(ɵɵinject(NB_THEME_OPTIONS), ɵɵinject(NbMediaBreakpointsService), ɵɵinject(NbJSThemesRegistry));
};
_NbThemeService.ɵprov = ɵɵdefineInjectable({
  token: _NbThemeService,
  factory: _NbThemeService.ɵfac
});
var NbThemeService = _NbThemeService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbThemeService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_THEME_OPTIONS]
    }]
  }, {
    type: NbMediaBreakpointsService
  }, {
    type: NbJSThemesRegistry
  }], null);
})();
var _NbSpinnerService = class _NbSpinnerService {
  constructor(document2) {
    this.document = document2;
    this.loaders = [];
    this.selector = "nb-global-spinner";
  }
  /**
   * Appends new loader to the list of loader to be completed before
   * spinner will be hidden
   * @param method Promise<any>
   */
  registerLoader(method) {
    this.loaders.push(method);
  }
  /**
   * Clears the list of loader
   */
  clear() {
    this.loaders = [];
  }
  /**
   * Start the loader process, show spinnder and execute loaders
   */
  load() {
    this.showSpinner();
    this.executeAll();
  }
  executeAll(done = (values) => {
  }) {
    Promise.all(this.loaders).then((values) => {
      this.hideSpinner();
      done.call(null, values);
    }).catch((error) => {
      console.error(error);
    });
  }
  // TODO is there any better way of doing this?
  showSpinner() {
    const el = this.getSpinnerElement();
    if (el) {
      el.style["display"] = "block";
    }
  }
  hideSpinner() {
    const el = this.getSpinnerElement();
    if (el) {
      el.style["display"] = "none";
    }
  }
  getSpinnerElement() {
    return this.document.getElementById(this.selector);
  }
};
_NbSpinnerService.ɵfac = function NbSpinnerService_Factory(t) {
  return new (t || _NbSpinnerService)(ɵɵinject(NB_DOCUMENT));
};
_NbSpinnerService.ɵprov = ɵɵdefineInjectable({
  token: _NbSpinnerService,
  factory: _NbSpinnerService.ɵfac
});
var NbSpinnerService = _NbSpinnerService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbLayoutDirection;
(function(NbLayoutDirection2) {
  NbLayoutDirection2["LTR"] = "ltr";
  NbLayoutDirection2["RTL"] = "rtl";
})(NbLayoutDirection || (NbLayoutDirection = {}));
var NB_LAYOUT_DIRECTION = new InjectionToken("Layout direction");
var _NbLayoutDirectionService = class _NbLayoutDirectionService {
  constructor(direction = NbLayoutDirection.LTR) {
    this.direction = direction;
    this.$directionChange = new ReplaySubject(1);
    this.setDirection(direction);
  }
  /**
   * Returns true if layout direction set to left to right.
   * @returns boolean.
   * */
  isLtr() {
    return this.direction === NbLayoutDirection.LTR;
  }
  /**
   * Returns true if layout direction set to right to left.
   * @returns boolean.
   * */
  isRtl() {
    return this.direction === NbLayoutDirection.RTL;
  }
  /**
   * Returns current layout direction.
   * @returns NbLayoutDirection.
   * */
  getDirection() {
    return this.direction;
  }
  /**
   * Sets layout direction
   * @param {NbLayoutDirection} direction
   */
  setDirection(direction) {
    this.direction = direction;
    this.$directionChange.next(direction);
  }
  /**
   * Triggered when direction was changed.
   * @returns Observable<NbLayoutDirection>.
   */
  onDirectionChange() {
    return this.$directionChange.pipe(share());
  }
};
_NbLayoutDirectionService.ɵfac = function NbLayoutDirectionService_Factory(t) {
  return new (t || _NbLayoutDirectionService)(ɵɵinject(NB_LAYOUT_DIRECTION, 8));
};
_NbLayoutDirectionService.ɵprov = ɵɵdefineInjectable({
  token: _NbLayoutDirectionService,
  factory: _NbLayoutDirectionService.ɵfac
});
var NbLayoutDirectionService = _NbLayoutDirectionService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutDirectionService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_LAYOUT_DIRECTION]
    }]
  }], null);
})();
var _NbLayoutScrollService = class _NbLayoutScrollService {
  constructor() {
    this.scrollPositionReq$ = new Subject();
    this.manualScroll$ = new Subject();
    this.scroll$ = new Subject();
    this.scrollable$ = new Subject();
  }
  /**
   * Returns scroll position
   *
   * @returns {Observable<NbScrollPosition>}
   */
  getPosition() {
    return new Observable((observer) => {
      const listener = new Subject();
      listener.subscribe(observer);
      this.scrollPositionReq$.next({
        listener
      });
      return () => listener.complete();
    });
  }
  /**
   * Sets scroll position
   *
   * @param {number} x
   * @param {number} y
   */
  scrollTo(x = null, y = null) {
    this.manualScroll$.next({
      x,
      y
    });
  }
  /**
   * Returns a stream of scroll events
   *
   * @returns {Observable<any>}
   */
  onScroll() {
    return this.scroll$.pipe(share());
  }
  /**
   * @private
   * @returns Observable<NbScrollPosition>.
   */
  onManualScroll() {
    return this.manualScroll$.pipe(share());
  }
  /**
   * @private
   * @returns {Subject<any>}
   */
  onGetPosition() {
    return this.scrollPositionReq$;
  }
  onScrollableChange() {
    return this.scrollable$.pipe(share());
  }
  /**
   * @private
   * @param {any} event
   */
  fireScrollChange(event) {
    this.scroll$.next(event);
  }
  scrollable(scrollable) {
    this.scrollable$.next(scrollable);
  }
};
_NbLayoutScrollService.ɵfac = function NbLayoutScrollService_Factory(t) {
  return new (t || _NbLayoutScrollService)();
};
_NbLayoutScrollService.ɵprov = ɵɵdefineInjectable({
  token: _NbLayoutScrollService,
  factory: _NbLayoutScrollService.ɵfac
});
var NbLayoutScrollService = _NbLayoutScrollService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutScrollService, [{
    type: Injectable
  }], null, null);
})();
var _NbLayoutRulerService = class _NbLayoutRulerService {
  constructor() {
    this.contentDimensionsReq$ = new Subject();
  }
  /**
   * Content dimensions
   * @returns {Observable<NbLayoutDimensions>}
   */
  getDimensions() {
    return new Observable((observer) => {
      const listener = new Subject();
      listener.subscribe(observer);
      this.contentDimensionsReq$.next({
        listener
      });
      return () => listener.complete();
    });
  }
  /**
   * @private
   * @returns {Subject<any>}
   */
  onGetDimensions() {
    return this.contentDimensionsReq$;
  }
};
_NbLayoutRulerService.ɵfac = function NbLayoutRulerService_Factory(t) {
  return new (t || _NbLayoutRulerService)();
};
_NbLayoutRulerService.ɵprov = ɵɵdefineInjectable({
  token: _NbLayoutRulerService,
  factory: _NbLayoutRulerService.ɵfac
});
var NbLayoutRulerService = _NbLayoutRulerService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutRulerService, [{
    type: Injectable
  }], null, null);
})();
var _NbSharedModule = class _NbSharedModule {
};
_NbSharedModule.ɵfac = function NbSharedModule_Factory(t) {
  return new (t || _NbSharedModule)();
};
_NbSharedModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSharedModule,
  exports: [
    CommonModule,
    // TODO: probably we don't need FormsModule in SharedModule
    FormsModule,
    RouterModule
  ]
});
_NbSharedModule.ɵinj = ɵɵdefineInjector({
  imports: [
    CommonModule,
    // TODO: probably we don't need FormsModule in SharedModule
    FormsModule,
    RouterModule
  ]
});
var NbSharedModule = _NbSharedModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSharedModule, [{
    type: NgModule,
    args: [{
      exports: [
        CommonModule,
        // TODO: probably we don't need FormsModule in SharedModule
        FormsModule,
        RouterModule
      ]
    }]
  }], null, null);
})();
var NbFocusTrap = class extends FocusTrap {
  constructor(element, checker, ngZone, document2, deferAnchors) {
    super(element, checker, ngZone, document2, deferAnchors);
    this.element = element;
    this.checker = checker;
    this.ngZone = ngZone;
    this.document = document2;
    this.savePreviouslyFocusedElement();
  }
  restoreFocus() {
    this.previouslyFocusedElement.focus();
    this.destroy();
  }
  blurPreviouslyFocusedElement() {
    this.previouslyFocusedElement.blur();
  }
  savePreviouslyFocusedElement() {
    this.previouslyFocusedElement = this.document.activeElement;
  }
};
var _NbFocusTrapFactoryService = class _NbFocusTrapFactoryService extends FocusTrapFactory {
  constructor(checker, ngZone, document2) {
    super(checker, ngZone, document2);
    this.checker = checker;
    this.ngZone = ngZone;
    this.document = document2;
  }
  create(element, deferCaptureElements) {
    return new NbFocusTrap(element, this.checker, this.ngZone, this.document, deferCaptureElements);
  }
};
_NbFocusTrapFactoryService.ɵfac = function NbFocusTrapFactoryService_Factory(t) {
  return new (t || _NbFocusTrapFactoryService)(ɵɵinject(InteractivityChecker), ɵɵinject(NgZone), ɵɵinject(NB_DOCUMENT));
};
_NbFocusTrapFactoryService.ɵprov = ɵɵdefineInjectable({
  token: _NbFocusTrapFactoryService,
  factory: _NbFocusTrapFactoryService.ɵfac
});
var NbFocusTrapFactoryService = _NbFocusTrapFactoryService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFocusTrapFactoryService, [{
    type: Injectable
  }], () => [{
    type: InteractivityChecker
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbFocusKeyManager = class extends FocusKeyManager {
};
var NbFocusKeyManagerFactoryService = class {
  create(items) {
    return new NbFocusKeyManager(items);
  }
};
var NbActiveDescendantKeyManager = class extends ActiveDescendantKeyManager {
};
var NbActiveDescendantKeyManagerFactoryService = class {
  create(items) {
    return new NbActiveDescendantKeyManager(items);
  }
};
var NbKeyManagerActiveItemMode;
(function(NbKeyManagerActiveItemMode2) {
  NbKeyManagerActiveItemMode2[NbKeyManagerActiveItemMode2["RESET_ACTIVE"] = -1] = "RESET_ACTIVE";
  NbKeyManagerActiveItemMode2[NbKeyManagerActiveItemMode2["FIRST_ACTIVE"] = 0] = "FIRST_ACTIVE";
})(NbKeyManagerActiveItemMode || (NbKeyManagerActiveItemMode = {}));
var _NbFocusMonitor = class _NbFocusMonitor extends FocusMonitor {
};
_NbFocusMonitor.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFocusMonitor_BaseFactory;
  return function NbFocusMonitor_Factory(t) {
    return (ɵNbFocusMonitor_BaseFactory || (ɵNbFocusMonitor_BaseFactory = ɵɵgetInheritedFactory(_NbFocusMonitor)))(t || _NbFocusMonitor);
  };
})();
_NbFocusMonitor.ɵprov = ɵɵdefineInjectable({
  token: _NbFocusMonitor,
  factory: _NbFocusMonitor.ɵfac
});
var NbFocusMonitor = _NbFocusMonitor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFocusMonitor, [{
    type: Injectable
  }], null, null);
})();
var _NbA11yModule = class _NbA11yModule {
  static forRoot() {
    return {
      ngModule: _NbA11yModule,
      providers: [NbFocusTrapFactoryService, NbFocusKeyManagerFactoryService, NbActiveDescendantKeyManagerFactoryService, {
        provide: NbFocusMonitor,
        useClass: FocusMonitor
      }]
    };
  }
};
_NbA11yModule.ɵfac = function NbA11yModule_Factory(t) {
  return new (t || _NbA11yModule)();
};
_NbA11yModule.ɵmod = ɵɵdefineNgModule({
  type: _NbA11yModule
});
_NbA11yModule.ɵinj = ɵɵdefineInjector({});
var NbA11yModule = _NbA11yModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbA11yModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var _NbPortalDirective = class _NbPortalDirective extends CdkPortal {
};
_NbPortalDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbPortalDirective_BaseFactory;
  return function NbPortalDirective_Factory(t) {
    return (ɵNbPortalDirective_BaseFactory || (ɵNbPortalDirective_BaseFactory = ɵɵgetInheritedFactory(_NbPortalDirective)))(t || _NbPortalDirective);
  };
})();
_NbPortalDirective.ɵdir = ɵɵdefineDirective({
  type: _NbPortalDirective,
  selectors: [["", "nbPortal", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
var NbPortalDirective = _NbPortalDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPortalDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPortal]"
    }]
  }], null, null);
})();
var _NbPortalOutletDirective = class _NbPortalOutletDirective extends CdkPortalOutlet {
};
_NbPortalOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbPortalOutletDirective_BaseFactory;
  return function NbPortalOutletDirective_Factory(t) {
    return (ɵNbPortalOutletDirective_BaseFactory || (ɵNbPortalOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbPortalOutletDirective)))(t || _NbPortalOutletDirective);
  };
})();
_NbPortalOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbPortalOutletDirective,
  selectors: [["", "nbPortalOutlet", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
var NbPortalOutletDirective = _NbPortalOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPortalOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPortalOutlet]"
    }]
  }], null, null);
})();
var NbComponentPortal = class extends ComponentPortal {
};
var _NbOverlay = class _NbOverlay extends Overlay {
};
_NbOverlay.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbOverlay_BaseFactory;
  return function NbOverlay_Factory(t) {
    return (ɵNbOverlay_BaseFactory || (ɵNbOverlay_BaseFactory = ɵɵgetInheritedFactory(_NbOverlay)))(t || _NbOverlay);
  };
})();
_NbOverlay.ɵprov = ɵɵdefineInjectable({
  token: _NbOverlay,
  factory: _NbOverlay.ɵfac
});
var NbOverlay = _NbOverlay;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlay, [{
    type: Injectable
  }], null, null);
})();
var _NbOverlayPositionBuilder = class _NbOverlayPositionBuilder extends OverlayPositionBuilder {
};
_NbOverlayPositionBuilder.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbOverlayPositionBuilder_BaseFactory;
  return function NbOverlayPositionBuilder_Factory(t) {
    return (ɵNbOverlayPositionBuilder_BaseFactory || (ɵNbOverlayPositionBuilder_BaseFactory = ɵɵgetInheritedFactory(_NbOverlayPositionBuilder)))(t || _NbOverlayPositionBuilder);
  };
})();
_NbOverlayPositionBuilder.ɵprov = ɵɵdefineInjectable({
  token: _NbOverlayPositionBuilder,
  factory: _NbOverlayPositionBuilder.ɵfac
});
var NbOverlayPositionBuilder = _NbOverlayPositionBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayPositionBuilder, [{
    type: Injectable
  }], null, null);
})();
var NbTemplatePortal = class extends TemplatePortal {
  constructor(template, viewContainerRef, context) {
    super(template, viewContainerRef, context);
  }
};
var _NbOverlayContainer = class _NbOverlayContainer extends OverlayContainer {
};
_NbOverlayContainer.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbOverlayContainer_BaseFactory;
  return function NbOverlayContainer_Factory(t) {
    return (ɵNbOverlayContainer_BaseFactory || (ɵNbOverlayContainer_BaseFactory = ɵɵgetInheritedFactory(_NbOverlayContainer)))(t || _NbOverlayContainer);
  };
})();
_NbOverlayContainer.ɵprov = ɵɵdefineInjectable({
  token: _NbOverlayContainer,
  factory: _NbOverlayContainer.ɵfac
});
var NbOverlayContainer = _NbOverlayContainer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainer, [{
    type: Injectable
  }], null, null);
})();
var NbFlexibleConnectedPositionStrategy = class extends FlexibleConnectedPositionStrategy {
};
var NbPortalInjector = class extends PortalInjector {
};
var CDK_MODULES = [OverlayModule, PortalModule];
var _NbCdkMappingModule = class _NbCdkMappingModule {
  static forRoot() {
    return {
      ngModule: _NbCdkMappingModule,
      providers: [NbOverlay, NbOverlayPositionBuilder]
    };
  }
};
_NbCdkMappingModule.ɵfac = function NbCdkMappingModule_Factory(t) {
  return new (t || _NbCdkMappingModule)();
};
_NbCdkMappingModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCdkMappingModule,
  declarations: [NbPortalDirective, NbPortalOutletDirective],
  imports: [OverlayModule, PortalModule],
  exports: [OverlayModule, PortalModule, NbPortalDirective, NbPortalOutletDirective]
});
_NbCdkMappingModule.ɵinj = ɵɵdefineInjector({
  imports: [CDK_MODULES, OverlayModule, PortalModule]
});
var NbCdkMappingModule = _NbCdkMappingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCdkMappingModule, [{
    type: NgModule,
    args: [{
      imports: [...CDK_MODULES],
      exports: [...CDK_MODULES, NbPortalDirective, NbPortalOutletDirective],
      declarations: [NbPortalDirective, NbPortalOutletDirective]
    }]
  }], null, null);
})();
var NbGlobalLogicalPosition;
(function(NbGlobalLogicalPosition2) {
  NbGlobalLogicalPosition2["TOP_START"] = "top-start";
  NbGlobalLogicalPosition2["TOP_END"] = "top-end";
  NbGlobalLogicalPosition2["BOTTOM_START"] = "bottom-start";
  NbGlobalLogicalPosition2["BOTTOM_END"] = "bottom-end";
})(NbGlobalLogicalPosition || (NbGlobalLogicalPosition = {}));
var NbGlobalPhysicalPosition;
(function(NbGlobalPhysicalPosition2) {
  NbGlobalPhysicalPosition2["TOP_RIGHT"] = "top-right";
  NbGlobalPhysicalPosition2["TOP_LEFT"] = "top-left";
  NbGlobalPhysicalPosition2["BOTTOM_RIGHT"] = "bottom-right";
  NbGlobalPhysicalPosition2["BOTTOM_LEFT"] = "bottom-left";
})(NbGlobalPhysicalPosition || (NbGlobalPhysicalPosition = {}));
var _NbPositionHelper = class _NbPositionHelper {
  constructor(layoutDirection) {
    this.layoutDirection = layoutDirection;
  }
  toLogicalPosition(position) {
    if (Object.values(NbGlobalLogicalPosition).includes(position)) {
      return position;
    }
    if (this.layoutDirection.isLtr()) {
      return this.toLogicalPositionWhenLtr(position);
    } else {
      return this.toLogicalPositionWhenRtl(position);
    }
  }
  toPhysicalPosition(position) {
    if (Object.values(NbGlobalPhysicalPosition).includes(position)) {
      return position;
    }
    if (this.layoutDirection.isLtr()) {
      return this.toPhysicalPositionWhenLtr(position);
    } else {
      return this.toPhysicalPositionWhenRtl(position);
    }
  }
  isTopPosition(position) {
    const logicalPosition = this.toLogicalPosition(position);
    return logicalPosition === NbGlobalLogicalPosition.TOP_END || logicalPosition === NbGlobalLogicalPosition.TOP_START;
  }
  isRightPosition(position) {
    const physicalPosition = this.toPhysicalPosition(position);
    return physicalPosition === NbGlobalPhysicalPosition.TOP_RIGHT || physicalPosition === NbGlobalPhysicalPosition.BOTTOM_RIGHT;
  }
  toLogicalPositionWhenLtr(position) {
    switch (position) {
      case NbGlobalPhysicalPosition.TOP_RIGHT:
        return NbGlobalLogicalPosition.TOP_END;
      case NbGlobalPhysicalPosition.TOP_LEFT:
        return NbGlobalLogicalPosition.TOP_START;
      case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
        return NbGlobalLogicalPosition.BOTTOM_END;
      case NbGlobalPhysicalPosition.BOTTOM_LEFT:
        return NbGlobalLogicalPosition.BOTTOM_START;
    }
  }
  toLogicalPositionWhenRtl(position) {
    switch (position) {
      case NbGlobalPhysicalPosition.TOP_RIGHT:
        return NbGlobalLogicalPosition.TOP_START;
      case NbGlobalPhysicalPosition.TOP_LEFT:
        return NbGlobalLogicalPosition.TOP_END;
      case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
        return NbGlobalLogicalPosition.BOTTOM_START;
      case NbGlobalPhysicalPosition.BOTTOM_LEFT:
        return NbGlobalLogicalPosition.BOTTOM_END;
    }
  }
  toPhysicalPositionWhenLtr(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return NbGlobalPhysicalPosition.TOP_LEFT;
      case NbGlobalLogicalPosition.TOP_END:
        return NbGlobalPhysicalPosition.TOP_RIGHT;
      case NbGlobalLogicalPosition.BOTTOM_START:
        return NbGlobalPhysicalPosition.BOTTOM_LEFT;
      case NbGlobalLogicalPosition.BOTTOM_END:
        return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
    }
  }
  toPhysicalPositionWhenRtl(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return NbGlobalPhysicalPosition.TOP_RIGHT;
      case NbGlobalLogicalPosition.TOP_END:
        return NbGlobalPhysicalPosition.TOP_LEFT;
      case NbGlobalLogicalPosition.BOTTOM_START:
        return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
      case NbGlobalLogicalPosition.BOTTOM_END:
        return NbGlobalPhysicalPosition.BOTTOM_LEFT;
    }
  }
};
_NbPositionHelper.ɵfac = function NbPositionHelper_Factory(t) {
  return new (t || _NbPositionHelper)(ɵɵinject(NbLayoutDirectionService));
};
_NbPositionHelper.ɵprov = ɵɵdefineInjectable({
  token: _NbPositionHelper,
  factory: _NbPositionHelper.ɵfac
});
var NbPositionHelper = _NbPositionHelper;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionHelper, [{
    type: Injectable
  }], () => [{
    type: NbLayoutDirectionService
  }], null);
})();
var _NbPlatform = class _NbPlatform extends Platform {
};
_NbPlatform.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbPlatform_BaseFactory;
  return function NbPlatform_Factory(t) {
    return (ɵNbPlatform_BaseFactory || (ɵNbPlatform_BaseFactory = ɵɵgetInheritedFactory(_NbPlatform)))(t || _NbPlatform);
  };
})();
_NbPlatform.ɵprov = ɵɵdefineInjectable({
  token: _NbPlatform,
  factory: (t) => Platform.ɵfac(t),
  providedIn: "root"
});
var NbPlatform = _NbPlatform;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPlatform, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useClass: Platform
    }]
  }], null, null);
})();
var _NbViewportRulerAdapter = class _NbViewportRulerAdapter extends ViewportRuler {
  constructor(platform, ngZone, ruler, scroll, document2) {
    super(platform, ngZone, document2);
    this.ruler = ruler;
    this.scroll = scroll;
  }
  getViewportSize() {
    let res;
    this.ruler.getDimensions().pipe(map((dimensions) => ({
      width: dimensions.clientWidth,
      height: dimensions.clientHeight
    }))).subscribe((rect) => res = rect);
    return res;
  }
  getViewportScrollPosition() {
    let res;
    this.scroll.getPosition().pipe(map((position) => ({
      top: position.y,
      left: position.x
    }))).subscribe((position) => res = position);
    return res;
  }
};
_NbViewportRulerAdapter.ɵfac = function NbViewportRulerAdapter_Factory(t) {
  return new (t || _NbViewportRulerAdapter)(ɵɵinject(NbPlatform), ɵɵinject(NgZone), ɵɵinject(NbLayoutRulerService), ɵɵinject(NbLayoutScrollService), ɵɵinject(NB_DOCUMENT));
};
_NbViewportRulerAdapter.ɵprov = ɵɵdefineInjectable({
  token: _NbViewportRulerAdapter,
  factory: _NbViewportRulerAdapter.ɵfac
});
var NbViewportRulerAdapter = _NbViewportRulerAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbViewportRulerAdapter, [{
    type: Injectable
  }], () => [{
    type: NbPlatform
  }, {
    type: NgZone
  }, {
    type: NbLayoutRulerService
  }, {
    type: NbLayoutScrollService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
function throwLayoutNotFoundError() {
  throw new Error(`[NbOverlayContainerAdapter]: Layout not found.
  When using Nebular '<nb-layout>' is required and should wrap other nebular components.`);
}
var _NbOverlayContainerAdapter = class _NbOverlayContainerAdapter extends NbOverlayContainer {
  setContainer(container) {
    this.container = container;
  }
  clearContainer() {
    this.container = null;
    this._containerElement = null;
  }
  _createContainer() {
    this.checkContainer();
    const container = this._document.createElement("div");
    container.classList.add("cdk-overlay-container");
    this.container.appendChild(container);
    this._containerElement = container;
  }
  checkContainer() {
    if (!this.container) {
      throwLayoutNotFoundError();
    }
  }
};
_NbOverlayContainerAdapter.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbOverlayContainerAdapter_BaseFactory;
  return function NbOverlayContainerAdapter_Factory(t) {
    return (ɵNbOverlayContainerAdapter_BaseFactory || (ɵNbOverlayContainerAdapter_BaseFactory = ɵɵgetInheritedFactory(_NbOverlayContainerAdapter)))(t || _NbOverlayContainerAdapter);
  };
})();
_NbOverlayContainerAdapter.ɵprov = ɵɵdefineInjectable({
  token: _NbOverlayContainerAdapter,
  factory: _NbOverlayContainerAdapter.ɵfac
});
var NbOverlayContainerAdapter = _NbOverlayContainerAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainerAdapter, [{
    type: Injectable
  }], null, null);
})();
var NbAdjustment;
(function(NbAdjustment2) {
  NbAdjustment2["NOOP"] = "noop";
  NbAdjustment2["CLOCKWISE"] = "clockwise";
  NbAdjustment2["COUNTERCLOCKWISE"] = "counterclockwise";
  NbAdjustment2["VERTICAL"] = "vertical";
  NbAdjustment2["HORIZONTAL"] = "horizontal";
})(NbAdjustment || (NbAdjustment = {}));
var NbPosition;
(function(NbPosition2) {
  NbPosition2["TOP"] = "top";
  NbPosition2["BOTTOM"] = "bottom";
  NbPosition2["LEFT"] = "left";
  NbPosition2["RIGHT"] = "right";
  NbPosition2["START"] = "start";
  NbPosition2["END"] = "end";
  NbPosition2["TOP_END"] = "top-end";
  NbPosition2["TOP_START"] = "top-start";
  NbPosition2["BOTTOM_END"] = "bottom-end";
  NbPosition2["BOTTOM_START"] = "bottom-start";
  NbPosition2["END_TOP"] = "end-top";
  NbPosition2["END_BOTTOM"] = "end-bottom";
  NbPosition2["START_TOP"] = "start-top";
  NbPosition2["START_BOTTOM"] = "start-bottom";
})(NbPosition || (NbPosition = {}));
var POSITIONS = {
  [NbPosition.RIGHT](offset) {
    return {
      originX: "end",
      originY: "center",
      overlayX: "start",
      overlayY: "center",
      offsetX: offset
    };
  },
  [NbPosition.BOTTOM](offset) {
    return {
      originX: "center",
      originY: "bottom",
      overlayX: "center",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.LEFT](offset) {
    return {
      originX: "start",
      originY: "center",
      overlayX: "end",
      overlayY: "center",
      offsetX: -offset
    };
  },
  [NbPosition.TOP](offset) {
    return {
      originX: "center",
      originY: "top",
      overlayX: "center",
      overlayY: "bottom",
      offsetY: -offset
    };
  },
  [NbPosition.START](offset) {
    return this[NbPosition.LEFT](offset);
  },
  [NbPosition.END](offset) {
    return this[NbPosition.RIGHT](offset);
  },
  [NbPosition.END_TOP](offset) {
    return {
      originX: "end",
      originY: "bottom",
      overlayX: "start",
      overlayY: "bottom",
      offsetX: offset
    };
  },
  [NbPosition.END_BOTTOM](offset) {
    return {
      originX: "end",
      originY: "top",
      overlayX: "start",
      overlayY: "top",
      offsetX: offset
    };
  },
  [NbPosition.BOTTOM_START](offset) {
    return {
      originX: "end",
      originY: "bottom",
      overlayX: "end",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.BOTTOM_END](offset) {
    return {
      originX: "start",
      originY: "bottom",
      overlayX: "start",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.START_TOP](offset) {
    return {
      originX: "start",
      originY: "bottom",
      overlayX: "end",
      overlayY: "bottom",
      offsetX: -offset
    };
  },
  [NbPosition.START_BOTTOM](offset) {
    return {
      originX: "start",
      originY: "top",
      overlayX: "end",
      overlayY: "top",
      offsetX: -offset
    };
  },
  [NbPosition.TOP_START](offset) {
    return {
      originX: "end",
      originY: "top",
      overlayX: "end",
      overlayY: "bottom",
      offsetY: -offset
    };
  },
  [NbPosition.TOP_END](offset) {
    return {
      originX: "start",
      originY: "top",
      overlayX: "start",
      overlayY: "bottom",
      offsetY: -offset
    };
  }
};
var RTL_PHYSICAL_POSITIONS = __spreadProps(__spreadValues({}, POSITIONS), {
  [NbPosition.RIGHT](offset) {
    return {
      originX: "start",
      originY: "center",
      overlayX: "end",
      overlayY: "center",
      offsetX: offset
    };
  },
  [NbPosition.LEFT](offset) {
    return {
      originX: "end",
      originY: "center",
      overlayX: "start",
      overlayY: "center",
      offsetX: -offset
    };
  },
  [NbPosition.START](offset) {
    return this[NbPosition.RIGHT](offset);
  },
  [NbPosition.END](offset) {
    return this[NbPosition.LEFT](offset);
  }
});
var COUNTER_CLOCKWISE_POSITIONS = [NbPosition.TOP, NbPosition.TOP_END, NbPosition.TOP_START, NbPosition.START, NbPosition.START_TOP, NbPosition.START_BOTTOM, NbPosition.BOTTOM, NbPosition.BOTTOM_START, NbPosition.BOTTOM_END, NbPosition.END, NbPosition.END_BOTTOM, NbPosition.END_TOP];
var CLOCKWISE_POSITIONS = [NbPosition.TOP, NbPosition.TOP_START, NbPosition.TOP_END, NbPosition.END, NbPosition.END_TOP, NbPosition.END_BOTTOM, NbPosition.BOTTOM, NbPosition.BOTTOM_END, NbPosition.BOTTOM_START, NbPosition.START, NbPosition.START_BOTTOM, NbPosition.START_TOP];
var VERTICAL_POSITIONS = [NbPosition.BOTTOM, NbPosition.TOP];
var HORIZONTAL_POSITIONS = [NbPosition.START, NbPosition.END];
function comparePositions(p1, p2) {
  return p1.originX === p2.originX && p1.originY === p2.originY && p1.overlayX === p2.overlayX && p1.overlayY === p2.overlayY;
}
var NbAdjustableConnectedPositionStrategy = class extends NbFlexibleConnectedPositionStrategy {
  constructor() {
    super(...arguments);
    this._offset = 15;
    this.positionChange = this.positionChanges.pipe(map((positionChange) => positionChange.connectionPair), map((connectionPair) => {
      return this.appliedPositions.find(({
        connectedPosition
      }) => {
        return comparePositions(connectedPosition, connectionPair);
      }).key;
    }));
  }
  attach(overlayRef) {
    this.applyPositions();
    super.attach(overlayRef);
  }
  direction(direction) {
    this._direction = direction;
    return this;
  }
  apply() {
    this.applyPositions();
    super.apply();
  }
  position(position) {
    this._position = position;
    return this;
  }
  adjustment(adjustment) {
    this._adjustment = adjustment;
    return this;
  }
  offset(offset) {
    this._offset = offset;
    return this;
  }
  applyPositions() {
    const positions = this.createPositions();
    this.persistChosenPositions(positions);
    this.withPositions(this.appliedPositions.map(({
      connectedPosition
    }) => connectedPosition));
  }
  createPositions() {
    switch (this._adjustment) {
      case NbAdjustment.NOOP:
        return [this._position];
      case NbAdjustment.CLOCKWISE:
        return this.reorderPreferredPositions(CLOCKWISE_POSITIONS);
      case NbAdjustment.COUNTERCLOCKWISE:
        return this.reorderPreferredPositions(COUNTER_CLOCKWISE_POSITIONS);
      case NbAdjustment.HORIZONTAL:
        return this.reorderPreferredPositions(HORIZONTAL_POSITIONS);
      case NbAdjustment.VERTICAL:
        return this.reorderPreferredPositions(VERTICAL_POSITIONS);
    }
  }
  mapToLogicalPosition(position) {
    if (position === NbPosition.LEFT) {
      return this._direction === NbLayoutDirection.LTR ? NbPosition.START : NbPosition.END;
    }
    if (position === NbPosition.RIGHT) {
      return this._direction === NbLayoutDirection.LTR ? NbPosition.END : NbPosition.START;
    }
    return position;
  }
  persistChosenPositions(positions) {
    const positionGrid = this._direction === NbLayoutDirection.RTL ? RTL_PHYSICAL_POSITIONS : POSITIONS;
    this.appliedPositions = positions.map((position) => ({
      key: position,
      connectedPosition: positionGrid[position](this._offset)
    }));
  }
  reorderPreferredPositions(positions) {
    const startPosition = this.mapToLogicalPosition(this._position);
    const startPositionIndex = positions.indexOf(startPosition);
    const firstPart = positions.slice(startPositionIndex);
    const secondPart = positions.slice(0, startPositionIndex);
    return firstPart.concat(secondPart);
  }
};
var NbGlobalPositionStrategy = class extends GlobalPositionStrategy {
  position(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return this.top().left();
      case NbGlobalLogicalPosition.TOP_END:
        return this.top().right();
      case NbGlobalLogicalPosition.BOTTOM_START:
        return this.bottom().left();
      case NbGlobalLogicalPosition.BOTTOM_END:
        return this.bottom().right();
    }
  }
};
var _NbPositionBuilderService = class _NbPositionBuilderService {
  constructor(document2, viewportRuler, platform, positionBuilder, overlayContainer) {
    this.document = document2;
    this.viewportRuler = viewportRuler;
    this.platform = platform;
    this.positionBuilder = positionBuilder;
    this.overlayContainer = overlayContainer;
  }
  global() {
    return new NbGlobalPositionStrategy();
  }
  connectedTo(elementRef) {
    return new NbAdjustableConnectedPositionStrategy(elementRef, this.viewportRuler, this.document, this.platform, this.overlayContainer).withFlexibleDimensions(false).withPush(false);
  }
};
_NbPositionBuilderService.ɵfac = function NbPositionBuilderService_Factory(t) {
  return new (t || _NbPositionBuilderService)(ɵɵinject(NB_DOCUMENT), ɵɵinject(NbViewportRulerAdapter), ɵɵinject(NbPlatform), ɵɵinject(NbOverlayPositionBuilder), ɵɵinject(NbOverlayContainerAdapter));
};
_NbPositionBuilderService.ɵprov = ɵɵdefineInjectable({
  token: _NbPositionBuilderService,
  factory: _NbPositionBuilderService.ɵfac
});
var NbPositionBuilderService = _NbPositionBuilderService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionBuilderService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NbPlatform
  }, {
    type: NbOverlayPositionBuilder
  }, {
    type: NbOverlayContainerAdapter
  }], null);
})();
var _NbPositionedContainerComponent = class _NbPositionedContainerComponent {
  get top() {
    return this.position === NbPosition.TOP;
  }
  get topStart() {
    return this.position === NbPosition.TOP_START;
  }
  get topEnd() {
    return this.position === NbPosition.TOP_END;
  }
  get right() {
    return this.position === NbPosition.RIGHT || this.position === NbPosition.END;
  }
  get endTop() {
    return this.position === NbPosition.END_TOP;
  }
  get endBottom() {
    return this.position === NbPosition.END_BOTTOM;
  }
  get bottom() {
    return this.position === NbPosition.BOTTOM;
  }
  get bottomStart() {
    return this.position === NbPosition.BOTTOM_START;
  }
  get bottomEnd() {
    return this.position === NbPosition.BOTTOM_END;
  }
  get left() {
    return this.position === NbPosition.LEFT || this.position === NbPosition.START;
  }
  get startTop() {
    return this.position === NbPosition.START_TOP;
  }
  get startBottom() {
    return this.position === NbPosition.START_BOTTOM;
  }
};
_NbPositionedContainerComponent.ɵfac = function NbPositionedContainerComponent_Factory(t) {
  return new (t || _NbPositionedContainerComponent)();
};
_NbPositionedContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbPositionedContainerComponent,
  selectors: [["ng-component"]],
  hostVars: 24,
  hostBindings: function NbPositionedContainerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("nb-overlay-top", ctx.top)("nb-overlay-top-start", ctx.topStart)("nb-overlay-top-end", ctx.topEnd)("nb-overlay-right", ctx.right)("nb-overlay-end-top", ctx.endTop)("nb-overlay-end-bottom", ctx.endBottom)("nb-overlay-bottom", ctx.bottom)("nb-overlay-bottom-start", ctx.bottomStart)("nb-overlay-bottom-end", ctx.bottomEnd)("nb-overlay-left", ctx.left)("nb-overlay-start-top", ctx.startTop)("nb-overlay-start-bottom", ctx.startBottom);
    }
  },
  inputs: {
    position: "position"
  },
  decls: 0,
  vars: 0,
  template: function NbPositionedContainerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbPositionedContainerComponent = _NbPositionedContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionedContainerComponent, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], null, {
    position: [{
      type: Input
    }],
    top: [{
      type: HostBinding,
      args: ["class.nb-overlay-top"]
    }],
    topStart: [{
      type: HostBinding,
      args: ["class.nb-overlay-top-start"]
    }],
    topEnd: [{
      type: HostBinding,
      args: ["class.nb-overlay-top-end"]
    }],
    right: [{
      type: HostBinding,
      args: ["class.nb-overlay-right"]
    }],
    endTop: [{
      type: HostBinding,
      args: ["class.nb-overlay-end-top"]
    }],
    endBottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-end-bottom"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom"]
    }],
    bottomStart: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom-start"]
    }],
    bottomEnd: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom-end"]
    }],
    left: [{
      type: HostBinding,
      args: ["class.nb-overlay-left"]
    }],
    startTop: [{
      type: HostBinding,
      args: ["class.nb-overlay-start-top"]
    }],
    startBottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-start-bottom"]
    }]
  });
})();
var _NbOverlayContainerComponent = class _NbOverlayContainerComponent {
  constructor(vcr, injector, changeDetectorRef) {
    this.vcr = vcr;
    this.injector = injector;
    this.changeDetectorRef = changeDetectorRef;
    this.isAttached = false;
  }
  get isStringContent() {
    return !!this.content;
  }
  attachComponentPortal(portal, context) {
    portal.injector = this.createChildInjector(portal.componentFactoryResolver);
    const componentRef = this.portalOutlet.attachComponentPortal(portal);
    if (context) {
      Object.assign(componentRef.instance, context);
    }
    componentRef.changeDetectorRef.markForCheck();
    componentRef.changeDetectorRef.detectChanges();
    this.isAttached = true;
    return componentRef;
  }
  attachTemplatePortal(portal) {
    const templateRef = this.portalOutlet.attachTemplatePortal(portal);
    templateRef.detectChanges();
    this.isAttached = true;
    return templateRef;
  }
  attachStringContent(content) {
    this.content = content;
    this.changeDetectorRef.markForCheck();
    this.changeDetectorRef.detectChanges();
    this.isAttached = true;
  }
  detach() {
    if (this.portalOutlet.hasAttached()) {
      this.portalOutlet.detach();
    }
    this.attachStringContent(null);
    this.isAttached = false;
  }
  createChildInjector(cfr) {
    return new NbPortalInjector(this.injector, new WeakMap([[ComponentFactoryResolver$1, cfr]]));
  }
};
_NbOverlayContainerComponent.ɵfac = function NbOverlayContainerComponent_Factory(t) {
  return new (t || _NbOverlayContainerComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbOverlayContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbOverlayContainerComponent,
  selectors: [["nb-overlay-container"]],
  viewQuery: function NbOverlayContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalOutletDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    }
  },
  decls: 2,
  vars: 1,
  consts: [["class", "primitive-overlay", 4, "ngIf"], ["nbPortalOutlet", ""], [1, "primitive-overlay"]],
  template: function NbOverlayContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbOverlayContainerComponent_div_0_Template, 2, 1, "div", 0)(1, NbOverlayContainerComponent_ng_template_1_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isStringContent);
    }
  },
  dependencies: [NbPortalOutletDirective, NgIf],
  encapsulation: 2
});
var NbOverlayContainerComponent = _NbOverlayContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-overlay-container",
      template: `
    <div *ngIf="isStringContent" class="primitive-overlay">{{ content }}</div>
    <ng-template nbPortalOutlet></ng-template>
  `
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: Injector
  }, {
    type: ChangeDetectorRef
  }], {
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective, {
        static: true
      }]
    }]
  });
})();
function patch(container, containerContext) {
  Object.assign(container.instance, containerContext);
  container.changeDetectorRef.detectChanges();
  return container;
}
function createContainer(ref, container, context, componentFactoryResolver) {
  const containerRef = ref.attach(new NbComponentPortal(container, null, null, componentFactoryResolver));
  patch(containerRef, context);
  return containerRef;
}
var _NbOverlayService = class _NbOverlayService {
  constructor(overlay, layoutDirection) {
    this.overlay = overlay;
    this.layoutDirection = layoutDirection;
  }
  get scrollStrategies() {
    return this.overlay.scrollStrategies;
  }
  create(config) {
    const overlayRef = this.overlay.create(config);
    this.layoutDirection.onDirectionChange().subscribe((dir) => overlayRef.setDirection(dir));
    return overlayRef;
  }
};
_NbOverlayService.ɵfac = function NbOverlayService_Factory(t) {
  return new (t || _NbOverlayService)(ɵɵinject(NbOverlay), ɵɵinject(NbLayoutDirectionService));
};
_NbOverlayService.ɵprov = ɵɵdefineInjectable({
  token: _NbOverlayService,
  factory: _NbOverlayService.ɵfac
});
var NbOverlayService = _NbOverlayService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayService, [{
    type: Injectable
  }], () => [{
    type: NbOverlay
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var _NbScrollDispatcherAdapter = class _NbScrollDispatcherAdapter extends ScrollDispatcher {
  constructor(ngZone, platform, scrollService, document2) {
    super(ngZone, platform, document2);
    this.scrollService = scrollService;
  }
  scrolled(auditTimeInMs) {
    return merge(super.scrolled(auditTimeInMs), this.scrollService.onScroll());
  }
};
_NbScrollDispatcherAdapter.ɵfac = function NbScrollDispatcherAdapter_Factory(t) {
  return new (t || _NbScrollDispatcherAdapter)(ɵɵinject(NgZone), ɵɵinject(NbPlatform), ɵɵinject(NbLayoutScrollService), ɵɵinject(NB_DOCUMENT));
};
_NbScrollDispatcherAdapter.ɵprov = ɵɵdefineInjectable({
  token: _NbScrollDispatcherAdapter,
  factory: _NbScrollDispatcherAdapter.ɵfac
});
var NbScrollDispatcherAdapter = _NbScrollDispatcherAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbScrollDispatcherAdapter, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: NbPlatform
  }, {
    type: NbLayoutScrollService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbBlockScrollStrategyAdapter = class _NbBlockScrollStrategyAdapter extends BlockScrollStrategy {
  constructor(document2, viewportRuler, scrollService) {
    super(viewportRuler, document2);
    this.scrollService = scrollService;
  }
  enable() {
    super.enable();
    this.scrollService.scrollable(false);
  }
  disable() {
    super.disable();
    this.scrollService.scrollable(true);
  }
};
_NbBlockScrollStrategyAdapter.ɵfac = function NbBlockScrollStrategyAdapter_Factory(t) {
  return new (t || _NbBlockScrollStrategyAdapter)(ɵɵinject(NB_DOCUMENT), ɵɵinject(NbViewportRulerAdapter), ɵɵinject(NbLayoutScrollService));
};
_NbBlockScrollStrategyAdapter.ɵprov = ɵɵdefineInjectable({
  token: _NbBlockScrollStrategyAdapter,
  factory: _NbBlockScrollStrategyAdapter.ɵfac
});
var NbBlockScrollStrategyAdapter = _NbBlockScrollStrategyAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBlockScrollStrategyAdapter, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NbLayoutScrollService
  }], null);
})();
var _NbScrollStrategyOptions = class _NbScrollStrategyOptions extends ScrollStrategyOptions {
  constructor(scrollService, scrollDispatcher, viewportRuler, ngZone, document2) {
    super(scrollDispatcher, viewportRuler, ngZone, document2);
    this.scrollService = scrollService;
    this.scrollDispatcher = scrollDispatcher;
    this.viewportRuler = viewportRuler;
    this.ngZone = ngZone;
    this.document = document2;
    this.block = () => new NbBlockScrollStrategyAdapter(this.document, this.viewportRuler, this.scrollService);
  }
};
_NbScrollStrategyOptions.ɵfac = function NbScrollStrategyOptions_Factory(t) {
  return new (t || _NbScrollStrategyOptions)(ɵɵinject(NbLayoutScrollService), ɵɵinject(ScrollDispatcher), ɵɵinject(NbViewportRulerAdapter), ɵɵinject(NgZone), ɵɵinject(NB_DOCUMENT));
};
_NbScrollStrategyOptions.ɵprov = ɵɵdefineInjectable({
  token: _NbScrollStrategyOptions,
  factory: _NbScrollStrategyOptions.ɵfac
});
var NbScrollStrategyOptions = _NbScrollStrategyOptions;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbScrollStrategyOptions, [{
    type: Injectable
  }], () => [{
    type: NbLayoutScrollService
  }, {
    type: ScrollDispatcher
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbCdkAdapterModule = class _NbCdkAdapterModule {
  static forRoot() {
    return {
      ngModule: _NbCdkAdapterModule,
      providers: [NbViewportRulerAdapter, NbOverlayContainerAdapter, NbBlockScrollStrategyAdapter, NbScrollDispatcherAdapter, NbScrollStrategyOptions, {
        provide: OverlayContainer,
        useExisting: NbOverlayContainerAdapter
      }, {
        provide: NbOverlayContainer,
        useExisting: NbOverlayContainerAdapter
      }, {
        provide: ScrollDispatcher,
        useExisting: NbScrollDispatcherAdapter
      }, {
        provide: ScrollStrategyOptions,
        useExisting: NbScrollStrategyOptions
      }]
    };
  }
};
_NbCdkAdapterModule.ɵfac = function NbCdkAdapterModule_Factory(t) {
  return new (t || _NbCdkAdapterModule)();
};
_NbCdkAdapterModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCdkAdapterModule
});
_NbCdkAdapterModule.ɵinj = ɵɵdefineInjector({});
var NbCdkAdapterModule = _NbCdkAdapterModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCdkAdapterModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var NbTrigger;
(function(NbTrigger2) {
  NbTrigger2["NOOP"] = "noop";
  NbTrigger2["CLICK"] = "click";
  NbTrigger2["HOVER"] = "hover";
  NbTrigger2["HINT"] = "hint";
  NbTrigger2["FOCUS"] = "focus";
})(NbTrigger || (NbTrigger = {}));
var NbTriggerStrategyBase = class {
  destroy() {
    this.destroyed$.next();
  }
  isNotOnHostOrContainer(element) {
    return !this.isOnHost(element) && !this.isOnContainer(element);
  }
  isOnHostOrContainer(element) {
    return this.isOnHost(element) || this.isOnContainer(element);
  }
  isOnHost(element) {
    return this.host.contains(element);
  }
  isOnContainer(element) {
    return this.container() && this.container().location.nativeElement.contains(element);
  }
  constructor(document2, host, container) {
    this.document = document2;
    this.host = host;
    this.container = container;
    this.destroyed$ = new Subject();
  }
};
var NbClickTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.click$ = fromEvent(this.document, "click").pipe(map((event) => [!this.container() && this.isOnHost(event.target), event]), share(), takeUntil(this.destroyed$));
    this.show$ = this.click$.pipe(filter(([shouldShow]) => shouldShow), map(([, event]) => event), takeUntil(this.destroyed$));
    this.hide$ = this.click$.pipe(filter(([shouldShow, event]) => !shouldShow && !this.isOnContainer(event.target)), map(([, event]) => event), takeUntil(this.destroyed$));
  }
};
var NbHoverTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = fromEvent(this.host, "mouseenter").pipe(
      filter(() => !this.container()),
      // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
      // meaning that if one event occurs in some time after the initial one we won't react to it
      delay(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "mouseleave")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = fromEvent(this.host, "mouseleave").pipe(switchMap(() => fromEvent(this.document, "mousemove").pipe(debounceTime(100), takeWhile(() => !!this.container()), filter((event) => this.isNotOnHostOrContainer(event.target)))), takeUntil(this.destroyed$));
  }
};
var NbHintTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = fromEvent(this.host, "mouseenter").pipe(
      // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
      // meaning that if one event occurs in some time after the initial one we won't react to it
      delay(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "mouseleave")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = fromEvent(this.host, "mouseleave").pipe(takeUntil(this.destroyed$));
  }
};
var NbFocusTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.focusOut$ = fromEvent(this.host, "focusout").pipe(switchMap(() => fromEvent(this.document, "focusin").pipe(takeWhile(() => !!this.container()), filter((event) => this.isNotOnHostOrContainer(event.target)))), takeUntil(this.destroyed$));
    this.clickIn$ = fromEvent(this.host, "click").pipe(filter(() => !this.container()), takeUntil(this.destroyed$));
    this.clickOut$ = fromEvent(this.document, "click").pipe(
      filter(() => !!this.container()),
      /**
       * Event target of `click` could be different from `activeElement`.
       * If during click you return focus to the host, it won't be opened.
       */
      filter((event) => {
        if (this.isNotOnHostOrContainer(event.target)) {
          return this.isNotOnHostOrContainer(this.document.activeElement);
        }
        return false;
      }),
      takeUntil(this.destroyed$)
    );
    this.tabKeyPress$ = fromEvent(this.document, "keydown").pipe(filter((event) => event.keyCode === 9), filter(() => !!this.container()), takeUntil(this.destroyed$));
    this.show$ = merge(fromEvent(this.host, "focusin"), this.clickIn$).pipe(
      filter(() => !this.container()),
      debounceTime(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "focusout")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = merge(this.focusOut$, this.tabKeyPress$, this.clickOut$).pipe(takeUntil(this.destroyed$));
  }
};
var NbNoopTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = EMPTY;
    this.hide$ = EMPTY;
  }
};
var _NbTriggerStrategyBuilderService = class _NbTriggerStrategyBuilderService {
  constructor(_document) {
    this._document = _document;
  }
  trigger(trigger2) {
    this._trigger = trigger2;
    return this;
  }
  host(host) {
    this._host = host;
    return this;
  }
  container(container) {
    this._container = container;
    return this;
  }
  build() {
    switch (this._trigger) {
      case NbTrigger.CLICK:
        return new NbClickTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.HINT:
        return new NbHintTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.HOVER:
        return new NbHoverTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.FOCUS:
        return new NbFocusTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.NOOP:
        return new NbNoopTriggerStrategy(this._document, this._host, this._container);
      default:
        throw new Error("Trigger have to be provided");
    }
  }
};
_NbTriggerStrategyBuilderService.ɵfac = function NbTriggerStrategyBuilderService_Factory(t) {
  return new (t || _NbTriggerStrategyBuilderService)(ɵɵinject(NB_DOCUMENT));
};
_NbTriggerStrategyBuilderService.ɵprov = ɵɵdefineInjectable({
  token: _NbTriggerStrategyBuilderService,
  factory: _NbTriggerStrategyBuilderService.ɵfac
});
var NbTriggerStrategyBuilderService = _NbTriggerStrategyBuilderService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTriggerStrategyBuilderService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbOverlayModule = class _NbOverlayModule {
  static forRoot() {
    return {
      ngModule: _NbOverlayModule,
      providers: [NbPositionBuilderService, NbTriggerStrategyBuilderService, NbOverlayService, NbPositionHelper, ...NbCdkMappingModule.forRoot().providers, ...NbCdkAdapterModule.forRoot().providers, ...NbA11yModule.forRoot().providers]
    };
  }
};
_NbOverlayModule.ɵfac = function NbOverlayModule_Factory(t) {
  return new (t || _NbOverlayModule)();
};
_NbOverlayModule.ɵmod = ɵɵdefineNgModule({
  type: _NbOverlayModule,
  declarations: [NbPositionedContainerComponent, NbOverlayContainerComponent],
  imports: [NbCdkMappingModule, NbSharedModule],
  exports: [NbCdkMappingModule, NbCdkAdapterModule, NbOverlayContainerComponent]
});
_NbOverlayModule.ɵinj = ɵɵdefineInjector({
  imports: [NbCdkMappingModule, NbSharedModule, NbCdkMappingModule, NbCdkAdapterModule]
});
var NbOverlayModule = _NbOverlayModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayModule, [{
    type: NgModule,
    args: [{
      imports: [NbCdkMappingModule, NbSharedModule],
      declarations: [NbPositionedContainerComponent, NbOverlayContainerComponent],
      exports: [NbCdkMappingModule, NbCdkAdapterModule, NbOverlayContainerComponent]
    }]
  }], null, null);
})();
var _NbStatusService = class _NbStatusService {
  constructor() {
    this.coreStatuses = ["basic", "primary", "info", "warning", "danger", "control"];
  }
  isCoreStatus(status) {
    return this.coreStatuses.includes(status);
  }
  isCustomStatus(status) {
    if (this.isValidStatusString(status)) {
      return !this.isCoreStatus(status);
    }
    return false;
  }
  getStatusClass(status) {
    if (this.isValidStatusString(status)) {
      return `status-${status}`;
    }
    return void 0;
  }
  isValidStatusString(status) {
    return typeof status === "string" && status.length > 0;
  }
};
_NbStatusService.ɵfac = function NbStatusService_Factory(t) {
  return new (t || _NbStatusService)();
};
_NbStatusService.ɵprov = ɵɵdefineInjectable({
  token: _NbStatusService,
  factory: _NbStatusService.ɵfac
});
var NbStatusService = _NbStatusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStatusService, [{
    type: Injectable
  }], null, null);
})();
function windowFactory(platformId) {
  if (isPlatformBrowser(platformId)) {
    return window;
  }
  return void 0;
}
var _NbThemeModule = class _NbThemeModule {
  // TODO: check the options (throw exception?)
  /**
   * Main Theme Module
   *
   * @param nbThemeOptions {NbThemeOptions} Main theme options
   * @param nbJSThemes {NbJSThemeOptions[]} List of JS Themes, will be merged with default themes
   * @param nbMediaBreakpoints {NbMediaBreakpoint} Available media breakpoints
   * @param layoutDirection {NbLayoutDirection} Layout direction
   *
   * @returns {ModuleWithProviders}
   */
  static forRoot(nbThemeOptions = {
    name: "default"
  }, nbJSThemes, nbMediaBreakpoints, layoutDirection) {
    return {
      ngModule: _NbThemeModule,
      providers: [{
        provide: NB_THEME_OPTIONS,
        useValue: nbThemeOptions || {}
      }, {
        provide: NB_BUILT_IN_JS_THEMES,
        useValue: BUILT_IN_THEMES
      }, {
        provide: NB_JS_THEMES,
        useValue: nbJSThemes || []
      }, {
        provide: NB_MEDIA_BREAKPOINTS,
        useValue: nbMediaBreakpoints || DEFAULT_MEDIA_BREAKPOINTS
      }, {
        provide: NB_DOCUMENT,
        useExisting: DOCUMENT
      }, {
        provide: NB_WINDOW,
        useFactory: windowFactory,
        deps: [PLATFORM_ID]
      }, NbJSThemesRegistry, NbThemeService, NbMediaBreakpointsService, NbSpinnerService, {
        provide: NB_LAYOUT_DIRECTION,
        useValue: layoutDirection || NbLayoutDirection.LTR
      }, NbLayoutDirectionService, NbLayoutScrollService, NbLayoutRulerService, ...NbOverlayModule.forRoot().providers, NbStatusService]
    };
  }
};
_NbThemeModule.ɵfac = function NbThemeModule_Factory(t) {
  return new (t || _NbThemeModule)();
};
_NbThemeModule.ɵmod = ɵɵdefineNgModule({
  type: _NbThemeModule,
  imports: [CommonModule]
});
_NbThemeModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
var NbThemeModule = _NbThemeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbThemeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      exports: []
    }]
  }], null, null);
})();
var NbColorHelper = class _NbColorHelper {
  static shade(color, weight) {
    return _NbColorHelper.mix("#000000", color, weight);
  }
  static tint(color, weight) {
    return _NbColorHelper.mix("#ffffff", color, weight);
  }
  static mix(color1, color2, weight) {
    const d2h = (d) => d.toString(16);
    const h2d = (h) => parseInt(h, 16);
    let result = "#";
    for (let i = 1; i < 7; i += 2) {
      const firstPart = h2d(color1.substr(i, 2));
      const secondPart = h2d(color2.substr(i, 2));
      const resultPart = d2h(Math.floor(secondPart + (firstPart - secondPart) * (weight / 100)));
      result += ("0" + resultPart).slice(-2);
    }
    return result;
  }
  static hexToRgbA(hex, alpha) {
    let c;
    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
      c = hex.substring(1).split("");
      if (c.length === 3) {
        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
      }
      c = "0x" + c.join("");
      return "rgba(" + [c >> 16 & 255, c >> 8 & 255, c & 255].join(",") + "," + alpha + ")";
    }
    throw new Error("Bad Hex");
  }
};
var NbIconPackType;
(function(NbIconPackType2) {
  NbIconPackType2["SVG"] = "svg";
  NbIconPackType2["FONT"] = "font";
})(NbIconPackType || (NbIconPackType = {}));
var NbFontIcon = class {
  constructor(name, content, params = {}) {
    this.name = name;
    this.content = content;
    this.params = params;
  }
  getClasses(options) {
    const classes = [];
    if (this.params.packClass) {
      classes.push(this.params.packClass);
    }
    const name = this.params.iconClassPrefix ? `${this.params.iconClassPrefix}-${this.name}` : this.name;
    classes.push(name);
    return classes;
  }
  getContent(options) {
    return this.content;
  }
};
var NbSvgIcon = class {
  constructor(name, content, params = {}) {
    this.name = name;
    this.content = content;
    this.params = params;
  }
  getClasses(options) {
    const classes = [];
    if (this.params.packClass) {
      classes.push(this.params.packClass);
    }
    return classes;
  }
  getContent(options) {
    return this.content;
  }
};
var NbIconDefinition = class {
};
function throwPackNotFoundError(name) {
  throw Error(`Icon Pack '${name}' is not registered`);
}
function throwNoDefaultPackError() {
  throw Error("Default pack is not registered.");
}
function throwWrongPackTypeError(name, type, desiredType) {
  throw Error(`Pack '${name}' is not an '${desiredType}' Pack and its type is '${type}'`);
}
var _NbIconLibraries = class _NbIconLibraries {
  constructor() {
    this.packs = /* @__PURE__ */ new Map();
  }
  /**
   * Registers new Svg icon pack
   * @param {string} name
   * @param {NbIcon} icons
   * @param {NbIconPackParams} params
   */
  registerSvgPack(name, icons, params = {}) {
    this.packs.set(name, {
      name,
      icons: new Map(Object.entries(icons)),
      params,
      type: NbIconPackType.SVG
    });
  }
  /**
   * Registers new font pack
   * @param {string} name
   * @param {NbIconPackParams} params
   */
  registerFontPack(name, params = {}) {
    this.packs.set(name, {
      name,
      params,
      icons: /* @__PURE__ */ new Map(),
      type: NbIconPackType.FONT
    });
  }
  /**
   * Returns pack by name
   * @param {string} name
   */
  getPack(name) {
    return this.packs.get(name);
  }
  /**
   * Sets pack as a default
   * @param {string} name
   */
  setDefaultPack(name) {
    if (!this.packs.has(name)) {
      throwPackNotFoundError(name);
    }
    this.defaultPack = this.packs.get(name);
  }
  /**
   * Returns Svg icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getSvgIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type !== NbIconPackType.SVG) {
      throwWrongPackTypeError(iconsPack.name, iconsPack.type, "SVG");
    }
    const icon = this.getIconFromPack(name, iconsPack);
    if (!icon) {
      return null;
    }
    return {
      name,
      pack: iconsPack.name,
      type: NbIconPackType.SVG,
      icon: this.createSvgIcon(name, icon, iconsPack.params)
    };
  }
  /**
   * Returns Font icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getFontIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type !== NbIconPackType.FONT) {
      throwWrongPackTypeError(iconsPack.name, iconsPack.type, "Font");
    }
    const icon = this.getIconFromPack(name, iconsPack) ?? "";
    const iconContent = iconsPack.params.ligature ? name : icon;
    return {
      name,
      pack: iconsPack.name,
      type: NbIconPackType.FONT,
      icon: this.createFontIcon(name, iconContent, iconsPack.params)
    };
  }
  /**
   * Returns an icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type === NbIconPackType.SVG) {
      return this.getSvgIcon(name, pack);
    }
    return this.getFontIcon(name, pack);
  }
  createSvgIcon(name, content, params) {
    return content instanceof NbSvgIcon ? content : new NbSvgIcon(name, content, params);
  }
  createFontIcon(name, content, params) {
    return content instanceof NbFontIcon ? content : new NbFontIcon(name, content, params);
  }
  getPackOrThrow(name) {
    const pack = this.packs.get(name);
    if (!pack) {
      throwPackNotFoundError(name);
    }
    return pack;
  }
  getDefaultPackOrThrow() {
    if (!this.defaultPack) {
      throwNoDefaultPackError();
    }
    return this.defaultPack;
  }
  getIconFromPack(name, pack) {
    if (pack.icons.has(name)) {
      return pack.icons.get(name);
    }
    return null;
  }
};
_NbIconLibraries.ɵfac = function NbIconLibraries_Factory(t) {
  return new (t || _NbIconLibraries)();
};
_NbIconLibraries.ɵprov = ɵɵdefineInjectable({
  token: _NbIconLibraries,
  factory: _NbIconLibraries.ɵfac,
  providedIn: "root"
});
var NbIconLibraries = _NbIconLibraries;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconLibraries, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _NbIconComponent = class _NbIconComponent {
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Sets all icon configurable properties via config object.
   * If passed value is a string set icon name.
   * @docs-private
   */
  get config() {
    return this._config;
  }
  set config(value) {
    if (!value) {
      return;
    }
    this._config = value;
    if (typeof value === "string") {
      this.icon = value;
    } else {
      this.icon = value.icon;
      this.pack = value.pack;
      this.status = value.status;
      this.options = value.options;
    }
  }
  constructor(sanitizer, iconLibrary, el, renderer, statusService) {
    this.sanitizer = sanitizer;
    this.iconLibrary = iconLibrary;
    this.el = el;
    this.renderer = renderer;
    this.statusService = statusService;
    this.prevClasses = [];
    this.html = "";
  }
  ngOnInit() {
    this.iconDef = this.renderIcon(this.icon, this.pack, this.options);
  }
  ngOnChanges() {
    const iconDef = this.iconLibrary.getIcon(this.icon, this.pack);
    if (iconDef) {
      this.renderIcon(this.icon, this.pack, this.options);
    } else {
      this.clearIcon();
    }
  }
  renderIcon(name, pack, options) {
    const iconDefinition = this.iconLibrary.getIcon(name, pack);
    if (!iconDefinition) {
      return void 0;
    }
    const content = iconDefinition.icon.getContent(options);
    if (content) {
      this.html = this.sanitizer.bypassSecurityTrustHtml(content);
    }
    this.assignClasses(iconDefinition.icon.getClasses(options));
    return iconDefinition;
  }
  clearIcon() {
    this.html = "";
    this.assignClasses([]);
  }
  assignClasses(classes) {
    this.prevClasses.forEach((className) => {
      this.renderer.removeClass(this.el.nativeElement, className);
    });
    classes.forEach((className) => {
      this.renderer.addClass(this.el.nativeElement, className);
    });
    this.prevClasses = classes;
  }
};
_NbIconComponent.ɵfac = function NbIconComponent_Factory(t) {
  return new (t || _NbIconComponent)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(NbIconLibraries), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NbStatusService));
};
_NbIconComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbIconComponent,
  selectors: [["nb-icon"]],
  hostVars: 17,
  hostBindings: function NbIconComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("innerHtml", ctx.html, ɵɵsanitizeHtml);
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    icon: "icon",
    pack: "pack",
    options: "options",
    status: "status",
    config: "config"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 0,
  vars: 0,
  template: function NbIconComponent_Template(rf, ctx) {
  },
  styles: ["[_nghost-%COMP%]{display:inline-block}"],
  changeDetection: 0
});
var NbIconComponent = _NbIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconComponent, [{
    type: Component,
    args: [{
      selector: "nb-icon",
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [":host{display:inline-block}\n"]
    }]
  }], () => [{
    type: DomSanitizer
  }, {
    type: NbIconLibraries
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NbStatusService
  }], {
    html: [{
      type: HostBinding,
      args: ["innerHtml"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    icon: [{
      type: Input
    }],
    pack: [{
      type: Input
    }],
    options: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    config: [{
      type: Input
    }]
  });
})();
var _NbIconModule = class _NbIconModule {
  constructor(iconsLibrary) {
    this.iconsLibrary = iconsLibrary;
    this.essentialsPackName = "nebular-essentials";
    if (this.iconsLibrary.getPack(this.essentialsPackName)) {
      return;
    }
    this.iconsLibrary.registerSvgPack(this.essentialsPackName, {
      "chevron-down-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-down"><rect width="24" height="24" opacity="0"/><path d="M12 15.5a1 1 0 0 1-.71-.29l-4-4a1 1 0 1 1 1.42-1.42L12 13.1l3.3-3.18a1 1 0 1 1 1.38 1.44l-4 3.86a1 1 0 0 1-.68.28z"/></g></g></svg>',
      "chevron-up-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M16 14.5a1 1 0 0 1-.71-.29L12 10.9l-3.3 3.18a1 1 0 0 1-1.41 0 1 1 0 0 1 0-1.42l4-3.86a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1 0 1.42 1 1 0 0 1-.69.28z"/></g></g></svg>',
      "chevron-left-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.36 17a1 1 0 0 1-.72-.31l-3.86-4a1 1 0 0 1 0-1.4l4-4a1 1 0 1 1 1.42 1.42L10.9 12l3.18 3.3a1 1 0 0 1 0 1.41 1 1 0 0 1-.72.29z"/></g></g></svg>',
      "chevron-right-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M10.5 17a1 1 0 0 1-.71-.29 1 1 0 0 1 0-1.42L13.1 12 9.92 8.69a1 1 0 0 1 0-1.41 1 1 0 0 1 1.42 0l3.86 4a1 1 0 0 1 0 1.4l-4 4a1 1 0 0 1-.7.32z"/></g></g></svg>',
      "checkmark-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="checkmark"><rect width="24" height="24" opacity="0"/><path d="M9.86 18a1 1 0 0 1-.73-.32l-4.86-5.17a1 1 0 1 1 1.46-1.37l4.12 4.39 8.41-9.2a1 1 0 1 1 1.48 1.34l-9.14 10a1 1 0 0 1-.73.33z"/></g></g></svg>',
      "paper-plane-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="paper-plane"><rect width="24" height="24" opacity="0"/><path d="M21 4a1.31 1.31 0 0 0-.06-.27v-.09a1 1 0 0 0-.2-.3 1 1 0 0 0-.29-.19h-.09a.86.86 0 0 0-.31-.15H20a1 1 0 0 0-.3 0l-18 6a1 1 0 0 0 0 1.9l8.53 2.84 2.84 8.53a1 1 0 0 0 1.9 0l6-18A1 1 0 0 0 21 4zm-4.7 2.29l-5.57 5.57L5.16 10zM14 18.84l-1.86-5.57 5.57-5.57z"/></g></g></svg>',
      "file-text-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="file-text"><rect width="24" height="24" opacity="0"/><path d="M15 16H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/><path d="M9 14h3a1 1 0 0 0 0-2H9a1 1 0 0 0 0 2z"/><path d="M19.74 8.33l-5.44-6a1 1 0 0 0-.74-.33h-7A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V9a1 1 0 0 0-.26-.67zM14 5l2.74 3h-2a.79.79 0 0 1-.74-.85zm3.44 15H6.56a.53.53 0 0 1-.56-.5v-15a.53.53 0 0 1 .56-.5H12v3.15A2.79 2.79 0 0 0 14.71 10H18v9.5a.53.53 0 0 1-.56.5z"/></g></g></svg>',
      "alert-triangle-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="alert-triangle"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M22.56 16.3L14.89 3.58a3.43 3.43 0 0 0-5.78 0L1.44 16.3a3 3 0 0 0-.05 3A3.37 3.37 0 0 0 4.33 21h15.34a3.37 3.37 0 0 0 2.94-1.66 3 3 0 0 0-.05-3.04zm-1.7 2.05a1.31 1.31 0 0 1-1.19.65H4.33a1.31 1.31 0 0 1-1.19-.65 1 1 0 0 1 0-1l7.68-12.73a1.48 1.48 0 0 1 2.36 0l7.67 12.72a1 1 0 0 1 .01 1.01z"/><circle cx="12" cy="16" r="1"/><path d="M12 8a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/></g></g></svg>',
      "question-mark-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="question-mark"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M17 9A5 5 0 0 0 7 9a1 1 0 0 0 2 0 3 3 0 1 1 3 3 1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-1.1A5 5 0 0 0 17 9z"/><circle cx="12" cy="19" r="1"/></g></g></svg>',
      "email-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="email"><rect width="24" height="24" opacity="0"/><path d="M19 4H5a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3zm-.67 2L12 10.75 5.67 6zM19 18H5a1 1 0 0 1-1-1V7.25l7.4 5.55a1 1 0 0 0 .6.2 1 1 0 0 0 .6-.2L20 7.25V17a1 1 0 0 1-1 1z"/></g></g></svg>',
      "flash-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="flash"><rect width="24" height="24" opacity="0"/><path d="M11.11 23a1 1 0 0 1-.34-.06 1 1 0 0 1-.65-1.05l.77-7.09H5a1 1 0 0 1-.83-1.56l7.89-11.8a1 1 0 0 1 1.17-.38 1 1 0 0 1 .65 1l-.77 7.14H19a1 1 0 0 1 .83 1.56l-7.89 11.8a1 1 0 0 1-.83.44zM6.87 12.8H12a1 1 0 0 1 .74.33 1 1 0 0 1 .25.78l-.45 4.15 4.59-6.86H12a1 1 0 0 1-1-1.11l.45-4.15z"/></g></g></svg>',
      "search-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="search"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM5 11a6 6 0 1 1 6 6 6 6 0 0 1-6-6z"/></g></g></svg>',
      "close-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="close"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M13.41 12l4.3-4.29a1 1 0 1 0-1.42-1.42L12 10.59l-4.29-4.3a1 1 0 0 0-1.42 1.42l4.3 4.29-4.3 4.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l4.29-4.3 4.29 4.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g></svg>',
      "collapse-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="collapse"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 9h-2.58l3.29-3.29a1 1 0 1 0-1.42-1.42L15 7.57V5a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2z"/><path d="M10 13H5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L9 16.42V19a1 1 0 0 0 1 1 1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z"/></g></g></svg>',
      "expand-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="expand"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 5a1 1 0 0 0-1-1h-5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L18 7.42V10a1 1 0 0 0 1 1 1 1 0 0 0 1-1z"/><path d="M10.71 13.29a1 1 0 0 0-1.42 0L6 16.57V14a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2H7.42l3.29-3.29a1 1 0 0 0 0-1.42z"/></g></g></svg>',
      "minus-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="minus"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 13H5a1 1 0 0 1 0-2h14a1 1 0 0 1 0 2z"/></g></g></svg>',
      "minus-bold-outline": '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 2" width="100%" height="100%"><defs><rect id="nb-mbo" y="3" width="8" height="2" rx="1"/></defs><use xlink:href="#nb-mbo" transform="translate(0 -3)" fill-rule="evenodd"/></svg>',
      "checkmark-bold-outline": '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 7" width="100%" height="100%"><defs><path id="nb-cbo" d="M6.039 1.43a1.11 1.11 0 0 1 1.517-.228c.483.342.588.998.234 1.466L4.431 7.1a1 1 0 0 1-1.492.115L.317 4.677a1.023 1.023 0 0 1 .002-1.483 1.113 1.113 0 0 1 1.535.002l1.641 1.59L6.04 1.428z"/></defs><use xlink:href="#nb-cbo" transform="translate(0 -1)" fill-rule="evenodd"/></svg>',
      "arrow-back": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="arrow-back"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M19 11H7.14l3.63-4.36a1 1 0 1 0-1.54-1.28l-5 6a1.19 1.19 0 0 0-.09.15c0 .05 0 .08-.07.13A1 1 0 0 0 4 12a1 1 0 0 0 .07.36c0 .05 0 .08.07.13a1.19 1.19 0 0 0 .09.15l5 6A1 1 0 0 0 10 19a1 1 0 0 0 .64-.23 1 1 0 0 0 .13-1.41L7.14 13H19a1 1 0 0 0 0-2z"/></g></g></svg>'
    });
  }
};
_NbIconModule.ɵfac = function NbIconModule_Factory(t) {
  return new (t || _NbIconModule)(ɵɵinject(NbIconLibraries));
};
_NbIconModule.ɵmod = ɵɵdefineNgModule({
  type: _NbIconModule,
  declarations: [NbIconComponent],
  imports: [CommonModule],
  exports: [NbIconComponent]
});
_NbIconModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
var NbIconModule = _NbIconModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [NbIconComponent],
      exports: [NbIconComponent]
    }]
  }], () => [{
    type: NbIconLibraries
  }], null);
})();
var _NbCardHeaderComponent = class _NbCardHeaderComponent {
};
_NbCardHeaderComponent.ɵfac = function NbCardHeaderComponent_Factory(t) {
  return new (t || _NbCardHeaderComponent)();
};
_NbCardHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardHeaderComponent,
  selectors: [["nb-card-header"]],
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbCardHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbCardHeaderComponent = _NbCardHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-header",
      template: `<ng-content></ng-content>`
    }]
  }], null, null);
})();
var _NbCardBodyComponent = class _NbCardBodyComponent {
};
_NbCardBodyComponent.ɵfac = function NbCardBodyComponent_Factory(t) {
  return new (t || _NbCardBodyComponent)();
};
_NbCardBodyComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardBodyComponent,
  selectors: [["nb-card-body"]],
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbCardBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbCardBodyComponent = _NbCardBodyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardBodyComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-body",
      template: `<ng-content></ng-content>`
    }]
  }], null, null);
})();
var _NbCardFooterComponent = class _NbCardFooterComponent {
};
_NbCardFooterComponent.ɵfac = function NbCardFooterComponent_Factory(t) {
  return new (t || _NbCardFooterComponent)();
};
_NbCardFooterComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardFooterComponent,
  selectors: [["nb-card-footer"]],
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbCardFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbCardFooterComponent = _NbCardFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-footer",
      template: `<ng-content></ng-content>`
    }]
  }], null, null);
})();
var _NbCardComponent = class _NbCardComponent {
  /**
   * Card size, available sizes:
   * tiny, small, medium, large, giant
   */
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get hasAccent() {
    return this.accent;
  }
  get primaryAccent() {
    return this.accent === "primary";
  }
  get infoAccent() {
    return this.accent === "info";
  }
  get successAccent() {
    return this.accent === "success";
  }
  get warningAccent() {
    return this.accent === "warning";
  }
  get dangerAccent() {
    return this.accent === "danger";
  }
  get basicAccent() {
    return this.accent === "basic";
  }
  get controlAccent() {
    return this.accent === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this._size = "";
    this.status = "";
    this.accent = "";
  }
};
_NbCardComponent.ɵfac = function NbCardComponent_Factory(t) {
  return new (t || _NbCardComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbCardComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardComponent,
  selectors: [["nb-card"]],
  hostVars: 42,
  hostBindings: function NbCardComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent", ctx.hasAccent)("accent-primary", ctx.primaryAccent)("accent-info", ctx.infoAccent)("accent-success", ctx.successAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    accent: "accent"
  },
  ngContentSelectors: _c2,
  decls: 4,
  vars: 0,
  template: function NbCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c13);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
      ɵɵprojection(2, 2);
      ɵɵprojection(3, 3);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;flex-direction:column}"]
});
var NbCardComponent = _NbCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-card",
      template: `
    <ng-content select="nb-card-header"></ng-content>
    <ng-content select="nb-card-body"></ng-content>
    <ng-content></ng-content>
    <ng-content select="nb-card-footer"></ng-content>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    accent: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    hasAccent: [{
      type: HostBinding,
      args: ["class.accent"]
    }],
    primaryAccent: [{
      type: HostBinding,
      args: ["class.accent-primary"]
    }],
    infoAccent: [{
      type: HostBinding,
      args: ["class.accent-info"]
    }],
    successAccent: [{
      type: HostBinding,
      args: ["class.accent-success"]
    }],
    warningAccent: [{
      type: HostBinding,
      args: ["class.accent-warning"]
    }],
    dangerAccent: [{
      type: HostBinding,
      args: ["class.accent-danger"]
    }],
    basicAccent: [{
      type: HostBinding,
      args: ["class.accent-basic"]
    }],
    controlAccent: [{
      type: HostBinding,
      args: ["class.accent-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbRevealCardComponent = class _NbRevealCardComponent {
  constructor() {
    this.revealed = false;
    this.showToggleButton = true;
  }
  toggle() {
    this.revealed = !this.revealed;
  }
};
_NbRevealCardComponent.ɵfac = function NbRevealCardComponent_Factory(t) {
  return new (t || _NbRevealCardComponent)();
};
_NbRevealCardComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRevealCardComponent,
  selectors: [["nb-reveal-card"]],
  hostVars: 2,
  hostBindings: function NbRevealCardComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("revealed", ctx.revealed);
    }
  },
  inputs: {
    revealed: "revealed",
    showToggleButton: "showToggleButton"
  },
  ngContentSelectors: _c4,
  decls: 4,
  vars: 1,
  consts: [[1, "second-card-container"], ["class", "reveal-button", 3, "click", 4, "ngIf"], [1, "reveal-button", 3, "click"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
  template: function NbRevealCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c3);
      ɵɵprojection(0);
      ɵɵelementStart(1, "div", 0);
      ɵɵprojection(2, 1);
      ɵɵelementEnd();
      ɵɵtemplate(3, NbRevealCardComponent_a_3_Template, 2, 0, "a", 1);
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showToggleButton);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["[_nghost-%COMP%]{display:block;position:relative;overflow:hidden}[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s .5s}[_nghost-%COMP%]     nb-card-front nb-card, [_nghost-%COMP%]     nb-card-back nb-card{box-shadow:none;margin:0}[_nghost-%COMP%]     nb-card-front{display:block;height:100%}[_nghost-%COMP%]     nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top .5s}[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform .3s}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{top:0;transition:none}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]     nb-card-back{top:0}.revealed[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{transform:none}"]
});
var NbRevealCardComponent = _NbRevealCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRevealCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-reveal-card",
      template: `
    <ng-content select="nb-card-front"></ng-content>
    <div class="second-card-container">
      <ng-content select="nb-card-back"></ng-content>
    </div>
    <a *ngIf="showToggleButton" class="reveal-button" (click)="toggle()">
      <nb-icon icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </a>
  `,
      styles: [":host{display:block;position:relative;overflow:hidden}:host .second-card-container{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s .5s}:host ::ng-deep nb-card-front nb-card,:host ::ng-deep nb-card-back nb-card{box-shadow:none;margin:0}:host ::ng-deep nb-card-front{display:block;height:100%}:host ::ng-deep nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top .5s}:host .reveal-button{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform .3s}:host(.revealed) .second-card-container{top:0;transition:none}:host(.revealed) .second-card-container ::ng-deep nb-card-back{top:0}:host(.revealed) .reveal-button{transform:none}\n"]
    }]
  }], null, {
    revealed: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.revealed"]
    }],
    showToggleButton: [{
      type: Input
    }]
  });
})();
var _NbFlipCardComponent = class _NbFlipCardComponent {
  constructor() {
    this.flipped = false;
    this.showToggleButton = true;
  }
  toggle() {
    this.flipped = !this.flipped;
  }
};
_NbFlipCardComponent.ɵfac = function NbFlipCardComponent_Factory(t) {
  return new (t || _NbFlipCardComponent)();
};
_NbFlipCardComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbFlipCardComponent,
  selectors: [["nb-flip-card"]],
  hostVars: 2,
  hostBindings: function NbFlipCardComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("flipped", ctx.flipped);
    }
  },
  inputs: {
    flipped: "flipped",
    showToggleButton: "showToggleButton"
  },
  ngContentSelectors: _c4,
  decls: 7,
  vars: 2,
  consts: [[1, "flipcard-body"], [1, "front-container"], ["class", "flip-button", 3, "click", 4, "ngIf"], [1, "back-container"], [1, "flip-button", 3, "click"], ["icon", "chevron-left-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
  template: function NbFlipCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c3);
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵprojection(2);
      ɵɵtemplate(3, NbFlipCardComponent_a_3_Template, 2, 0, "a", 2);
      ɵɵelementEnd();
      ɵɵelementStart(4, "div", 3);
      ɵɵprojection(5, 1);
      ɵɵtemplate(6, NbFlipCardComponent_a_6_Template, 2, 0, "a", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showToggleButton);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showToggleButton);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:block;min-width:0;perspective:1200px;position:relative}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]{transform:rotateY(-180deg)}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{opacity:0;transition:opacity 0s .25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{opacity:0;z-index:-1}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body[_ngcontent-%COMP%]{display:flex;transition:transform .5s;transform-style:preserve-3d}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{flex:1;height:fit-content;overflow:auto}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s .15s}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s .2s}.flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}"]
});
var NbFlipCardComponent = _NbFlipCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFlipCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-flip-card",
      template: `
    <div class="flipcard-body">
      <div class="front-container">
        <ng-content select="nb-card-front"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
      <div class="back-container">
        <ng-content select="nb-card-back"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
    </div>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:block;min-width:0;perspective:1200px;position:relative}:host-context(.flipped) .flipcard-body{transform:rotateY(-180deg)}:host-context(.flipped) .flipcard-body .front-container{opacity:0;transition:opacity 0s .25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}:host-context(.flipped) .flipcard-body .front-container .flip-button{opacity:0;z-index:-1}:host-context(.flipped) .flipcard-body .back-container{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body{display:flex;transition:transform .5s;transform-style:preserve-3d}.flipcard-body .front-container,.flipcard-body .back-container{flex:1;height:fit-content;overflow:auto}.flipcard-body .front-container .flip-button,.flipcard-body .back-container .flip-button{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s .15s}.flipcard-body .front-container{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s .2s}.flipcard-body .back-container{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}\n"]
    }]
  }], null, {
    flipped: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.flipped"]
    }],
    showToggleButton: [{
      type: Input
    }]
  });
})();
var _NbCardFrontComponent = class _NbCardFrontComponent {
};
_NbCardFrontComponent.ɵfac = function NbCardFrontComponent_Factory(t) {
  return new (t || _NbCardFrontComponent)();
};
_NbCardFrontComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardFrontComponent,
  selectors: [["nb-card-front"]],
  ngContentSelectors: _c6,
  decls: 1,
  vars: 0,
  template: function NbCardFrontComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c5);
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbCardFrontComponent = _NbCardFrontComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardFrontComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-front",
      template: '<ng-content select="nb-card"></ng-content>'
    }]
  }], null, null);
})();
var _NbCardBackComponent = class _NbCardBackComponent {
};
_NbCardBackComponent.ɵfac = function NbCardBackComponent_Factory(t) {
  return new (t || _NbCardBackComponent)();
};
_NbCardBackComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardBackComponent,
  selectors: [["nb-card-back"]],
  ngContentSelectors: _c6,
  decls: 1,
  vars: 0,
  template: function NbCardBackComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c5);
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbCardBackComponent = _NbCardBackComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardBackComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-back",
      template: '<ng-content select="nb-card"></ng-content>'
    }]
  }], null, null);
})();
var NB_CARD_COMPONENTS = [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent];
var _NbCardModule = class _NbCardModule {
};
_NbCardModule.ɵfac = function NbCardModule_Factory(t) {
  return new (t || _NbCardModule)();
};
_NbCardModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCardModule,
  declarations: [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent]
});
_NbCardModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbCardModule = _NbCardModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [...NB_CARD_COMPONENTS],
      exports: [...NB_CARD_COMPONENTS]
    }]
  }], null, null);
})();
var NbCalendarViewMode;
(function(NbCalendarViewMode2) {
  NbCalendarViewMode2["YEAR"] = "year";
  NbCalendarViewMode2["MONTH"] = "month";
  NbCalendarViewMode2["DATE"] = "date";
})(NbCalendarViewMode || (NbCalendarViewMode = {}));
var NbCalendarSize;
(function(NbCalendarSize2) {
  NbCalendarSize2["MEDIUM"] = "medium";
  NbCalendarSize2["LARGE"] = "large";
})(NbCalendarSize || (NbCalendarSize = {}));
function convertToBoolProperty(val) {
  if (typeof val === "string") {
    val = val.toLowerCase().trim();
    return val === "true" || val === "";
  }
  return !!val;
}
var NbDateService = class {
  constructor() {
    this.DAYS_IN_WEEK = 7;
    this.HOURS_IN_DAY_PERIOD = 12;
  }
  setLocale(locale) {
    this.locale = locale;
  }
  /**
   * Checks if the date is between the start date and the end date.
   * */
  isBetween(date, start, end) {
    return this.compareDates(date, start) > 0 && this.compareDates(date, end) < 0;
  }
  /**
   * Checks is two dates have the same day.
   * */
  isSameDaySafe(date1, date2) {
    return date1 && date2 && this.isSameDay(date1, date2);
  }
  /**
   * Checks is two dates have the same month.
   * */
  isSameMonthSafe(date1, date2) {
    return date1 && date2 && this.isSameMonth(date1, date2);
  }
  /**
   * Checks is two dates have the same year.
   * */
  isSameYearSafe(date1, date2) {
    return date1 && date2 && this.isSameYear(date1, date2);
  }
  isSameHourAndMinute(date1, date2) {
    return this.isSameHour(date1, date2) && this.isSameMinute(date1, date2);
  }
  isSameHour(date1, date2) {
    return this.getHours(date1) === this.getHours(date2);
  }
  isSameMinute(date1, date2) {
    return this.getMinutes(date1) === this.getMinutes(date2);
  }
  getTwentyFourHoursFormat() {
    return "HH:mm";
  }
  getTwentyFourHoursFormatWithSeconds() {
    return "HH:mm:ss";
  }
  getTwelveHoursFormatWithSeconds() {
    return "hh:mm:ss a";
  }
  getDayPeriod(date) {
    const isFirstDayPeriod = this.getHours(date) < this.HOURS_IN_DAY_PERIOD;
    if (isFirstDayPeriod) {
      return "AM";
    } else {
      return "PM";
    }
  }
};
var batch = (target, batchSize, offset = 0) => {
  return target.reduce((res, item, index) => {
    const chunkIndex = Math.floor((index + offset) / batchSize);
    if (!res[chunkIndex]) {
      res[chunkIndex] = [];
    }
    res[chunkIndex].push(item);
    return res;
  }, []);
};
var rangeFromTo = (from2, to = 0, producer = (i) => i) => {
  const arr = [];
  for (let i = from2; i < to; i++) {
    arr.push(producer(i));
  }
  return arr;
};
var range = (bound, producer = (i) => i) => {
  return rangeFromTo(0, bound, producer);
};
var _NbCalendarYearModelService = class _NbCalendarYearModelService {
  constructor(dateService) {
    this.dateService = dateService;
    this.yearsInView = 12;
    this.yearsInRow = 4;
  }
  getYearsInView() {
    return this.yearsInView;
  }
  getYearsInRow() {
    return this.yearsInRow;
  }
  getViewYears(viewYear) {
    const year = this.dateService.getYear(viewYear);
    let viewStartYear;
    if (year >= 0) {
      viewStartYear = year - year % this.yearsInView;
    } else {
      viewStartYear = year - (year % this.yearsInView + this.yearsInView);
    }
    const years = range(this.yearsInView).map((i) => this.copyWithYear(viewStartYear + i, viewYear));
    return batch(years, this.yearsInRow);
  }
  copyWithYear(year, date) {
    return this.dateService.createDate(year, this.dateService.getMonth(date), this.dateService.getDate(date));
  }
};
_NbCalendarYearModelService.ɵfac = function NbCalendarYearModelService_Factory(t) {
  return new (t || _NbCalendarYearModelService)(ɵɵinject(NbDateService));
};
_NbCalendarYearModelService.ɵprov = ɵɵdefineInjectable({
  token: _NbCalendarYearModelService,
  factory: _NbCalendarYearModelService.ɵfac
});
var NbCalendarYearModelService = _NbCalendarYearModelService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbButton = class _NbButton {
  /**
   * Sets `filled` appearance
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Sets `outline` appearance
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Sets `ghost` appearance
   */
  get ghost() {
    return this.appearance === "ghost";
  }
  set ghost(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "ghost";
    }
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * Disables the button
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (this.disabled !== convertToBoolProperty(value)) {
      this._disabled = !this.disabled;
      this.renderer.setProperty(this.hostElement.nativeElement, "disabled", this.disabled);
    }
  }
  // issue #794
  get tabbable() {
    if (this.disabled) {
      return "-1";
    }
    if (this.tabIndex == null) {
      return "0";
    }
    return this.tabIndex.toString();
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(renderer, hostElement, cd, zone, statusService) {
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "filled";
    this._fullWidth = false;
    this._disabled = false;
    this.iconLeft = false;
    this.iconRight = false;
  }
  ngAfterContentChecked() {
    const firstNode = this.nodes[0];
    const lastNode = this.nodes[this.nodes.length - 1];
    this.iconLeft = this.isIconExist(firstNode);
    this.iconRight = this.isIconExist(lastNode);
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  /**
   * @docs-private
   **/
  updateProperties(config) {
    let isPropertyChanged = false;
    for (const key in config) {
      if (config.hasOwnProperty(key) && this[key] !== config[key]) {
        this[key] = config[key];
        isPropertyChanged = true;
      }
    }
    if (isPropertyChanged) {
      this.cd.markForCheck();
    }
  }
  get iconElement() {
    const el = this.hostElement.nativeElement;
    return el.querySelector("nb-icon");
  }
  get nodes() {
    return this.cd.rootNodes.filter((child) => child.nodeType !== Node.COMMENT_NODE);
  }
  isIconExist(node) {
    return this.icons.some((item) => item.nativeElement === node);
  }
};
_NbButton.ɵfac = function NbButton_Factory(t) {
  return new (t || _NbButton)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbButton.ɵdir = ɵɵdefineDirective({
  type: _NbButton,
  contentQueries: function NbButton_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbIconComponent, 4, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.icons = _t);
    }
  },
  hostVars: 34,
  hostBindings: function NbButton_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-disabled", ctx.disabled)("tabindex", ctx.tabbable);
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("appearance-ghost", ctx.ghost)("full-width", ctx.fullWidth)("btn-disabled", ctx.disabled)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound)("icon-start", ctx.iconLeft)("icon-end", ctx.iconRight);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    filled: "filled",
    outline: "outline",
    ghost: "ghost",
    fullWidth: "fullWidth",
    disabled: "disabled",
    tabIndex: "tabIndex"
  }
});
var NbButton = _NbButton;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButton, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    ghost: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-ghost"]
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.btn-disabled"]
    }],
    tabIndex: [{
      type: Input
    }],
    tabbable: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    iconLeft: [{
      type: HostBinding,
      args: ["class.icon-start"]
    }],
    iconRight: [{
      type: HostBinding,
      args: ["class.icon-end"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    icons: [{
      type: ContentChildren,
      args: [NbIconComponent, {
        read: ElementRef
      }]
    }]
  });
})();
var _NbButtonComponent = class _NbButtonComponent extends NbButton {
  /**
   * Sets `hero` appearance
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  /**
   * @private
   * Keep this handler to partially support anchor disabling.
   * Unlike button, anchor doesn't have 'disabled' DOM property,
   * so handler will be called anyway. We preventing navigation and bubbling.
   * Disabling is partial due to click handlers precedence. Consider example:
   * <a nbButton [disabled]="true" (click)="clickHandler()">...</a>
   * 'clickHandler' will be called before our host listener below. We can't prevent
   * such handlers call.
   */
  onClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
  }
  constructor(renderer, hostElement, cd, zone, statusService) {
    super(renderer, hostElement, cd, zone, statusService);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
  }
};
_NbButtonComponent.ɵfac = function NbButtonComponent_Factory(t) {
  return new (t || _NbButtonComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbButtonComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbButtonComponent,
  selectors: [["button", "nbButton", ""], ["a", "nbButton", ""], ["input", "type", "button", "nbButton", ""], ["input", "type", "submit", "nbButton", ""]],
  hostVars: 16,
  hostBindings: function NbButtonComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbButtonComponent_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("appearance-hero", ctx.hero)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    hero: "hero"
  },
  features: [ɵɵProvidersFeature([{
    provide: NbButton,
    useExisting: _NbButtonComponent
  }]), ɵɵInheritDefinitionFeature],
  attrs: _c7,
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbButtonComponent = _NbButtonComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonComponent, [{
    type: Component,
    args: [{
      selector: 'button[nbButton],a[nbButton],input[type="button"][nbButton],input[type="submit"][nbButton]',
      template: `
    <ng-content></ng-content>
  `,
      providers: [{
        provide: NbButton,
        useExisting: NbButtonComponent
      }],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _NbCalendarViewModeComponent = class _NbCalendarViewModeComponent {
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.viewMode = NbCalendarViewMode.DATE;
    this.changeMode = new EventEmitter(true);
  }
  getText() {
    if (!this.date) {
      return "";
    }
    switch (this.viewMode) {
      case NbCalendarViewMode.DATE: {
        const month = this.dateService.getMonthName(this.date, TranslationWidth.Wide);
        const year = this.dateService.getYear(this.date);
        return `${month} ${year}`;
      }
      case NbCalendarViewMode.MONTH:
        return `${this.dateService.getYear(this.date)}`;
      case NbCalendarViewMode.YEAR:
        return `${this.getFirstYear()} - ${this.getLastYear()}`;
    }
  }
  getIcon() {
    if (this.viewMode === NbCalendarViewMode.DATE) {
      return "chevron-down-outline";
    }
    return "chevron-up-outline";
  }
  getFirstYear() {
    const years = this.yearModelService.getViewYears(this.date);
    return this.dateService.getYear(years[0][0]).toString();
  }
  getLastYear() {
    const years = this.yearModelService.getViewYears(this.date);
    const lastRow = years[years.length - 1];
    const lastYear = lastRow[lastRow.length - 1];
    return this.dateService.getYear(lastYear).toString();
  }
};
_NbCalendarViewModeComponent.ɵfac = function NbCalendarViewModeComponent_Factory(t) {
  return new (t || _NbCalendarViewModeComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NbCalendarYearModelService));
};
_NbCalendarViewModeComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarViewModeComponent,
  selectors: [["nb-calendar-view-mode"]],
  inputs: {
    date: "date",
    viewMode: "viewMode"
  },
  outputs: {
    changeMode: "changeMode"
  },
  decls: 3,
  vars: 2,
  consts: [["nbButton", "", "ghost", "", "status", "basic", 3, "click"], ["pack", "nebular-essentials", 3, "icon"]],
  template: function NbCalendarViewModeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function NbCalendarViewModeComponent_Template_button_click_0_listener() {
        return ctx.changeMode.emit();
      });
      ɵɵtext(1);
      ɵɵelement(2, "nb-icon", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.getText(), " ");
      ɵɵadvance();
      ɵɵproperty("icon", ctx.getIcon());
    }
  },
  dependencies: [NbButtonComponent, NbIconComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarViewModeComponent = _NbCalendarViewModeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarViewModeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-view-mode",
      template: `
    <button nbButton (click)="changeMode.emit()" ghost status="basic">
      {{ getText() }}
      <nb-icon [icon]="getIcon()" pack="nebular-essentials"></nb-icon>
    </button>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    date: [{
      type: Input
    }],
    viewMode: [{
      type: Input
    }],
    changeMode: [{
      type: Output
    }]
  });
})();
var _NbCalendarPageableNavigationComponent = class _NbCalendarPageableNavigationComponent {
  constructor(directionService) {
    this.directionService = directionService;
    this.next = new EventEmitter();
    this.prev = new EventEmitter();
  }
  get isLtr() {
    return this.directionService.isLtr();
  }
};
_NbCalendarPageableNavigationComponent.ɵfac = function NbCalendarPageableNavigationComponent_Factory(t) {
  return new (t || _NbCalendarPageableNavigationComponent)(ɵɵdirectiveInject(NbLayoutDirectionService));
};
_NbCalendarPageableNavigationComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarPageableNavigationComponent,
  selectors: [["nb-calendar-pageable-navigation"]],
  outputs: {
    next: "next",
    prev: "prev"
  },
  decls: 4,
  vars: 2,
  consts: [["nbButton", "", "ghost", "", "status", "basic", 1, "prev-month", 3, "click"], ["pack", "nebular-essentials", 3, "icon"], ["nbButton", "", "ghost", "", "status", "basic", 1, "next-month", 3, "click"]],
  template: function NbCalendarPageableNavigationComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function NbCalendarPageableNavigationComponent_Template_button_click_0_listener() {
        return ctx.prev.emit();
      });
      ɵɵelement(1, "nb-icon", 1);
      ɵɵelementEnd();
      ɵɵelementStart(2, "button", 2);
      ɵɵlistener("click", function NbCalendarPageableNavigationComponent_Template_button_click_2_listener() {
        return ctx.next.emit();
      });
      ɵɵelement(3, "nb-icon", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("icon", ctx.isLtr ? "chevron-left-outline" : "chevron-right-outline");
      ɵɵadvance(2);
      ɵɵproperty("icon", ctx.isLtr ? "chevron-right-outline" : "chevron-left-outline");
    }
  },
  dependencies: [NbButtonComponent, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;align-items:center;justify-content:flex-start}"]
});
var NbCalendarPageableNavigationComponent = _NbCalendarPageableNavigationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPageableNavigationComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-pageable-navigation",
      template: `
    <button nbButton (click)="prev.emit()" ghost status="basic" class="prev-month">
      <nb-icon [icon]="isLtr ? 'chevron-left-outline' : 'chevron-right-outline'" pack="nebular-essentials"></nb-icon>
    </button>
    <button nbButton (click)="next.emit()" ghost status="basic" class="next-month">
      <nb-icon [icon]="isLtr ? 'chevron-right-outline' : 'chevron-left-outline'" pack="nebular-essentials"></nb-icon>
    </button>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;align-items:center;justify-content:flex-start}\n"]
    }]
  }], () => [{
    type: NbLayoutDirectionService
  }], {
    next: [{
      type: Output
    }],
    prev: [{
      type: Output
    }]
  });
})();
var _NbCalendarYearCellComponent = class _NbCalendarYearCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.yearCellClass = true;
  }
  get selected() {
    return this.dateService.isSameYearSafe(this.date, this.selectedValue);
  }
  get today() {
    return this.dateService.isSameYearSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get year() {
    return this.dateService.getYear(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
  }
  yearStart() {
    return this.dateService.getYearStart(this.date);
  }
  yearEnd() {
    return this.dateService.getYearEnd(this.date);
  }
};
_NbCalendarYearCellComponent.ɵfac = function NbCalendarYearCellComponent_Factory(t) {
  return new (t || _NbCalendarYearCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarYearCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarYearCellComponent,
  selectors: [["nb-calendar-year-cell"]],
  hostVars: 10,
  hostBindings: function NbCalendarYearCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarYearCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("year-cell", ctx.yearCellClass);
    }
  },
  inputs: {
    date: "date",
    min: "min",
    max: "max",
    selectedValue: "selectedValue",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarYearCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.year, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarYearCellComponent = _NbCalendarYearCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-year-cell",
      template: `
    <div class="cell-content">
      {{ year }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    yearCellClass: [{
      type: HostBinding,
      args: ["class.year-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarPickerRowComponent = class _NbCalendarPickerRowComponent {
  constructor(cfr) {
    this.cfr = cfr;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter();
  }
  ngOnChanges() {
    const factory = this.cfr.resolveComponentFactory(this.component);
    this.containerRef.clear();
    this.row.forEach((date) => {
      const component = this.containerRef.createComponent(factory, this.containerRef.length);
      this.patchWithContext(component.instance, date);
      component.changeDetectorRef.detectChanges();
    });
  }
  patchWithContext(component, date) {
    component.visibleDate = this.visibleDate;
    component.selectedValue = this.selectedValue;
    component.date = date;
    component.min = this.min;
    component.max = this.max;
    component.filter = this.filter;
    component.size = this.size;
    component.select.subscribe(this.select.emit.bind(this.select));
  }
};
_NbCalendarPickerRowComponent.ɵfac = function NbCalendarPickerRowComponent_Factory(t) {
  return new (t || _NbCalendarPickerRowComponent)(ɵɵdirectiveInject(ComponentFactoryResolver$1));
};
_NbCalendarPickerRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarPickerRowComponent,
  selectors: [["nb-calendar-picker-row"]],
  viewQuery: function NbCalendarPickerRowComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(TemplateRef, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.containerRef = _t.first);
    }
  },
  inputs: {
    row: "row",
    selectedValue: "selectedValue",
    visibleDate: "visibleDate",
    component: "component",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 0,
  template: function NbCalendarPickerRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbCalendarPickerRowComponent_ng_template_0_Template, 0, 0, "ng-template");
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}"],
  changeDetection: 0
});
var NbCalendarPickerRowComponent = _NbCalendarPickerRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPickerRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-picker-row",
      template: "<ng-template></ng-template>",
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [":host{display:flex;justify-content:space-between}\n"]
    }]
  }], () => [{
    type: ComponentFactoryResolver$1
  }], {
    row: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    component: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    containerRef: [{
      type: ViewChild,
      args: [TemplateRef, {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var _NbCalendarPickerComponent = class _NbCalendarPickerComponent {
  constructor() {
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
};
_NbCalendarPickerComponent.ɵfac = function NbCalendarPickerComponent_Factory(t) {
  return new (t || _NbCalendarPickerComponent)();
};
_NbCalendarPickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarPickerComponent,
  selectors: [["nb-calendar-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.isLarge);
    }
  },
  inputs: {
    data: "data",
    visibleDate: "visibleDate",
    selectedValue: "selectedValue",
    cellComponent: "cellComponent",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  decls: 1,
  vars: 1,
  consts: [[3, "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "size", "select", 4, "ngFor", "ngForOf"], [3, "select", "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "size"]],
  template: function NbCalendarPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbCalendarPickerComponent_nb_calendar_picker_row_0_Template, 1, 8, "nb-calendar-picker-row", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.data);
    }
  },
  dependencies: [NgForOf, NbCalendarPickerRowComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarPickerComponent = _NbCalendarPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-picker",
      template: `
    <nb-calendar-picker-row
      *ngFor="let row of data"
      [row]="row"
      [visibleDate]="visibleDate"
      [selectedValue]="selectedValue"
      [component]="cellComponent"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [size]="size"
      (select)="select.emit($event)">
    </nb-calendar-picker-row>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    cellComponent: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarYearPickerComponent = class _NbCalendarYearPickerComponent {
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.cellComponent = NbCalendarYearCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this.yearChange = new EventEmitter();
  }
  ngOnChanges() {
    this.years = this.yearModelService.getViewYears(this.year);
  }
  onSelect(year) {
    this.yearChange.emit(year);
  }
};
_NbCalendarYearPickerComponent.ɵfac = function NbCalendarYearPickerComponent_Factory(t) {
  return new (t || _NbCalendarYearPickerComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NbCalendarYearModelService));
};
_NbCalendarYearPickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarYearPickerComponent,
  selectors: [["nb-calendar-year-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarYearPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.large);
    }
  },
  inputs: {
    date: "date",
    min: "min",
    max: "max",
    filter: "filter",
    _cellComponent: [InputFlags.None, "cellComponent", "_cellComponent"],
    size: "size",
    year: "year"
  },
  outputs: {
    yearChange: "yearChange"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 8,
  consts: [[3, "select", "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "size"]],
  template: function NbCalendarYearPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-calendar-picker", 0);
      ɵɵlistener("select", function NbCalendarYearPickerComponent_Template_nb_calendar_picker_select_0_listener($event) {
        return ctx.onSelect($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("data", ctx.years)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.year)("cellComponent", ctx.cellComponent)("size", ctx.size);
    }
  },
  dependencies: [NbCalendarPickerComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarYearPickerComponent = _NbCalendarYearPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-year-picker",
      template: `
    <nb-calendar-picker
      [data]="years"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="year"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    _cellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    size: [{
      type: Input
    }],
    year: [{
      type: Input
    }],
    yearChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarMonthCellComponent = class _NbCalendarMonthCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.monthCellClass = true;
  }
  get selected() {
    return this.dateService.isSameMonthSafe(this.date, this.selectedValue);
  }
  get today() {
    return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get month() {
    return this.dateService.getMonthName(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
  }
  monthStart() {
    return this.dateService.getMonthStart(this.date);
  }
  monthEnd() {
    return this.dateService.getMonthEnd(this.date);
  }
};
_NbCalendarMonthCellComponent.ɵfac = function NbCalendarMonthCellComponent_Factory(t) {
  return new (t || _NbCalendarMonthCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarMonthCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarMonthCellComponent,
  selectors: [["nb-calendar-month-cell"]],
  hostVars: 10,
  hostBindings: function NbCalendarMonthCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarMonthCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("month-cell", ctx.monthCellClass);
    }
  },
  inputs: {
    date: "date",
    selectedValue: "selectedValue",
    min: "min",
    max: "max",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarMonthCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.month, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarMonthCellComponent = _NbCalendarMonthCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-month-cell",
      template: `
    <div class="cell-content">
      {{ month }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    monthCellClass: [{
      type: HostBinding,
      args: ["class.month-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var MONTHS_IN_VIEW = 12;
var MONTHS_IN_COLUMN = 4;
var _NbCalendarMonthPickerComponent = class _NbCalendarMonthPickerComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.monthChange = new EventEmitter();
    this.cellComponent = NbCalendarMonthCellComponent;
  }
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  ngOnChanges(changes) {
    if (changes.month) {
      this.initMonths();
    }
  }
  initMonths() {
    const date = this.dateService.getDate(this.month);
    const year = this.dateService.getYear(this.month);
    const firstMonth = this.dateService.createDate(year, 0, date);
    const months = [firstMonth];
    for (let monthIndex = 1; monthIndex < MONTHS_IN_VIEW; monthIndex++) {
      months.push(this.dateService.addMonth(firstMonth, monthIndex));
    }
    this.months = batch(months, MONTHS_IN_COLUMN);
  }
  onSelect(month) {
    this.monthChange.emit(month);
  }
};
_NbCalendarMonthPickerComponent.ɵfac = function NbCalendarMonthPickerComponent_Factory(t) {
  return new (t || _NbCalendarMonthPickerComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarMonthPickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarMonthPickerComponent,
  selectors: [["nb-calendar-month-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarMonthPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.large);
    }
  },
  inputs: {
    min: "min",
    max: "max",
    filter: "filter",
    size: "size",
    month: "month",
    date: "date",
    _cellComponent: [InputFlags.None, "cellComponent", "_cellComponent"]
  },
  outputs: {
    monthChange: "monthChange"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 8,
  consts: [[3, "select", "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "size"]],
  template: function NbCalendarMonthPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-calendar-picker", 0);
      ɵɵlistener("select", function NbCalendarMonthPickerComponent_Template_nb_calendar_picker_select_0_listener($event) {
        return ctx.onSelect($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("data", ctx.months)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.month)("cellComponent", ctx.cellComponent)("size", ctx.size);
    }
  },
  dependencies: [NbCalendarPickerComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarMonthPickerComponent = _NbCalendarMonthPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-month-picker",
      template: `
    <nb-calendar-picker
      [data]="months"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="month"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    month: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    monthChange: [{
      type: Output
    }],
    _cellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarDayCellComponent = class _NbCalendarDayCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.dayCellClass = true;
  }
  get today() {
    return this.dateService.isSameDaySafe(this.date, this.dateService.today());
  }
  get boundingMonth() {
    return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
  }
  get selected() {
    return this.dateService.isSameDaySafe(this.date, this.selectedValue);
  }
  get empty() {
    return !this.date;
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get day() {
    return this.date && this.dateService.getDate(this.date);
  }
  onClick() {
    if (this.disabled || this.empty) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
  }
  dontFitFilter() {
    return this.date && this.filter && !this.filter(this.date);
  }
};
_NbCalendarDayCellComponent.ɵfac = function NbCalendarDayCellComponent_Factory(t) {
  return new (t || _NbCalendarDayCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarDayCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarDayCellComponent,
  selectors: [["nb-calendar-day-cell"]],
  hostVars: 14,
  hostBindings: function NbCalendarDayCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarDayCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled)("size-large", ctx.isLarge)("day-cell", ctx.dayCellClass);
    }
  },
  inputs: {
    date: "date",
    selectedValue: "selectedValue",
    visibleDate: "visibleDate",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarDayCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.day, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarDayCellComponent = _NbCalendarDayCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDayCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-day-cell",
      template: `
    <div class="cell-content">
      {{ day }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    boundingMonth: [{
      type: HostBinding,
      args: ["class.bounding-month"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    empty: [{
      type: HostBinding,
      args: ["class.empty"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    dayCellClass: [{
      type: HostBinding,
      args: ["class.day-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarMonthModelService = class _NbCalendarMonthModelService {
  constructor(dateService) {
    this.dateService = dateService;
  }
  createDaysGrid(activeMonth, boundingMonth = true, firstDayOfWeek) {
    const weeks = this.createDates(activeMonth, firstDayOfWeek);
    return this.withBoundingMonths(weeks, activeMonth, boundingMonth);
  }
  createDates(activeMonth, firstDayOfWeek) {
    const days = this.createDateRangeForMonth(activeMonth);
    const startOfWeekDayDiff = this.getStartOfWeekDayDiff(activeMonth, firstDayOfWeek);
    return batch(days, this.dateService.DAYS_IN_WEEK, startOfWeekDayDiff);
  }
  withBoundingMonths(weeks, activeMonth, boundingMonth) {
    let withBoundingMonths = weeks;
    if (this.isShouldAddPrevBoundingMonth(withBoundingMonths)) {
      withBoundingMonths = this.addPrevBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
    }
    if (this.isShouldAddNextBoundingMonth(withBoundingMonths)) {
      withBoundingMonths = this.addNextBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
    }
    return withBoundingMonths;
  }
  addPrevBoundingMonth(weeks, activeMonth, boundingMonth) {
    const firstWeek = weeks.shift();
    const requiredItems = this.dateService.DAYS_IN_WEEK - firstWeek.length;
    firstWeek.unshift(...this.createPrevBoundingDays(activeMonth, boundingMonth, requiredItems));
    return [firstWeek, ...weeks];
  }
  addNextBoundingMonth(weeks, activeMonth, boundingMonth) {
    const lastWeek = weeks.pop();
    const requiredItems = this.dateService.DAYS_IN_WEEK - lastWeek.length;
    lastWeek.push(...this.createNextBoundingDays(activeMonth, boundingMonth, requiredItems));
    return [...weeks, lastWeek];
  }
  createPrevBoundingDays(activeMonth, boundingMonth, requiredItems) {
    const month = this.dateService.addMonth(activeMonth, -1);
    const daysInMonth = this.dateService.getNumberOfDaysInMonth(month);
    return this.createDateRangeForMonth(month).slice(daysInMonth - requiredItems).map((date) => boundingMonth ? date : null);
  }
  createNextBoundingDays(activeMonth, boundingMonth, requiredItems) {
    const month = this.dateService.addMonth(activeMonth, 1);
    return this.createDateRangeForMonth(month).slice(0, requiredItems).map((date) => boundingMonth ? date : null);
  }
  getStartOfWeekDayDiff(date, firstDayOfWeek) {
    const startOfMonth = this.dateService.getMonthStart(date);
    return this.getWeekStartDiff(startOfMonth, firstDayOfWeek);
  }
  getWeekStartDiff(date, firstDayOfWeek) {
    const weekOfset = firstDayOfWeek ?? this.dateService.getFirstDayOfWeek();
    return (7 - weekOfset + this.dateService.getDayOfWeek(date)) % 7;
  }
  isShouldAddPrevBoundingMonth(weeks) {
    return weeks[0].length < this.dateService.DAYS_IN_WEEK;
  }
  isShouldAddNextBoundingMonth(weeks) {
    return weeks[weeks.length - 1].length < this.dateService.DAYS_IN_WEEK;
  }
  createDateRangeForMonth(date) {
    const daysInMonth = this.dateService.getNumberOfDaysInMonth(date);
    return range(daysInMonth, (i) => {
      const year = this.dateService.getYear(date);
      const month = this.dateService.getMonth(date);
      return this.dateService.createDate(year, month, i + 1);
    });
  }
};
_NbCalendarMonthModelService.ɵfac = function NbCalendarMonthModelService_Factory(t) {
  return new (t || _NbCalendarMonthModelService)(ɵɵinject(NbDateService));
};
_NbCalendarMonthModelService.ɵprov = ɵɵdefineInjectable({
  token: _NbCalendarMonthModelService,
  factory: _NbCalendarMonthModelService.ɵfac
});
var NbCalendarMonthModelService = _NbCalendarMonthModelService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbCalendarDaysNamesComponent = class _NbCalendarDaysNamesComponent {
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService) {
    this.dateService = dateService;
  }
  ngOnInit() {
    const days = this.createDaysNames();
    this.days = this.shiftStartOfWeek(days);
  }
  ngOnChanges({
    firstDayOfWeek
  }) {
    if (firstDayOfWeek) {
      const days = this.createDaysNames();
      this.days = this.shiftStartOfWeek(days);
    }
  }
  createDaysNames() {
    return this.dateService.getDayOfWeekNames().map(this.markIfHoliday);
  }
  shiftStartOfWeek(days) {
    const firstDayOfWeek = this.firstDayOfWeek ?? this.dateService.getFirstDayOfWeek();
    for (let i = 0; i < firstDayOfWeek; i++) {
      days.push(days.shift());
    }
    return days;
  }
  markIfHoliday(name, i) {
    return {
      name,
      isHoliday: i % 6 === 0
    };
  }
};
_NbCalendarDaysNamesComponent.ɵfac = function NbCalendarDaysNamesComponent_Factory(t) {
  return new (t || _NbCalendarDaysNamesComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarDaysNamesComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarDaysNamesComponent,
  selectors: [["nb-calendar-days-names"]],
  hostVars: 2,
  hostBindings: function NbCalendarDaysNamesComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.isLarge);
    }
  },
  inputs: {
    size: "size",
    firstDayOfWeek: "firstDayOfWeek"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 1,
  consts: [["class", "day", 3, "holiday", 4, "ngFor", "ngForOf"], [1, "day"]],
  template: function NbCalendarDaysNamesComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbCalendarDaysNamesComponent_div_0_Template, 2, 3, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.days);
    }
  },
  dependencies: [NgForOf],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;justify-content:space-between}[_nghost-%COMP%]   .day[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}"],
  changeDetection: 0
});
var NbCalendarDaysNamesComponent = _NbCalendarDaysNamesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDaysNamesComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-days-names",
      template: `
    <div class="day" *ngFor="let day of days" [class.holiday]="day.isHoliday">{{ day.name }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;justify-content:space-between}:host .day{display:flex;align-items:center;justify-content:center}\n"]
    }]
  }], () => [{
    type: NbDateService
  }], {
    size: [{
      type: Input
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    firstDayOfWeek: [{
      type: Input
    }]
  });
})();
var _NbCalendarWeekNumberComponent = class _NbCalendarWeekNumberComponent {
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService) {
    this.dateService = dateService;
  }
  ngOnChanges(changes) {
    if (changes.weeks) {
      this.weekNumbers = this.getWeeks();
    }
  }
  getWeeks() {
    return this.weeks.map((week) => {
      const lastDay = [...week].reverse().find((day) => !!day);
      return this.dateService.getWeekNumber(lastDay);
    });
  }
};
_NbCalendarWeekNumberComponent.ɵfac = function NbCalendarWeekNumberComponent_Factory(t) {
  return new (t || _NbCalendarWeekNumberComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarWeekNumberComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarWeekNumberComponent,
  selectors: [["nb-calendar-week-numbers"]],
  hostVars: 2,
  hostBindings: function NbCalendarWeekNumberComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.isLarge);
    }
  },
  inputs: {
    weeks: "weeks",
    size: "size",
    weekNumberSymbol: "weekNumberSymbol"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 4,
  vars: 2,
  consts: [[1, "sign-container"], [1, "sign"], ["class", "week-number", 4, "ngFor", "ngForOf"], [1, "week-number"]],
  template: function NbCalendarWeekNumberComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵtext(2);
      ɵɵelementEnd()();
      ɵɵtemplate(3, NbCalendarWeekNumberComponent_div_3_Template, 2, 1, "div", 2);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.weekNumberSymbol);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.weekNumbers);
    }
  },
  dependencies: [NgForOf],
  styles: [_c8],
  changeDetection: 0
});
var NbCalendarWeekNumberComponent = _NbCalendarWeekNumberComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarWeekNumberComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-week-numbers",
      template: `
    <div class="sign-container">
      <div class="sign">{{ weekNumberSymbol }}</div>
    </div>
    <div class="week-number" *ngFor="let weekNumber of weekNumbers">{{ weekNumber }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column}\n"]
    }]
  }], () => [{
    type: NbDateService
  }], {
    weeks: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarDayPickerComponent = class _NbCalendarDayPickerComponent {
  /**
   * Custom day cell component. Have to implement `NbCalendarCell` interface.
   * */
  set setCellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(monthModel) {
    this.monthModel = monthModel;
    this.boundingMonths = true;
    this.cellComponent = NbCalendarDayCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this._showWeekNumber = false;
    this.dateChange = new EventEmitter();
  }
  ngOnChanges({
    visibleDate,
    boundingMonths,
    firstDayOfWeek
  }) {
    if (visibleDate || boundingMonths || firstDayOfWeek) {
      this.weeks = this.monthModel.createDaysGrid(this.visibleDate, this.boundingMonths, this.firstDayOfWeek);
    }
  }
  onSelect(day) {
    this.dateChange.emit(day);
  }
};
_NbCalendarDayPickerComponent.ɵfac = function NbCalendarDayPickerComponent_Factory(t) {
  return new (t || _NbCalendarDayPickerComponent)(ɵɵdirectiveInject(NbCalendarMonthModelService));
};
_NbCalendarDayPickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarDayPickerComponent,
  selectors: [["nb-calendar-day-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarDayPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.large);
    }
  },
  inputs: {
    visibleDate: "visibleDate",
    boundingMonths: "boundingMonths",
    min: "min",
    max: "max",
    filter: "filter",
    setCellComponent: [InputFlags.None, "cellComponent", "setCellComponent"],
    size: "size",
    date: "date",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    dateChange: "dateChange"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 4,
  vars: 11,
  consts: [[3, "weeks", "size", "weekNumberSymbol", 4, "ngIf"], [1, "days-container"], [3, "size", "firstDayOfWeek"], [3, "select", "data", "visibleDate", "selectedValue", "cellComponent", "min", "max", "filter", "size"], [3, "weeks", "size", "weekNumberSymbol"]],
  template: function NbCalendarDayPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template, 1, 3, "nb-calendar-week-numbers", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵelement(2, "nb-calendar-days-names", 2);
      ɵɵelementStart(3, "nb-calendar-picker", 3);
      ɵɵlistener("select", function NbCalendarDayPickerComponent_Template_nb_calendar_picker_select_3_listener($event) {
        return ctx.onSelect($event);
      });
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.showWeekNumber);
      ɵɵadvance(2);
      ɵɵproperty("size", ctx.size)("firstDayOfWeek", ctx.firstDayOfWeek);
      ɵɵadvance();
      ɵɵproperty("data", ctx.weeks)("visibleDate", ctx.visibleDate)("selectedValue", ctx.date)("cellComponent", ctx.cellComponent)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("size", ctx.size);
    }
  },
  dependencies: [NgIf, NbCalendarDaysNamesComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent],
  styles: ["[_nghost-%COMP%]{display:flex}.days-container[_ngcontent-%COMP%]{width:100%}"],
  changeDetection: 0
});
var NbCalendarDayPickerComponent = _NbCalendarDayPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDayPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-day-picker",
      template: `
    <nb-calendar-week-numbers *ngIf="showWeekNumber"
                              [weeks]="weeks"
                              [size]="size"
                              [weekNumberSymbol]="weekNumberSymbol">
    </nb-calendar-week-numbers>
    <div class="days-container">
      <nb-calendar-days-names [size]="size" [firstDayOfWeek]="firstDayOfWeek"></nb-calendar-days-names>
      <nb-calendar-picker
          [data]="weeks"
          [visibleDate]="visibleDate"
          [selectedValue]="date"
          [cellComponent]="cellComponent"
          [min]="min"
          [max]="max"
          [filter]="filter"
          [size]="size"
          (select)="onSelect($event)">
      </nb-calendar-picker>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [":host{display:flex}.days-container{width:100%}\n"]
    }]
  }], () => [{
    type: NbCalendarMonthModelService
  }], {
    visibleDate: [{
      type: Input
    }],
    boundingMonths: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    setCellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    size: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbBaseCalendarComponent = class _NbBaseCalendarComponent {
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.boundingMonth = true;
    this.activeViewMode = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.dateChange = new EventEmitter();
    this.ViewMode = NbCalendarViewMode;
  }
  ngOnInit() {
    if (!this.visibleDate) {
      this.visibleDate = this.dateService.today();
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  setViewMode(viewMode) {
    this.activeViewMode = viewMode;
  }
  setVisibleDate(visibleDate) {
    this.visibleDate = visibleDate;
  }
  prevMonth() {
    this.changeVisibleMonth(-1);
  }
  nextMonth() {
    this.changeVisibleMonth(1);
  }
  prevYear() {
    this.changeVisibleYear(-1);
  }
  nextYear() {
    this.changeVisibleYear(1);
  }
  prevYears() {
    this.changeVisibleYears(-1);
  }
  nextYears() {
    this.changeVisibleYears(1);
  }
  navigatePrev() {
    switch (this.activeViewMode) {
      case NbCalendarViewMode.DATE:
        return this.prevMonth();
      case NbCalendarViewMode.MONTH:
        return this.prevYear();
      case NbCalendarViewMode.YEAR:
        return this.prevYears();
    }
  }
  navigateNext() {
    switch (this.activeViewMode) {
      case NbCalendarViewMode.DATE:
        return this.nextMonth();
      case NbCalendarViewMode.MONTH:
        return this.nextYear();
      case NbCalendarViewMode.YEAR:
        return this.nextYears();
    }
  }
  onChangeViewMode() {
    if (this.activeViewMode === NbCalendarViewMode.DATE) {
      return this.setViewMode(NbCalendarViewMode.YEAR);
    }
    this.setViewMode(NbCalendarViewMode.DATE);
  }
  changeVisibleMonth(direction) {
    this.visibleDate = this.dateService.addMonth(this.visibleDate, direction);
  }
  changeVisibleYear(direction) {
    this.visibleDate = this.dateService.addYear(this.visibleDate, direction);
  }
  changeVisibleYears(direction) {
    this.visibleDate = this.dateService.addYear(this.visibleDate, direction * this.yearModelService.getYearsInView());
  }
};
_NbBaseCalendarComponent.ɵfac = function NbBaseCalendarComponent_Factory(t) {
  return new (t || _NbBaseCalendarComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NbCalendarYearModelService));
};
_NbBaseCalendarComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbBaseCalendarComponent,
  selectors: [["nb-base-calendar"]],
  hostVars: 6,
  hostBindings: function NbBaseCalendarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("has-navigation", ctx.showNavigation)("has-week-number", ctx.showWeekNumber)("size-large", ctx.large);
    }
  },
  inputs: {
    boundingMonth: "boundingMonth",
    activeViewMode: [InputFlags.None, "startView", "activeViewMode"],
    min: "min",
    max: "max",
    filter: "filter",
    dayCellComponent: "dayCellComponent",
    monthCellComponent: "monthCellComponent",
    yearCellComponent: "yearCellComponent",
    size: "size",
    visibleDate: "visibleDate",
    showNavigation: "showNavigation",
    date: "date",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    dateChange: "dateChange"
  },
  decls: 6,
  vars: 5,
  consts: [["class", "calendar-navigation", 4, "ngIf"], [3, "ngSwitch"], [3, "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "firstDayOfWeek", "weekNumberSymbol", "dateChange", 4, "ngSwitchCase"], [3, "cellComponent", "date", "min", "max", "filter", "size", "year", "yearChange", 4, "ngSwitchCase"], [3, "cellComponent", "min", "max", "filter", "size", "month", "date", "monthChange", 4, "ngSwitchCase"], [1, "calendar-navigation"], [3, "changeMode", "date", "viewMode"], [3, "prev", "next"], [3, "dateChange", "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "firstDayOfWeek", "weekNumberSymbol"], [3, "yearChange", "cellComponent", "date", "min", "max", "filter", "size", "year"], [3, "monthChange", "cellComponent", "min", "max", "filter", "size", "month", "date"]],
  template: function NbBaseCalendarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-card");
      ɵɵtemplate(1, NbBaseCalendarComponent_nb_card_header_1_Template, 3, 2, "nb-card-header", 0);
      ɵɵelementStart(2, "nb-card-body", 1);
      ɵɵtemplate(3, NbBaseCalendarComponent_nb_calendar_day_picker_3_Template, 1, 11, "nb-calendar-day-picker", 2)(4, NbBaseCalendarComponent_nb_calendar_year_picker_4_Template, 1, 7, "nb-calendar-year-picker", 3)(5, NbBaseCalendarComponent_nb_calendar_month_picker_5_Template, 1, 7, "nb-calendar-month-picker", 4);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showNavigation);
      ɵɵadvance();
      ɵɵproperty("ngSwitch", ctx.activeViewMode);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.ViewMode.DATE);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.ViewMode.YEAR);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.ViewMode.MONTH);
    }
  },
  dependencies: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NgIf, NgSwitch, NgSwitchCase, NbCardComponent, NbCardBodyComponent, NbCardHeaderComponent],
  encapsulation: 2
});
var NbBaseCalendarComponent = _NbBaseCalendarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseCalendarComponent, [{
    type: Component,
    args: [{
      selector: "nb-base-calendar",
      template: '<nb-card>\n  <nb-card-header *ngIf="showNavigation" class="calendar-navigation">\n    <nb-calendar-view-mode [date]="visibleDate"\n                           [viewMode]="activeViewMode"\n                           (changeMode)="onChangeViewMode()">\n    </nb-calendar-view-mode>\n\n    <nb-calendar-pageable-navigation (prev)="navigatePrev()" (next)="navigateNext()">\n    </nb-calendar-pageable-navigation>\n  </nb-card-header>\n\n  <nb-card-body [ngSwitch]="activeViewMode">\n\n    <nb-calendar-day-picker *ngSwitchCase="ViewMode.DATE"\n                            [boundingMonths]="boundingMonth"\n                            [cellComponent]="dayCellComponent"\n                            [min]="min"\n                            [max]="max"\n                            [filter]="filter"\n                            [visibleDate]="visibleDate"\n                            [size]="size"\n                            [date]="date"\n                            [showWeekNumber]="showWeekNumber"\n                            [firstDayOfWeek]="firstDayOfWeek"\n                            (dateChange)="dateChange.emit($any($event))"\n                            [weekNumberSymbol]="weekNumberSymbol">\n    </nb-calendar-day-picker>\n\n    <nb-calendar-year-picker *ngSwitchCase="ViewMode.YEAR"\n                             [cellComponent]="yearCellComponent"\n                             [date]="$any(date)"\n                             [min]="min"\n                             [max]="max"\n                             [filter]="filter"\n                             [size]="size"\n                             [year]="visibleDate"\n                             (yearChange)="setVisibleDate($event); setViewMode(ViewMode.MONTH)">\n    </nb-calendar-year-picker>\n\n    <nb-calendar-month-picker *ngSwitchCase="ViewMode.MONTH"\n                              [cellComponent]="monthCellComponent"\n                              [min]="min"\n                              [max]="max"\n                              [filter]="filter"\n                              [size]="size"\n                              [month]="visibleDate"\n                              [date]="$any(date)"\n                              (monthChange)="setVisibleDate($event); setViewMode(ViewMode.DATE)">\n    </nb-calendar-month-picker>\n\n  </nb-card-body>\n\n</nb-card>\n'
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    boundingMonth: [{
      type: Input
    }],
    activeViewMode: [{
      type: Input,
      args: ["startView"]
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.has-navigation"]
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.has-week-number"]
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarComponent = class _NbCalendarComponent {
  constructor() {
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.weekNumberSymbol = "#";
    this.dateChange = new EventEmitter();
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
};
_NbCalendarComponent.ɵfac = function NbCalendarComponent_Factory(t) {
  return new (t || _NbCalendarComponent)();
};
_NbCalendarComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarComponent,
  selectors: [["nb-calendar"]],
  inputs: {
    boundingMonth: "boundingMonth",
    startView: "startView",
    min: "min",
    max: "max",
    filter: "filter",
    dayCellComponent: "dayCellComponent",
    monthCellComponent: "monthCellComponent",
    yearCellComponent: "yearCellComponent",
    size: "size",
    visibleDate: "visibleDate",
    showNavigation: "showNavigation",
    date: "date",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    dateChange: "dateChange"
  },
  decls: 1,
  vars: 15,
  consts: [[3, "dateChange", "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showNavigation", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek"]],
  template: function NbCalendarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-base-calendar", 0);
      ɵɵlistener("dateChange", function NbCalendarComponent_Template_nb_base_calendar_dateChange_0_listener($event) {
        return ctx.dateChange.emit($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
    }
  },
  dependencies: [NbBaseCalendarComponent],
  encapsulation: 2
});
var NbCalendarComponent = _NbCalendarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar",
      template: `
    <nb-base-calendar
      [boundingMonth]="boundingMonth"
      [startView]="startView"
      [date]="date"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [size]="size"
      [visibleDate]="visibleDate"
      [showNavigation]="showNavigation"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
      [firstDayOfWeek]="firstDayOfWeek"
      (dateChange)="dateChange.emit($event)"
    ></nb-base-calendar>
  `
    }]
  }], null, {
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }]
  });
})();
var NB_BUTTON_COMPONENTS = [NbButtonComponent];
var _NbButtonModule = class _NbButtonModule {
};
_NbButtonModule.ɵfac = function NbButtonModule_Factory(t) {
  return new (t || _NbButtonModule)();
};
_NbButtonModule.ɵmod = ɵɵdefineNgModule({
  type: _NbButtonModule,
  declarations: [NbButtonComponent],
  imports: [NbSharedModule],
  exports: [NbButtonComponent]
});
_NbButtonModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbButtonModule = _NbButtonModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_BUTTON_COMPONENTS],
      exports: [...NB_BUTTON_COMPONENTS]
    }]
  }], null, null);
})();
var _NbNativeDateService = class _NbNativeDateService extends NbDateService {
  constructor(locale) {
    super();
    this.setLocale(locale);
  }
  setLocale(locale) {
    super.setLocale(locale);
    this.datePipe = new DatePipe(locale);
  }
  setHours(date, hour) {
    const result = this.clone(date);
    result.setHours(hour);
    return result;
  }
  setMinutes(date, minute) {
    const result = this.clone(date);
    result.setMinutes(minute);
    return result;
  }
  setSeconds(date, second) {
    const result = this.clone(date);
    result.setSeconds(second);
    return result;
  }
  setMilliseconds(date, second) {
    const result = this.clone(date);
    result.setMilliseconds(second);
    return result;
  }
  isValidDateString(date, format) {
    return !isNaN(this.parse(date, format).getTime());
  }
  isValidTimeString(date, format) {
    return this.isValidDateString(date, format);
  }
  today() {
    return /* @__PURE__ */ new Date();
  }
  getLocaleTimeFormat() {
    return getLocaleTimeFormat(this.locale, FormatWidth.Short);
  }
  getDate(date) {
    return date.getDate();
  }
  getMonth(date) {
    return date.getMonth();
  }
  getYear(date) {
    return date.getFullYear();
  }
  getDayOfWeek(date) {
    return date.getDay();
  }
  /**
   * returns first day of the week, it can be 1 if week starts from monday
   * and 0 if from sunday and so on.
   * */
  getFirstDayOfWeek() {
    return getLocaleFirstDayOfWeek(this.locale);
  }
  getMonthName(date, style2 = TranslationWidth.Abbreviated) {
    const index = date.getMonth();
    return this.getMonthNameByIndex(index, style2);
  }
  getMonthNameByIndex(index, style2 = TranslationWidth.Abbreviated) {
    return getLocaleMonthNames(this.locale, FormStyle.Format, style2)[index];
  }
  getDayOfWeekNames() {
    return [...getLocaleDayNames(this.locale, FormStyle.Format, TranslationWidth.Short)];
  }
  format(date, format) {
    return this.datePipe.transform(date, format);
  }
  /**
   * We haven't got capability to parse date using formatting without third party libraries.
   * */
  parse(date, format) {
    return new Date(Date.parse(date));
  }
  addDay(date, num) {
    return this.createDate(date.getFullYear(), date.getMonth(), date.getDate() + num);
  }
  addMonth(date, num) {
    const month = this.createDate(date.getFullYear(), date.getMonth() + num, 1);
    month.setDate(Math.min(date.getDate(), this.getMonthEnd(month).getDate()));
    return month;
  }
  addMinutes(date, minute) {
    const result = new Date(date);
    result.setMinutes(date.getMinutes() + minute);
    return result;
  }
  addHours(date, hour) {
    const result = new Date(date);
    result.setHours(date.getHours() + hour);
    return result;
  }
  getHours(date) {
    return date.getHours();
  }
  getMinutes(date) {
    return date.getMinutes();
  }
  getSeconds(date) {
    return date.getSeconds();
  }
  getMilliseconds(date) {
    return date.getMilliseconds();
  }
  addYear(date, num) {
    return this.createDate(date.getFullYear() + num, date.getMonth(), date.getDate());
  }
  clone(date) {
    return new Date(date.getTime());
  }
  compareDates(date1, date2) {
    return date1.getTime() - date2.getTime();
  }
  createDate(year, month, date) {
    const result = new Date(year, month, date);
    if (year >= 0 && year < 100) {
      result.setFullYear(result.getFullYear() - 1900);
    }
    return result;
  }
  getMonthEnd(date) {
    return this.createDate(date.getFullYear(), date.getMonth() + 1, 0);
  }
  getMonthStart(date) {
    return this.createDate(date.getFullYear(), date.getMonth(), 1);
  }
  getNumberOfDaysInMonth(date) {
    return this.getMonthEnd(date).getDate();
  }
  getYearEnd(date) {
    return this.createDate(date.getFullYear(), 11, 31);
  }
  getYearStart(date) {
    return this.createDate(date.getFullYear(), 0, 1);
  }
  valueOf(date) {
    return date.valueOf();
  }
  isSameDay(date1, date2) {
    return this.isSameMonth(date1, date2) && date1.getDate() === date2.getDate();
  }
  isSameMonth(date1, date2) {
    return this.isSameYear(date1, date2) && date1.getMonth() === date2.getMonth();
  }
  isSameYear(date1, date2) {
    return date1.getFullYear() === date2.getFullYear();
  }
  getId() {
    return "native";
  }
  getWeekNumber(date) {
    return parseInt(this.datePipe.transform(date, "w"), 10);
  }
  getDateFormat() {
    return "yyyy-MM-dd";
  }
  getTwelveHoursFormat() {
    return "hh:mm a";
  }
};
_NbNativeDateService.ɵfac = function NbNativeDateService_Factory(t) {
  return new (t || _NbNativeDateService)(ɵɵinject(LOCALE_ID));
};
_NbNativeDateService.ɵprov = ɵɵdefineInjectable({
  token: _NbNativeDateService,
  factory: _NbNativeDateService.ɵfac
});
var NbNativeDateService = _NbNativeDateService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbNativeDateService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var _NbCalendarTimeModelService = class _NbCalendarTimeModelService {
  constructor(dateService) {
    this.dateService = dateService;
    this.MINUTES_AND_SECONDS = 60;
  }
  getHoursRange(step = this.MINUTES_AND_SECONDS) {
    let date = this.getResetTime();
    const endDate = this.dateService.addDay(date, 1);
    const result = [];
    while (this.dateService.compareDates(date, endDate) < 0) {
      result.push(date);
      date = this.dateService.addMinutes(date, step);
    }
    return result;
  }
  getResetTime() {
    let today = this.dateService.today();
    today = this.dateService.setHours(today, 0);
    today = this.dateService.setMinutes(today, 0);
    today = this.dateService.setSeconds(today, 0);
    today = this.dateService.setMilliseconds(today, 0);
    return today;
  }
  paddToTwoSymbols(n) {
    if (n < 10) {
      return "0" + n;
    }
    return n.toString();
  }
  buildDateFormat(twelveHoursFormat, withSeconds = false) {
    if (twelveHoursFormat) {
      return `${this.dateService.getDateFormat()} ${this.dateService.getTwelveHoursFormat()}`;
    }
    if (withSeconds) {
      return `${this.dateService.getDateFormat()} ${this.dateService.getTwentyFourHoursFormatWithSeconds()}`;
    }
    return `${this.dateService.getDateFormat()} ${this.dateService.getTwentyFourHoursFormat()}`;
  }
};
_NbCalendarTimeModelService.ɵfac = function NbCalendarTimeModelService_Factory(t) {
  return new (t || _NbCalendarTimeModelService)(ɵɵinject(NbDateService));
};
_NbCalendarTimeModelService.ɵprov = ɵɵdefineInjectable({
  token: _NbCalendarTimeModelService,
  factory: _NbCalendarTimeModelService.ɵfac
});
var NbCalendarTimeModelService = _NbCalendarTimeModelService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarTimeModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbCalendarActionsComponent = class _NbCalendarActionsComponent {
  constructor() {
    this._applyButtonText = "ok";
    this._currentTimeButtonText = "now";
    this.setCurrentTime = new EventEmitter();
    this.saveValue = new EventEmitter();
  }
  set applyButtonText(value) {
    if (value) {
      this._applyButtonText = value;
    }
  }
  get applyText() {
    return this._applyButtonText;
  }
  set currentTimeButtonText(value) {
    if (value) {
      this._currentTimeButtonText = value;
    }
  }
  get currentTimeText() {
    return this._currentTimeButtonText;
  }
};
_NbCalendarActionsComponent.ɵfac = function NbCalendarActionsComponent_Factory(t) {
  return new (t || _NbCalendarActionsComponent)();
};
_NbCalendarActionsComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarActionsComponent,
  selectors: [["nb-calendar-actions"]],
  inputs: {
    applyButtonText: "applyButtonText",
    currentTimeButtonText: "currentTimeButtonText",
    showCurrentTimeButton: "showCurrentTimeButton"
  },
  outputs: {
    setCurrentTime: "setCurrentTime",
    saveValue: "saveValue"
  },
  decls: 3,
  vars: 2,
  consts: [["nbButton", "", "ghost", "", "status", "primary", "size", "small", 3, "click", 4, "ngIf"], ["nbButton", "", "status", "primary", "size", "small", 1, "apply-text-button", 3, "click"], ["nbButton", "", "ghost", "", "status", "primary", "size", "small", 3, "click"]],
  template: function NbCalendarActionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbCalendarActionsComponent_button_0_Template, 2, 1, "button", 0);
      ɵɵelementStart(1, "button", 1);
      ɵɵlistener("click", function NbCalendarActionsComponent_Template_button_click_1_listener() {
        return ctx.saveValue.emit();
      });
      ɵɵtext(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.showCurrentTimeButton);
      ɵɵadvance(2);
      ɵɵtextInterpolate1(" ", ctx.applyText, "");
    }
  },
  dependencies: [NgIf, NbButtonComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;justify-content:space-between}[dir=ltr]   [_nghost-%COMP%]   .apply-text-button[_ngcontent-%COMP%]{margin-left:auto}[dir=rtl]   [_nghost-%COMP%]   .apply-text-button[_ngcontent-%COMP%]{margin-right:auto}"],
  changeDetection: 0
});
var NbCalendarActionsComponent = _NbCalendarActionsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarActionsComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-actions",
      template: `
    <button
      *ngIf="showCurrentTimeButton"
      nbButton
      ghost
      status="primary"
      size="small"
      (click)="setCurrentTime.emit()">
      {{ currentTimeText }}</button>
    <button
      class="apply-text-button"
      nbButton
      status="primary"
      size="small"
      (click)="saveValue.emit()">
      {{ applyText }}</button>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;justify-content:space-between}[dir=ltr] :host .apply-text-button{margin-left:auto}[dir=rtl] :host .apply-text-button{margin-right:auto}\n"]
    }]
  }], null, {
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    setCurrentTime: [{
      type: Output
    }],
    saveValue: [{
      type: Output
    }]
  });
})();
var SERVICES = [{
  provide: NbDateService,
  useClass: NbNativeDateService
}, DatePipe, NbCalendarMonthModelService, NbCalendarYearModelService, NbCalendarTimeModelService];
var COMPONENTS$3 = [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent];
var _NbCalendarKitModule = class _NbCalendarKitModule {
};
_NbCalendarKitModule.ɵfac = function NbCalendarKitModule_Factory(t) {
  return new (t || _NbCalendarKitModule)();
};
_NbCalendarKitModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCalendarKitModule,
  declarations: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent],
  imports: [NbSharedModule, NbButtonModule, NbIconModule],
  exports: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent]
});
_NbCalendarKitModule.ɵinj = ɵɵdefineInjector({
  providers: [...SERVICES],
  imports: [NbSharedModule, NbButtonModule, NbIconModule]
});
var NbCalendarKitModule = _NbCalendarKitModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarKitModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbButtonModule, NbIconModule],
      exports: [...COMPONENTS$3],
      declarations: [...COMPONENTS$3],
      providers: [...SERVICES]
    }]
  }], null, null);
})();
var _NbBaseCalendarModule = class _NbBaseCalendarModule {
};
_NbBaseCalendarModule.ɵfac = function NbBaseCalendarModule_Factory(t) {
  return new (t || _NbBaseCalendarModule)();
};
_NbBaseCalendarModule.ɵmod = ɵɵdefineNgModule({
  type: _NbBaseCalendarModule,
  declarations: [NbBaseCalendarComponent],
  imports: [NbCalendarKitModule, NbSharedModule, NbCardModule],
  exports: [NbBaseCalendarComponent]
});
_NbBaseCalendarModule.ɵinj = ɵɵdefineInjector({
  imports: [NbCalendarKitModule, NbSharedModule, NbCardModule]
});
var NbBaseCalendarModule = _NbBaseCalendarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseCalendarModule, [{
    type: NgModule,
    args: [{
      imports: [NbCalendarKitModule, NbSharedModule, NbCardModule],
      exports: [NbBaseCalendarComponent],
      declarations: [NbBaseCalendarComponent]
    }]
  }], null, null);
})();
var _NbCalendarModule = class _NbCalendarModule {
};
_NbCalendarModule.ɵfac = function NbCalendarModule_Factory(t) {
  return new (t || _NbCalendarModule)();
};
_NbCalendarModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCalendarModule,
  declarations: [NbCalendarComponent],
  imports: [NbBaseCalendarModule],
  exports: [NbCalendarComponent]
});
_NbCalendarModule.ɵinj = ɵɵdefineInjector({
  imports: [NbBaseCalendarModule]
});
var NbCalendarModule = _NbCalendarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarModule, [{
    type: NgModule,
    args: [{
      imports: [NbBaseCalendarModule],
      exports: [NbCalendarComponent],
      declarations: [NbCalendarComponent]
    }]
  }], null, null);
})();
var NbBaseCalendarRangeCell = class {
  get hasRange() {
    return !!(this.selectedValue && this.selectedValue.start && this.selectedValue.end);
  }
};
var _NbCalendarRangeDayCellComponent = class _NbCalendarRangeDayCellComponent extends NbBaseCalendarRangeCell {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.rangeCellClass = true;
    this.dayCellClass = true;
  }
  get inRange() {
    if (this.date && this.hasRange) {
      return this.isInRange(this.date, this.selectedValue);
    }
    return false;
  }
  get start() {
    return this.date && this.hasRange && this.dateService.isSameDay(this.date, this.selectedValue.start);
  }
  get end() {
    return this.date && this.hasRange && this.dateService.isSameDay(this.date, this.selectedValue.end);
  }
  get today() {
    return this.date && this.dateService.isSameDay(this.date, this.dateService.today());
  }
  get boundingMonth() {
    return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameDaySafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get empty() {
    return !this.date;
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get day() {
    return this.date && this.dateService.getDate(this.date);
  }
  onClick() {
    if (this.disabled || this.empty) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
  }
  dontFitFilter() {
    return this.date && this.filter && !this.filter(this.date);
  }
  isInRange(date, {
    start,
    end
  }) {
    const isGreaterThanStart = this.dateService.compareDates(this.date, start) >= 0;
    const isLessThanEnd = this.dateService.compareDates(this.date, end) <= 0;
    return isGreaterThanStart && isLessThanEnd;
  }
};
_NbCalendarRangeDayCellComponent.ɵfac = function NbCalendarRangeDayCellComponent_Factory(t) {
  return new (t || _NbCalendarRangeDayCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarRangeDayCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarRangeDayCellComponent,
  selectors: [["nb-calendar-range-day-cell"]],
  hostVars: 22,
  hostBindings: function NbCalendarRangeDayCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarRangeDayCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("in-range", ctx.inRange)("start", ctx.start)("end", ctx.end)("range-cell", ctx.rangeCellClass)("day-cell", ctx.dayCellClass)("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    }
  },
  inputs: {
    date: "date",
    selectedValue: "selectedValue",
    visibleDate: "visibleDate",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarRangeDayCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.day);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarRangeDayCellComponent = _NbCalendarRangeDayCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeDayCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-day-cell",
      template: `
    <div class="cell-content">{{ day }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    start: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    end: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    dayCellClass: [{
      type: HostBinding,
      args: ["class.day-cell"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    boundingMonth: [{
      type: HostBinding,
      args: ["class.bounding-month"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    empty: [{
      type: HostBinding,
      args: ["class.empty"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarRangeYearCellComponent = class _NbCalendarRangeYearCellComponent extends NbBaseCalendarRangeCell {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.yearCellClass = true;
    this.rangeCellClass = true;
  }
  get inRange() {
    return this.hasRange && this.isInRange(this.date, this.selectedValue);
  }
  get rangeStart() {
    return this.hasRange && this.dateService.isSameYear(this.date, this.selectedValue.start);
  }
  get rangeEnd() {
    return this.hasRange && this.dateService.isSameYear(this.date, this.selectedValue.end);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameYearSafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get today() {
    return this.dateService.isSameYear(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get year() {
    return this.dateService.getYear(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
  }
  yearStart() {
    return this.dateService.getYearStart(this.date);
  }
  yearEnd() {
    return this.dateService.getYearEnd(this.date);
  }
  isInRange(date, {
    start,
    end
  }) {
    if (start && end) {
      const cellYear = this.dateService.getYear(date);
      const startYear = this.dateService.getYear(start);
      const endYear = this.dateService.getYear(end);
      return cellYear >= startYear && cellYear <= endYear;
    }
    return this.dateService.isSameYear(date, start);
  }
};
_NbCalendarRangeYearCellComponent.ɵfac = function NbCalendarRangeYearCellComponent_Factory(t) {
  return new (t || _NbCalendarRangeYearCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarRangeYearCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarRangeYearCellComponent,
  selectors: [["nb-calendar-range-year-cell"]],
  hostVars: 18,
  hostBindings: function NbCalendarRangeYearCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarRangeYearCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("in-range", ctx.inRange)("start", ctx.rangeStart)("end", ctx.rangeEnd)("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("year-cell", ctx.yearCellClass)("range-cell", ctx.rangeCellClass);
    }
  },
  inputs: {
    date: "date",
    min: "min",
    max: "max",
    selectedValue: "selectedValue",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarRangeYearCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.year, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarRangeYearCellComponent = _NbCalendarRangeYearCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeYearCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-year-cell",
      template: `
    <div class="cell-content">
      {{ year }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    rangeStart: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    rangeEnd: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    yearCellClass: [{
      type: HostBinding,
      args: ["class.year-cell"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarRangeMonthCellComponent = class _NbCalendarRangeMonthCellComponent extends NbBaseCalendarRangeCell {
  get month() {
    return this.dateService.getMonthName(this.date);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameMonthSafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get inRange() {
    if (this.hasRange) {
      return this.isInRage(this.date, this.selectedValue);
    }
    return false;
  }
  get rangeStart() {
    if (this.hasRange) {
      return this.dateService.isSameMonth(this.date, this.selectedValue.start);
    }
    return false;
  }
  get rangeEnd() {
    if (this.hasRange) {
      return this.dateService.isSameMonth(this.date, this.selectedValue.end);
    }
    return false;
  }
  get today() {
    return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.monthCellClass = true;
    this.rangeCellClass = true;
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
  }
  monthStart() {
    return this.dateService.getMonthStart(this.date);
  }
  monthEnd() {
    return this.dateService.getMonthEnd(this.date);
  }
  isInRage(date, range2) {
    if (range2.start && range2.end) {
      const cellDate = this.dateService.getMonthStart(date);
      const start = this.dateService.getMonthStart(range2.start);
      const end = this.dateService.getMonthStart(range2.end);
      const isGreaterThanStart = this.dateService.compareDates(cellDate, start) >= 0;
      const isLessThanEnd = this.dateService.compareDates(cellDate, end) <= 0;
      return isGreaterThanStart && isLessThanEnd;
    }
    return this.dateService.isSameMonth(date, range2.start);
  }
};
_NbCalendarRangeMonthCellComponent.ɵfac = function NbCalendarRangeMonthCellComponent_Factory(t) {
  return new (t || _NbCalendarRangeMonthCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarRangeMonthCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarRangeMonthCellComponent,
  selectors: [["nb-calendar-range-month-cell"]],
  hostVars: 18,
  hostBindings: function NbCalendarRangeMonthCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarRangeMonthCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("month-cell", ctx.monthCellClass)("range-cell", ctx.rangeCellClass)("selected", ctx.selected)("in-range", ctx.inRange)("start", ctx.rangeStart)("end", ctx.rangeEnd)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    }
  },
  inputs: {
    date: "date",
    visibleDate: "visibleDate",
    selectedValue: "selectedValue",
    min: "min",
    max: "max",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarRangeMonthCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.month, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarRangeMonthCellComponent = _NbCalendarRangeMonthCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeMonthCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-month-cell",
      template: `
    <div class="cell-content">
      {{ month }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    monthCellClass: [{
      type: HostBinding,
      args: ["class.month-cell"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    rangeStart: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    rangeEnd: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarRangeComponent = class _NbCalendarRangeComponent {
  /**
   * Custom day cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.dayCellComponent = cellComponent;
    }
  }
  /**
   * Custom month cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _monthCellComponent(cellComponent) {
    if (cellComponent) {
      this.monthCellComponent = cellComponent;
    }
  }
  /**
   * Custom year cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _yearCellComponent(cellComponent) {
    if (cellComponent) {
      this.yearCellComponent = cellComponent;
    }
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(dateService) {
    this.dateService = dateService;
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.dayCellComponent = NbCalendarRangeDayCellComponent;
    this.monthCellComponent = NbCalendarRangeMonthCellComponent;
    this.yearCellComponent = NbCalendarRangeYearCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.weekNumberSymbol = "#";
    this.rangeChange = new EventEmitter();
  }
  onChange(date) {
    this.initDateIfNull();
    this.handleSelected(date);
  }
  initDateIfNull() {
    if (!this.range) {
      this.range = {
        start: null,
        end: null
      };
    }
  }
  handleSelected(date) {
    if (this.selectionStarted()) {
      this.selectEnd(date);
    } else {
      this.selectStart(date);
    }
  }
  selectionStarted() {
    const {
      start,
      end
    } = this.range;
    return start && !end;
  }
  selectStart(start) {
    this.selectRange({
      start
    });
  }
  selectEnd(date) {
    const {
      start
    } = this.range;
    if (this.dateService.compareDates(date, start) > 0) {
      this.selectRange({
        start,
        end: date
      });
    } else {
      this.selectRange({
        start: date,
        end: start
      });
    }
  }
  selectRange(range2) {
    this.range = range2;
    this.rangeChange.emit(range2);
  }
};
_NbCalendarRangeComponent.ɵfac = function NbCalendarRangeComponent_Factory(t) {
  return new (t || _NbCalendarRangeComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarRangeComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarRangeComponent,
  selectors: [["nb-calendar-range"]],
  inputs: {
    boundingMonth: "boundingMonth",
    startView: "startView",
    min: "min",
    max: "max",
    filter: "filter",
    _cellComponent: [InputFlags.None, "dayCellComponent", "_cellComponent"],
    _monthCellComponent: [InputFlags.None, "monthCellComponent", "_monthCellComponent"],
    monthCellComponent: "monthCellComponent",
    _yearCellComponent: [InputFlags.None, "yearCellComponent", "_yearCellComponent"],
    size: "size",
    visibleDate: "visibleDate",
    showNavigation: "showNavigation",
    range: "range",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    rangeChange: "rangeChange"
  },
  decls: 1,
  vars: 15,
  consts: [[3, "dateChange", "date", "min", "max", "filter", "startView", "boundingMonth", "dayCellComponent", "monthCellComponent", "yearCellComponent", "visibleDate", "showNavigation", "size", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek"]],
  template: function NbCalendarRangeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-base-calendar", 0);
      ɵɵlistener("dateChange", function NbCalendarRangeComponent_Template_nb_base_calendar_dateChange_0_listener($event) {
        return ctx.onChange($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("date", ctx.range)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("startView", ctx.startView)("boundingMonth", ctx.boundingMonth)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("size", ctx.size)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
    }
  },
  dependencies: [NbBaseCalendarComponent],
  encapsulation: 2
});
var NbCalendarRangeComponent = _NbCalendarRangeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range",
      template: `
    <nb-base-calendar
      [date]="range"
      (dateChange)="onChange($any($event))"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [startView]="startView"
      [boundingMonth]="boundingMonth"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [visibleDate]="visibleDate"
      [showNavigation]="showNavigation"
      [size]="size"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
      [firstDayOfWeek]="firstDayOfWeek"
    ></nb-base-calendar>
  `
    }]
  }], () => [{
    type: NbDateService
  }], {
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    _cellComponent: [{
      type: Input,
      args: ["dayCellComponent"]
    }],
    _monthCellComponent: [{
      type: Input,
      args: ["monthCellComponent"]
    }],
    monthCellComponent: [{
      type: Input
    }],
    _yearCellComponent: [{
      type: Input,
      args: ["yearCellComponent"]
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    range: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    rangeChange: [{
      type: Output
    }]
  });
})();
var _NbCalendarRangeModule = class _NbCalendarRangeModule {
};
_NbCalendarRangeModule.ɵfac = function NbCalendarRangeModule_Factory(t) {
  return new (t || _NbCalendarRangeModule)();
};
_NbCalendarRangeModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCalendarRangeModule,
  declarations: [NbCalendarRangeComponent, NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent, NbCalendarRangeMonthCellComponent],
  imports: [NbBaseCalendarModule],
  exports: [NbCalendarRangeComponent]
});
_NbCalendarRangeModule.ɵinj = ɵɵdefineInjector({
  imports: [NbBaseCalendarModule]
});
var NbCalendarRangeModule = _NbCalendarRangeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeModule, [{
    type: NgModule,
    args: [{
      imports: [NbBaseCalendarModule],
      exports: [NbCalendarRangeComponent],
      declarations: [NbCalendarRangeComponent, NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent, NbCalendarRangeMonthCellComponent]
    }]
  }], null, null);
})();
var NB_TIME_PICKER_CONFIG = new InjectionToken("NB_TIME_PICKER_CONFIG");
var NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG = {
  hoursText: "Hr",
  minutesText: "Min",
  secondsText: "Sec",
  ampmText: "Am/Pm"
};
var _NbListComponent = class _NbListComponent {
  constructor() {
    this.role = "list";
  }
};
_NbListComponent.ɵfac = function NbListComponent_Factory(t) {
  return new (t || _NbListComponent)();
};
_NbListComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbListComponent,
  selectors: [["nb-list"]],
  hostVars: 1,
  hostBindings: function NbListComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
    }
  },
  inputs: {
    role: "role"
  },
  ngContentSelectors: _c10,
  decls: 1,
  vars: 0,
  template: function NbListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c9);
      ɵɵprojection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}"]
});
var NbListComponent = _NbListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListComponent, [{
    type: Component,
    args: [{
      selector: "nb-list",
      template: `<ng-content select="nb-list-item"></ng-content>`,
      styles: [":host{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}\n"]
    }]
  }], null, {
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var _NbListItemComponent = class _NbListItemComponent {
  constructor() {
    this.role = "listitem";
  }
};
_NbListItemComponent.ɵfac = function NbListItemComponent_Factory(t) {
  return new (t || _NbListItemComponent)();
};
_NbListItemComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbListItemComponent,
  selectors: [["nb-list-item"]],
  hostVars: 1,
  hostBindings: function NbListItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
    }
  },
  inputs: {
    role: "role"
  },
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbListItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;align-items:center;flex-shrink:0}"]
});
var NbListItemComponent = _NbListItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListItemComponent, [{
    type: Component,
    args: [{
      selector: "nb-list-item",
      template: `<ng-content></ng-content>`,
      styles: [":host{display:flex;align-items:center;flex-shrink:0}\n"]
    }]
  }], null, {
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var _NbTimePickerCellComponent = class _NbTimePickerCellComponent {
  set selected(selected) {
    if (selected) {
      this._selected = selected;
      this.scrollToElement();
    }
    this.selectedChange$.next(selected);
  }
  get selected() {
    return this._selected;
  }
  constructor(ngZone, platformService) {
    this.ngZone = ngZone;
    this.platformService = platformService;
    this.selectedChange$ = new Subject();
    this.unselected$ = this.selectedChange$.pipe(filter((selected) => !selected));
    this.destroy$ = new Subject();
    this.select = new EventEmitter();
  }
  onClick() {
    this.select.emit({
      value: this.value
    });
  }
  ngAfterViewInit() {
    if (this.selected) {
      this.ngZone.onStable.pipe(take(1), takeUntil(merge(this.unselected$, this.destroy$))).subscribe(() => this.scrollToElement());
    }
  }
  scrollToElement() {
    if (this.valueContainerElement && this.platformService.isBrowser) {
      this.ngZone.runOutsideAngular(() => this.valueContainerElement.nativeElement.scrollIntoView({
        block: "center"
      }));
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbTimePickerCellComponent.ɵfac = function NbTimePickerCellComponent_Factory(t) {
  return new (t || _NbTimePickerCellComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbPlatform));
};
_NbTimePickerCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTimePickerCellComponent,
  selectors: [["nb-timepicker-cell"]],
  viewQuery: function NbTimePickerCellComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c11, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.valueContainerElement = _t.first);
    }
  },
  hostBindings: function NbTimePickerCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbTimePickerCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
  },
  inputs: {
    selected: "selected",
    value: "value"
  },
  outputs: {
    select: "select"
  },
  decls: 3,
  vars: 1,
  consts: [["valueContainer", ""]],
  template: function NbTimePickerCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", null, 0);
      ɵɵtext(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.value);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{width:100%;height:100%;display:flex;align-items:center;justify-content:center;-webkit-user-select:none;user-select:none}"],
  changeDetection: 0
});
var NbTimePickerCellComponent = _NbTimePickerCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-timepicker-cell",
      template: `
    <div #valueContainer>{{ value }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{width:100%;height:100%;display:flex;align-items:center;justify-content:center;-webkit-user-select:none;user-select:none}\n"]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: NbPlatform
  }], {
    selected: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    valueContainerElement: [{
      type: ViewChild,
      args: ["valueContainer"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbTimePickerComponent = class _NbTimePickerComponent {
  /**
   * Emits when timepicker looses focus.
   */
  get blur() {
    return this.blur$.asObservable();
  }
  /**
   * Defines time format string.
   * */
  get timeFormat() {
    return this._timeFormat;
  }
  set timeFormat(timeFormat) {
    this._timeFormat = timeFormat;
  }
  /**
   * Defines 12 hours format .
   * */
  get twelveHoursFormat() {
    return this._twelveHoursFormat;
  }
  set twelveHoursFormat(value) {
    this._twelveHoursFormat = convertToBoolProperty(value);
  }
  /**
   * Defines should show am/pm label if twelveHoursFormat enabled.
   * */
  get showAmPmLabel() {
    return this._showAmPmLabel;
  }
  set showAmPmLabel(value) {
    this._showAmPmLabel = convertToBoolProperty(value);
  }
  /**
   * Show seconds in timepicker.
   * Ignored when singleColumn is true
   * */
  get withSeconds() {
    return this._withSeconds;
  }
  set withSeconds(value) {
    this._withSeconds = convertToBoolProperty(value);
  }
  /**
   * Show timepicker values in one column with 60 minutes step by default.
   * */
  get singleColumn() {
    return this._singleColumn;
  }
  set singleColumn(value) {
    this._singleColumn = convertToBoolProperty(value);
  }
  /**
   * Defines minutes offset for options, when timepicker is in single column mode.
   * By default it’s 60 minutes: '12:00, 13:00: 14:00, 15:00...'
   * */
  set step(step) {
    this._step = step;
  }
  get step() {
    return this._step;
  }
  /**
   * Date which will be rendered as selected.
   * */
  set date(date) {
    this._date = date;
    this.isAM = this.dateService.getDayPeriod(this.date) === "AM";
    this.buildColumnOptions();
    this.cd.markForCheck();
  }
  get date() {
    return this._date;
  }
  constructor(config, platformService, locale, cd, calendarTimeModelService, dateService) {
    this.config = config;
    this.platformService = platformService;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
    this.dateService = dateService;
    this.blur$ = new Subject();
    this.dayPeriodColumnOptions = [
      "AM",
      "PM"
      /* NbDayPeriod.PM */
    ];
    this.isAM = true;
    this.timepickerFormatChange$ = new Subject();
    this.computedTimeFormat = this.setupTimeFormat();
    this._showAmPmLabel = true;
    this.showFooter = true;
    this.onSelectTime = new EventEmitter();
    this.initFromConfig(this.config);
  }
  ngOnChanges({
    step,
    twelveHoursFormat,
    withSeconds,
    singleColumn
  }) {
    const nextTimeFormat = this.setupTimeFormat();
    if (nextTimeFormat !== this.computedTimeFormat) {
      this.computedTimeFormat = nextTimeFormat;
      this.timepickerFormatChange$.next();
    }
    const isConfigChanged = step || twelveHoursFormat || withSeconds || singleColumn;
    if (isConfigChanged || !this.fullTimeOptions) {
      this.buildColumnOptions();
    }
  }
  setHost(hostRef) {
    this.hostRef = hostRef;
  }
  attach(hostRef) {
    this.hostRef = hostRef;
  }
  setCurrentTime() {
    this.date = this.dateService.today();
    this.onSelectTime.emit({
      time: this.date,
      save: true
    });
  }
  setHour(value) {
    this.updateValue(this.dateService.setHours(this.date, value));
  }
  setMinute(value) {
    this.updateValue(this.dateService.setMinutes(this.date, value));
  }
  setSecond(value) {
    this.updateValue(this.dateService.setSeconds(this.date, value));
  }
  selectFullTime(value) {
    this.updateValue(value);
  }
  changeDayPeriod(dayPeriodToSet) {
    if (this.dateService.getDayPeriod(this.date) === dayPeriodToSet) {
      return;
    }
    const direction = dayPeriodToSet === "AM" ? -1 : 1;
    const increment = direction * this.dateService.HOURS_IN_DAY_PERIOD;
    this.updateValue(this.dateService.addHours(this.date, increment));
  }
  updateValue(date) {
    this.onSelectTime.emit({
      time: date
    });
  }
  saveValue() {
    this.onSelectTime.emit({
      time: this.date,
      save: true
    });
  }
  trackByTimeValues(index, item) {
    return item.value;
  }
  trackBySingleColumnValue(index, item) {
    return this.dateService.valueOf(item);
  }
  trackByDayPeriod(index, item) {
    return item;
  }
  showSeconds() {
    return this.withSeconds && !this.singleColumn;
  }
  isSelectedHour(val) {
    if (this.date) {
      return this.dateService.getHours(this.date) === val;
    }
    return false;
  }
  isSelectedMinute(val) {
    if (this.date) {
      return this.dateService.getMinutes(this.date) === val;
    }
    return false;
  }
  isSelectedSecond(val) {
    if (this.date) {
      return this.dateService.getSeconds(this.date) === val;
    }
    return false;
  }
  isSelectedDayPeriod(dayPeriod) {
    if (this.date) {
      return dayPeriod === this.dateService.getDayPeriod(this.date);
    }
    return false;
  }
  getFullTimeString(item) {
    return this.dateService.format(item, this.computedTimeFormat).toUpperCase();
  }
  isSelectedFullTimeValue(value) {
    if (this.date) {
      return this.dateService.isSameHourAndMinute(value, this.date);
    }
    return false;
  }
  buildColumnOptions() {
    this.fullTimeOptions = this.singleColumn ? this.calendarTimeModelService.getHoursRange(this.step) : [];
    this.hoursColumnOptions = this.generateHours();
    this.minutesColumnOptions = this.generateMinutesOrSeconds();
    this.secondsColumnOptions = this.showSeconds() ? this.generateMinutesOrSeconds() : [];
  }
  /**
   * @docs-private
   */
  isFirefox() {
    return this.platformService.FIREFOX;
  }
  generateHours() {
    if (!this.twelveHoursFormat) {
      return range(24, (v) => {
        return {
          value: v,
          text: this.calendarTimeModelService.paddToTwoSymbols(v)
        };
      });
    }
    if (this.isAM) {
      return range(12, (v) => {
        const text = v === 0 ? 12 : v;
        return {
          value: v,
          text: this.calendarTimeModelService.paddToTwoSymbols(text)
        };
      });
    }
    return rangeFromTo(12, 24, (v) => {
      const text = v === 12 ? 12 : v - 12;
      return {
        value: v,
        text: this.calendarTimeModelService.paddToTwoSymbols(text)
      };
    });
  }
  generateMinutesOrSeconds() {
    return range(60, (v) => {
      return {
        value: v,
        text: this.calendarTimeModelService.paddToTwoSymbols(v)
      };
    });
  }
  setupTimeFormat() {
    if (!this.timeFormat) {
      return this.config.format || this.buildTimeFormat();
    }
    return this.timeFormat;
  }
  /**
   * @docs-private
   */
  buildTimeFormat() {
    if (this.twelveHoursFormat) {
      return `${this.withSeconds && !this.singleColumn ? this.dateService.getTwelveHoursFormatWithSeconds() : this.dateService.getTwelveHoursFormat()}`;
    } else {
      return `${this.withSeconds && !this.singleColumn ? this.dateService.getTwentyFourHoursFormatWithSeconds() : this.dateService.getTwentyFourHoursFormat()}`;
    }
  }
  initFromConfig(config) {
    if (config) {
      this.twelveHoursFormat = config.twelveHoursFormat;
    } else {
      this.twelveHoursFormat = this.dateService.getLocaleTimeFormat().includes("h");
    }
    const localeConfig = __spreadValues(__spreadValues({}, NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG), config?.localization ?? {});
    this.hoursText = localeConfig.hoursText;
    this.minutesText = localeConfig.minutesText;
    this.secondsText = localeConfig.secondsText;
    this.ampmText = localeConfig.ampmText;
  }
};
_NbTimePickerComponent.ɵfac = function NbTimePickerComponent_Factory(t) {
  return new (t || _NbTimePickerComponent)(ɵɵdirectiveInject(NB_TIME_PICKER_CONFIG), ɵɵdirectiveInject(NbPlatform), ɵɵdirectiveInject(LOCALE_ID), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbCalendarTimeModelService), ɵɵdirectiveInject(NbDateService));
};
_NbTimePickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTimePickerComponent,
  selectors: [["nb-timepicker"]],
  viewQuery: function NbTimePickerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
    }
  },
  inputs: {
    timeFormat: "timeFormat",
    twelveHoursFormat: "twelveHoursFormat",
    showAmPmLabel: "showAmPmLabel",
    withSeconds: "withSeconds",
    singleColumn: "singleColumn",
    step: "step",
    date: "date",
    showFooter: "showFooter",
    applyButtonText: "applyButtonText",
    hoursText: "hoursText",
    minutesText: "minutesText",
    secondsText: "secondsText",
    ampmText: "ampmText",
    currentTimeButtonText: "currentTimeButtonText"
  },
  outputs: {
    onSelectTime: "onSelectTime"
  },
  exportAs: ["nbTimepicker"],
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 0,
  consts: [["fullTimeHeadersBlock", ""], ["fullTimeColumnBlock", ""], ["class", "nb-timepicker-container", 3, "supports-scrollbar-theming", 4, "nbPortal"], [1, "nb-timepicker-container"], [1, "column-header"], [4, "ngIf", "ngIfElse"], [1, "picker-body"], ["class", "actions-footer", 4, "ngIf"], [1, "header-cell"], ["class", "header-cell", 4, "ngIf"], [3, "ngIf"], [1, "values-list"], ["class", "list-item", 3, "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "list-item"], [3, "select", "value", "selected"], ["class", "values-list", 4, "ngIf"], ["class", "list-item am-pm-item", 3, "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "list-item", "am-pm-item"], [1, "actions-footer"], [3, "setCurrentTime", "saveValue", "applyButtonText", "currentTimeButtonText"]],
  template: function NbTimePickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbTimePickerComponent_nb_card_0_Template, 10, 7, "nb-card", 2);
    }
  },
  dependencies: [NgForOf, NgIf, NbPortalDirective, NbListComponent, NbListItemComponent, NbCardComponent, NbCardFooterComponent, NbCardHeaderComponent, NbCalendarActionsComponent, NbTimePickerCellComponent],
  styles: ["\n\n\n\n\n.nb-timepicker-container[_ngcontent-%COMP%]{overflow:hidden;margin-bottom:0}.values-list[_ngcontent-%COMP%]{width:100%;overflow:hidden;scroll-snap-type:y proximity}.values-list[_ngcontent-%COMP%]:hover{overflow-y:auto}.list-item[_ngcontent-%COMP%]{border:0;padding:0;cursor:pointer}.picker-body[_ngcontent-%COMP%]{display:flex;width:100%;flex:1 0 0;overflow:hidden}.column-header[_ngcontent-%COMP%]{width:100%;display:flex;justify-content:space-between;padding:0}.header-cell[_ngcontent-%COMP%]{width:100%;display:flex;align-items:center;justify-content:center}.actions-footer[_ngcontent-%COMP%]{width:100%}nb-card-header[_ngcontent-%COMP%], nb-card-footer[_ngcontent-%COMP%]{flex:0 0 auto}"],
  changeDetection: 0
});
var NbTimePickerComponent = _NbTimePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-timepicker",
      exportAs: "nbTimepicker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<nb-card *nbPortal [class.supports-scrollbar-theming]="!isFirefox()" class="nb-timepicker-container">\n  <nb-card-header class="column-header">\n    <ng-container *ngIf="singleColumn; else fullTimeHeadersBlock">\n      <div class="header-cell">Time</div>\n    </ng-container>\n    <ng-template #fullTimeHeadersBlock>\n      <div class="header-cell">{{ hoursText }}</div>\n      <div class="header-cell">{{ minutesText }}</div>\n      <div *ngIf="withSeconds" class="header-cell">{{ secondsText }}</div>\n      <div *ngIf="twelveHoursFormat" class="header-cell">\n        <ng-template [ngIf]="showAmPmLabel">{{ ampmText }}</ng-template>\n      </div>\n    </ng-template>\n  </nb-card-header>\n\n  <div class="picker-body">\n    <ng-container *ngIf="singleColumn; else fullTimeColumnBlock">\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedFullTimeValue(item)"\n          *ngFor="let item of fullTimeOptions; trackBy: trackBySingleColumnValue.bind(this)"\n        >\n          <nb-timepicker-cell\n            [value]="getFullTimeString(item)"\n            [selected]="isSelectedFullTimeValue(item)"\n            (select)="selectFullTime(item)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n    </ng-container>\n\n    <ng-template #fullTimeColumnBlock>\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedHour(item.value)"\n          *ngFor="let item of hoursColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedHour(item.value)"\n            (select)="setHour(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedMinute(item.value)"\n          *ngFor="let item of minutesColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedMinute(item.value)"\n            (select)="setMinute(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list *ngIf="showSeconds()" class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedSecond(item.value)"\n          *ngFor="let item of secondsColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedSecond(item.value)"\n            (select)="setSecond(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list *ngIf="twelveHoursFormat" class="values-list">\n        <nb-list-item\n          class="list-item am-pm-item"\n          [class.selected]="isSelectedDayPeriod(dayPeriod)"\n          *ngFor="let dayPeriod of dayPeriodColumnOptions; trackBy: trackByDayPeriod"\n        >\n          <nb-timepicker-cell\n            [value]="dayPeriod"\n            [selected]="isSelectedDayPeriod(dayPeriod)"\n            (select)="changeDayPeriod(dayPeriod)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n    </ng-template>\n  </div>\n\n  <nb-card-footer *ngIf="showFooter" class="actions-footer">\n    <nb-calendar-actions\n      [applyButtonText]="applyButtonText"\n      [currentTimeButtonText]="currentTimeButtonText"\n      (setCurrentTime)="setCurrentTime()"\n      (saveValue)="saveValue()"\n    ></nb-calendar-actions>\n  </nb-card-footer>\n</nb-card>\n',
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */.nb-timepicker-container{overflow:hidden;margin-bottom:0}.values-list{width:100%;overflow:hidden;scroll-snap-type:y proximity}.values-list:hover{overflow-y:auto}.list-item{border:0;padding:0;cursor:pointer}.picker-body{display:flex;width:100%;flex:1 0 0;overflow:hidden}.column-header{width:100%;display:flex;justify-content:space-between;padding:0}.header-cell{width:100%;display:flex;align-items:center;justify-content:center}.actions-footer{width:100%}nb-card-header,nb-card-footer{flex:0 0 auto}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TIME_PICKER_CONFIG]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }, {
    type: NbDateService
  }], {
    timeFormat: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    hoursText: [{
      type: Input
    }],
    minutesText: [{
      type: Input
    }],
    secondsText: [{
      type: Input
    }],
    ampmText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    onSelectTime: [{
      type: Output
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective, {
        static: true
      }]
    }]
  });
})();
var _NbCalendarWithTimeComponent = class _NbCalendarWithTimeComponent extends NbCalendarComponent {
  constructor(dateService, cd, calendarTimeModelService) {
    super();
    this.dateService = dateService;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
  }
  ngOnInit() {
    if (!this.date) {
      this.date = this.calendarTimeModelService.getResetTime();
    }
  }
  ngAfterViewInit() {
    this.portalOutlet.attachTemplatePortal(this.timepicker.portal);
  }
  onDateValueChange(date) {
    const hours = this.dateService.getHours(this.date);
    const minutes = this.dateService.getMinutes(this.date);
    const seconds = this.dateService.getSeconds(this.date);
    const milliseconds = this.dateService.getMilliseconds(this.date);
    let newDate = this.dateService.setHours(date, hours);
    newDate = this.dateService.setMinutes(newDate, minutes);
    newDate = this.dateService.setMinutes(newDate, minutes);
    newDate = this.dateService.setSeconds(newDate, seconds);
    newDate = this.dateService.setMilliseconds(newDate, milliseconds);
    this.date = newDate;
  }
  onTimeChange(selectedTime) {
    let newDate = this.dateService.clone(this.date);
    newDate = this.dateService.setHours(newDate, this.dateService.getHours(selectedTime.time));
    newDate = this.dateService.setMinutes(newDate, this.dateService.getMinutes(selectedTime.time));
    newDate = this.dateService.setSeconds(newDate, this.dateService.getSeconds(selectedTime.time));
    newDate = this.dateService.setMilliseconds(newDate, this.dateService.getMilliseconds(selectedTime.time));
    this.date = newDate;
  }
  saveValue() {
    this.dateChange.emit(this.date);
  }
  saveCurrentTime() {
    this.dateChange.emit(this.dateService.today());
  }
  showSeconds() {
    return this.withSeconds && !this.singleColumn;
  }
  isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
};
_NbCalendarWithTimeComponent.ɵfac = function NbCalendarWithTimeComponent_Factory(t) {
  return new (t || _NbCalendarWithTimeComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbCalendarTimeModelService));
};
_NbCalendarWithTimeComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarWithTimeComponent,
  selectors: [["nb-calendar-with-time"]],
  viewQuery: function NbCalendarWithTimeComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalOutletDirective, 5);
      ɵɵviewQuery(NbTimePickerComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timepicker = _t.first);
    }
  },
  inputs: {
    visibleDate: "visibleDate",
    twelveHoursFormat: "twelveHoursFormat",
    showAmPmLabel: "showAmPmLabel",
    withSeconds: "withSeconds",
    singleColumn: "singleColumn",
    step: "step",
    timeFormat: "timeFormat",
    title: "title",
    applyButtonText: "applyButtonText",
    currentTimeButtonText: "currentTimeButtonText",
    showCurrentTimeButton: "showCurrentTimeButton"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 10,
  vars: 32,
  consts: [[1, "calendar-with-time"], [1, "picker-body"], [3, "dateChange", "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showNavigation", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek"], [1, "timepicker-section"], [1, "picker-title"], [3, "onSelectTime", "date", "twelveHoursFormat", "showAmPmLabel", "withSeconds", "showFooter", "singleColumn", "step"], ["nbPortalOutlet", ""], [1, "picker-footer"], [3, "setCurrentTime", "saveValue", "applyButtonText", "currentTimeButtonText", "showCurrentTimeButton"]],
  template: function NbCalendarWithTimeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-card", 0)(1, "nb-card-body", 1)(2, "nb-base-calendar", 2);
      ɵɵlistener("dateChange", function NbCalendarWithTimeComponent_Template_nb_base_calendar_dateChange_2_listener($event) {
        return ctx.onDateValueChange($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 3)(4, "div", 4);
      ɵɵtext(5);
      ɵɵelementEnd();
      ɵɵelementStart(6, "nb-timepicker", 5);
      ɵɵlistener("onSelectTime", function NbCalendarWithTimeComponent_Template_nb_timepicker_onSelectTime_6_listener($event) {
        return ctx.onTimeChange($event);
      });
      ɵɵelementEnd();
      ɵɵelementContainer(7, 6);
      ɵɵelementEnd()();
      ɵɵelementStart(8, "nb-card-footer", 7)(9, "nb-calendar-actions", 8);
      ɵɵlistener("setCurrentTime", function NbCalendarWithTimeComponent_Template_nb_calendar_actions_setCurrentTime_9_listener() {
        return ctx.saveCurrentTime();
      })("saveValue", function NbCalendarWithTimeComponent_Template_nb_calendar_actions_saveValue_9_listener() {
        return ctx.saveValue();
      });
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
      ɵɵadvance();
      ɵɵclassProp("size-large", ctx.isLarge())("timepicker-single-column-width", ctx.singleColumn)("timepicker-multiple-column-width", !ctx.singleColumn);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.title);
      ɵɵadvance();
      ɵɵproperty("date", ctx.date)("twelveHoursFormat", ctx.twelveHoursFormat)("showAmPmLabel", ctx.showAmPmLabel)("withSeconds", ctx.showSeconds())("showFooter", false)("singleColumn", ctx.singleColumn)("step", ctx.step);
      ɵɵadvance(3);
      ɵɵproperty("applyButtonText", ctx.applyButtonText)("currentTimeButtonText", ctx.currentTimeButtonText)("showCurrentTimeButton", ctx.showCurrentTimeButton);
    }
  },
  dependencies: [NbPortalOutletDirective, NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbBaseCalendarComponent, NbTimePickerComponent, NbCalendarActionsComponent],
  styles: ["\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]     nb-card.nb-timepicker-container{flex:1 0 0;border-radius:0;width:auto;border-right:0;border-bottom:0}[dir=ltr]   [_nghost-%COMP%]   .picker-footer[_ngcontent-%COMP%]{padding-left:.625rem}[dir=rtl]   [_nghost-%COMP%]   .picker-footer[_ngcontent-%COMP%]{padding-right:.625rem}.picker-body[_ngcontent-%COMP%]{align-items:stretch;display:flex;padding:0}.picker-body[_ngcontent-%COMP%]   nb-base-calendar[_ngcontent-%COMP%]     nb-card{border-radius:0}.calendar-with-time[_ngcontent-%COMP%]{overflow:hidden}.timepicker-section[_ngcontent-%COMP%]{display:flex;flex-direction:column}"],
  changeDetection: 0
});
var NbCalendarWithTimeComponent = _NbCalendarWithTimeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarWithTimeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-with-time",
      template: `
    <nb-card class="calendar-with-time">
      <nb-card-body class="picker-body">
        <nb-base-calendar
          [boundingMonth]="boundingMonth"
          [startView]="startView"
          [date]="date"
          [min]="min"
          [max]="max"
          [filter]="filter"
          [dayCellComponent]="dayCellComponent"
          [monthCellComponent]="monthCellComponent"
          [yearCellComponent]="yearCellComponent"
          [size]="size"
          [visibleDate]="visibleDate"
          [showNavigation]="showNavigation"
          [showWeekNumber]="showWeekNumber"
          [weekNumberSymbol]="weekNumberSymbol"
          [firstDayOfWeek]="firstDayOfWeek"
          (dateChange)="onDateValueChange($event)"
        >
        </nb-base-calendar>
        <div
          class="timepicker-section"
          [class.size-large]="isLarge()"
          [class.timepicker-single-column-width]="singleColumn"
          [class.timepicker-multiple-column-width]="!singleColumn"
        >
          <div class="picker-title">{{ title }}</div>
          <nb-timepicker
            (onSelectTime)="onTimeChange($event)"
            [date]="date"
            [twelveHoursFormat]="twelveHoursFormat"
            [showAmPmLabel]="showAmPmLabel"
            [withSeconds]="showSeconds()"
            [showFooter]="false"
            [singleColumn]="singleColumn"
            [step]="step"
          >
          </nb-timepicker>
          <ng-container nbPortalOutlet></ng-container>
        </div>
      </nb-card-body>
      <nb-card-footer class="picker-footer">
        <nb-calendar-actions
          [applyButtonText]="applyButtonText"
          [currentTimeButtonText]="currentTimeButtonText"
          [showCurrentTimeButton]="showCurrentTimeButton"
          (setCurrentTime)="saveCurrentTime()"
          (saveValue)="saveValue()"
        ></nb-calendar-actions>
      </nb-card-footer>
    </nb-card>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n*//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host ::ng-deep nb-card.nb-timepicker-container{flex:1 0 0;border-radius:0;width:auto;border-right:0;border-bottom:0}[dir=ltr] :host .picker-footer{padding-left:.625rem}[dir=rtl] :host .picker-footer{padding-right:.625rem}.picker-body{align-items:stretch;display:flex;padding:0}.picker-body nb-base-calendar ::ng-deep nb-card{border-radius:0}.calendar-with-time{overflow:hidden}.timepicker-section{display:flex;flex-direction:column}\n"]
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }], {
    visibleDate: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective]
    }],
    timepicker: [{
      type: ViewChild,
      args: [NbTimePickerComponent]
    }]
  });
})();
var _NbDatepickerContainerComponent = class _NbDatepickerContainerComponent extends NbPositionedContainerComponent {
  attach(portal) {
    return this.overlayContainer.attachComponentPortal(portal);
  }
};
_NbDatepickerContainerComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbDatepickerContainerComponent_BaseFactory;
  return function NbDatepickerContainerComponent_Factory(t) {
    return (ɵNbDatepickerContainerComponent_BaseFactory || (ɵNbDatepickerContainerComponent_BaseFactory = ɵɵgetInheritedFactory(_NbDatepickerContainerComponent)))(t || _NbDatepickerContainerComponent);
  };
})();
_NbDatepickerContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbDatepickerContainerComponent,
  selectors: [["nb-datepicker-container"]],
  viewQuery: function NbDatepickerContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbOverlayContainerComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 0,
  template: function NbDatepickerContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "nb-overlay-container");
    }
  },
  dependencies: [NbOverlayContainerComponent],
  encapsulation: 2
});
var NbDatepickerContainerComponent = _NbDatepickerContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-datepicker-container",
      template: `
    <nb-overlay-container></nb-overlay-container>
  `
    }]
  }], null, {
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent, {
        static: true
      }]
    }]
  });
})();
var NbDatepickerAdapter = class {
};
var NbDatepicker = class {
};
var NB_DATE_ADAPTER = new InjectionToken("Datepicker Adapter");
var NB_DATE_SERVICE_OPTIONS = new InjectionToken("Date service options");
var _NbDatepickerDirective = class _NbDatepickerDirective {
  /**
   * Provides datepicker component.
   * */
  // eslint-disable-next-line @angular-eslint/no-input-rename
  set setPicker(picker) {
    this.picker = picker;
    this.setupPicker();
  }
  constructor(document2, datepickerAdapters, hostRef, dateService, changeDetector) {
    this.document = document2;
    this.datepickerAdapters = datepickerAdapters;
    this.hostRef = hostRef;
    this.dateService = dateService;
    this.changeDetector = changeDetector;
    this.destroy$ = new Subject();
    this.isDatepickerReady = false;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.validator = Validators.compose([this.parseValidator, this.minValidator, this.maxValidator, this.filterValidator].map((fn) => fn.bind(this)));
    this.subscribeOnInputChange();
  }
  /**
   * Returns html input element.
   * */
  get input() {
    return this.hostRef.nativeElement;
  }
  /**
   * Returns host input value.
   * */
  get inputValue() {
    return this.input.value;
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Writes value in picker and html input element.
   * */
  writeValue(value) {
    if (this.isDatepickerReady) {
      this.writePicker(value);
      this.writeInput(value);
    } else {
      this.queue = value;
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.input.disabled = isDisabled;
  }
  /**
   * Form control validation based on picker validator config.
   * */
  validate() {
    return this.validator(null);
  }
  /**
   * Hides picker, focuses the input
   */
  hidePicker() {
    this.input.focus();
    this.picker.hide();
  }
  /**
   * Validates that we can parse value correctly.
   * */
  parseValidator() {
    if (this.inputValue === "") {
      return null;
    }
    const isValid = this.datepickerAdapter.isValid(this.inputValue, this.picker.format);
    return isValid ? null : {
      nbDatepickerParse: {
        value: this.inputValue
      }
    };
  }
  /**
   * Validates passed value is greater than min.
   * */
  minValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.min || !date || this.dateService.compareDates(config.min, date) <= 0 ? null : {
      nbDatepickerMin: {
        min: config.min,
        actual: date
      }
    };
  }
  /**
   * Validates passed value is smaller than max.
   * */
  maxValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.max || !date || this.dateService.compareDates(config.max, date) >= 0 ? null : {
      nbDatepickerMax: {
        max: config.max,
        actual: date
      }
    };
  }
  /**
   * Validates passed value satisfy the filter.
   * */
  filterValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.filter || !date || config.filter(date) ? null : {
      nbDatepickerFilter: true
    };
  }
  /**
   * Chooses datepicker adapter based on passed picker component.
   * */
  chooseDatepickerAdapter() {
    this.datepickerAdapter = this.datepickerAdapters.find(({
      picker
    }) => this.picker instanceof picker);
    if (this.noDatepickerAdapterProvided()) {
      throw new Error("No datepickerAdapter provided for picker");
    }
  }
  /**
   * Attaches picker to the host input element and subscribes on value changes.
   * */
  setupPicker() {
    this.chooseDatepickerAdapter();
    this.picker.attach(this.hostRef);
    if (this.inputValue) {
      this.picker.value = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    }
    this.pickerInputsChangedSubscription?.unsubscribe();
    this.pickerInputsChangedSubscription = this.picker.formatChanged$.pipe(map(() => this.picker.format), startWith(this.picker.format), distinctUntilChanged(), pairwise(), takeUntil(this.destroy$)).subscribe(([prevFormat, nextFormat]) => {
      if (this.inputValue) {
        const date = this.datepickerAdapter.parse(this.inputValue, prevFormat);
        this.writeInput(date);
      }
    });
    if (!this.isDatepickerReady) {
      this.picker.init.pipe(take(1), tap(() => this.isDatepickerReady = true), filter(() => !!this.queue), takeUntil(this.destroy$)).subscribe(() => {
        this.writeValue(this.queue);
        this.changeDetector.detectChanges();
        this.queue = void 0;
      });
    }
    this.picker.valueChange.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      this.writePicker(value);
      this.writeInput(value);
      this.onChange(value);
      if (this.picker.shouldHide()) {
        this.hidePicker();
      }
    });
    merge(this.picker.blur, fromEvent(this.input, "blur").pipe(filter(() => !this.picker.isShown && this.document.activeElement !== this.input))).pipe(takeUntil(this.destroy$)).subscribe(() => this.onTouched());
  }
  writePicker(value) {
    this.picker.value = value;
  }
  writeInput(value) {
    this.hostRef.nativeElement.value = this.datepickerAdapter.format(value, this.picker.format);
  }
  /**
   * Validates if no datepicker adapter provided.
   * */
  noDatepickerAdapterProvided() {
    return !this.datepickerAdapter || !(this.datepickerAdapter instanceof NbDatepickerAdapter);
  }
  subscribeOnInputChange() {
    fromEvent(this.input, "input").pipe(map(() => this.inputValue), takeUntil(this.destroy$)).subscribe((value) => this.handleInputChange(value));
  }
  /**
   * Parses input value and write if it isn't null.
   * */
  handleInputChange(value) {
    const date = this.parseInputValue(value);
    this.onChange(date);
    this.writePicker(date);
  }
  parseInputValue(value) {
    if (this.datepickerAdapter.isValid(value, this.picker.format)) {
      return this.datepickerAdapter.parse(value, this.picker.format);
    }
    return null;
  }
};
_NbDatepickerDirective.ɵfac = function NbDatepickerDirective_Factory(t) {
  return new (t || _NbDatepickerDirective)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NB_DATE_ADAPTER), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbDatepickerDirective.ɵdir = ɵɵdefineDirective({
  type: _NbDatepickerDirective,
  selectors: [["input", "nbDatepicker", ""]],
  inputs: {
    setPicker: [InputFlags.None, "nbDatepicker", "setPicker"]
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbDatepickerDirective),
    multi: true
  }, {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => _NbDatepickerDirective),
    multi: true
  }])]
});
var NbDatepickerDirective = _NbDatepickerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbDatepicker]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbDatepickerDirective),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => NbDatepickerDirective),
        multi: true
      }]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DATE_ADAPTER]
    }]
  }, {
    type: ElementRef
  }, {
    type: NbDateService
  }, {
    type: ChangeDetectorRef
  }], {
    setPicker: [{
      type: Input,
      args: ["nbDatepicker"]
    }]
  });
})();
var NbBasePicker = class extends NbDatepicker {
  constructor(overlay, positionBuilder, triggerStrategyBuilder, cfr, dateService, dateServiceOptions) {
    super();
    this.overlay = overlay;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cfr = cfr;
    this.dateService = dateService;
    this.dateServiceOptions = dateServiceOptions;
    this.formatChanged$ = new Subject();
    this.init$ = new ReplaySubject();
    this.onChange$ = new Subject();
    this.overlayOffset = 8;
    this.adjustment = NbAdjustment.COUNTERCLOCKWISE;
    this.destroy$ = new Subject();
    this.blur$ = new Subject();
  }
  /**
   * Returns picker instance.
   * */
  get picker() {
    return this.pickerRef && this.pickerRef.instance;
  }
  /**
   * Stream of picker value changes.
   * */
  get valueChange() {
    return this.onChange$.asObservable();
  }
  get isShown() {
    return this.ref && this.ref.hasAttached();
  }
  get init() {
    return this.init$.asObservable();
  }
  /**
   * Emits when datepicker looses focus.
   */
  get blur() {
    return this.blur$.asObservable();
  }
  /**
   * Datepicker knows nothing about host html input element.
   * So, attach method attaches datepicker to the host input element.
   * */
  attach(hostRef) {
    this.hostRef = hostRef;
    this.subscribeOnTriggers();
  }
  getValidatorConfig() {
    return {
      min: this.min,
      max: this.max,
      filter: this.filter
    };
  }
  show() {
    if (!this.ref) {
      this.createOverlay();
    }
    this.openDatepicker();
  }
  shouldHide() {
    return this.hideOnSelect && !!this.value;
  }
  hide() {
    if (this.ref) {
      this.ref.detach();
    }
    if (this.picker) {
      this.queue = this.value;
      this.pickerRef.destroy();
      this.pickerRef = null;
      this.container = null;
    }
  }
  createOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy: this.overlay.scrollStrategies.reposition()
    });
    this.subscribeOnPositionChange();
  }
  openDatepicker() {
    this.container = this.ref.attach(new NbComponentPortal(NbDatepickerContainerComponent, null, null, this.cfr));
    this.instantiatePicker();
    this.subscribeOnValueChange();
    this.writeQueue();
    this.patchWithInputs();
    this.pickerRef.changeDetectorRef.markForCheck();
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(this.adjustment);
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => patch(this.container, {
      position
    }));
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.container).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.subscribe(() => {
      this.blur$.next();
      this.hide();
    });
  }
  instantiatePicker() {
    this.pickerRef = this.container.instance.attach(new NbComponentPortal(this.pickerClass, null, null, this.cfr));
  }
  /**
   * Subscribes on picker value changes and emit data through this.onChange$ subject.
   * */
  subscribeOnValueChange() {
    this.pickerValueChange.subscribe((date) => {
      this.onChange$.next(date);
    });
  }
  patchWithInputs() {
    this.picker.boundingMonth = this.boundingMonth;
    this.picker.startView = this.startView;
    this.picker.min = this.min;
    this.picker.max = this.max;
    this.picker.filter = this.filter;
    this.picker._cellComponent = this.dayCellComponent;
    this.picker._monthCellComponent = this.monthCellComponent;
    this.picker._yearCellComponent = this.yearCellComponent;
    this.picker.size = this.size;
    this.picker.showNavigation = this.showNavigation;
    this.picker.visibleDate = this.visibleDate;
    this.picker.showWeekNumber = this.showWeekNumber;
    this.picker.weekNumberSymbol = this.weekNumberSymbol;
    this.picker.firstDayOfWeek = this.firstDayOfWeek;
  }
  checkFormat() {
    if (this.dateService.getId() === "native" && this.format) {
      throw new Error(`Can't format native date. To use custom formatting you have to install @nebular/moment or @nebular/date-fns package and import NbMomentDateModule or NbDateFnsDateModule accordingly.More information at "Formatting issue" https://akveo.github.io/nebular/docs/components/datepicker/overview#nbdatepickercomponent`);
    }
    const isFormatSet = this.format || this.dateServiceOptions && this.dateServiceOptions.format;
    if (this.dateService.getId() === "date-fns" && !isFormatSet) {
      throw new Error("format is required when using NbDateFnsDateModule");
    }
  }
};
var _NbBasePickerComponent = class _NbBasePickerComponent extends NbBasePicker {
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(document2, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions) {
    super(overlay, positionBuilder, triggerStrategyBuilder, cfr, dateService, dateServiceOptions);
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.hideOnSelect = true;
    this.showNavigation = true;
    this.weekNumberSymbol = "#";
    this._showWeekNumber = false;
    this.overlayOffset = 8;
    this.adjustment = NbAdjustment.COUNTERCLOCKWISE;
  }
  ngOnInit() {
    this.checkFormat();
    this.init$.next();
  }
  ngOnChanges(changes) {
    if (changes.format) {
      if (!changes.format.isFirstChange()) {
        this.checkFormat();
      }
      this.formatChanged$.next();
    }
    if (this.picker) {
      this.patchWithInputs();
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.hide();
    this.init$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  get pickerValueChange() {
    return void 0;
  }
  get value() {
    return void 0;
  }
  set value(value) {
  }
  writeQueue() {
  }
};
_NbBasePickerComponent.ɵfac = function NbBasePickerComponent_Factory(t) {
  return new (t || _NbBasePickerComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NB_DATE_SERVICE_OPTIONS, 8));
};
_NbBasePickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbBasePickerComponent,
  selectors: [["ng-component"]],
  inputs: {
    format: "format",
    boundingMonth: "boundingMonth",
    startView: "startView",
    min: "min",
    max: "max",
    filter: "filter",
    dayCellComponent: "dayCellComponent",
    monthCellComponent: "monthCellComponent",
    yearCellComponent: "yearCellComponent",
    size: "size",
    visibleDate: "visibleDate",
    hideOnSelect: "hideOnSelect",
    showNavigation: "showNavigation",
    weekNumberSymbol: "weekNumberSymbol",
    showWeekNumber: "showWeekNumber",
    firstDayOfWeek: "firstDayOfWeek",
    overlayOffset: "overlayOffset",
    adjustment: "adjustment"
  },
  features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  decls: 0,
  vars: 0,
  template: function NbBasePickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbBasePickerComponent = _NbBasePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBasePickerComponent, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: NbDateService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_DATE_SERVICE_OPTIONS]
    }]
  }], {
    format: [{
      type: Input
    }],
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    hideOnSelect: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    overlayOffset: [{
      type: Input
    }],
    adjustment: [{
      type: Input
    }]
  });
})();
var _NbDatepickerComponent = class _NbDatepickerComponent extends NbBasePickerComponent {
  constructor() {
    super(...arguments);
    this.pickerClass = NbCalendarComponent;
  }
  /**
   * Date which will be rendered as selected.
   * */
  set date(date) {
    this.value = date;
  }
  /**
   * Emits date when selected.
   * */
  get dateChange() {
    return this.valueChange;
  }
  get value() {
    return this.picker ? this.picker.date : void 0;
  }
  set value(date) {
    if (!this.picker) {
      this.queue = date;
      return;
    }
    if (date) {
      this.visibleDate = date;
      this.picker.visibleDate = date;
      this.picker.date = date;
    }
  }
  get pickerValueChange() {
    return this.picker.dateChange;
  }
  writeQueue() {
    if (this.queue) {
      const date = this.queue;
      this.queue = null;
      this.value = date;
    }
  }
};
_NbDatepickerComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbDatepickerComponent_BaseFactory;
  return function NbDatepickerComponent_Factory(t) {
    return (ɵNbDatepickerComponent_BaseFactory || (ɵNbDatepickerComponent_BaseFactory = ɵɵgetInheritedFactory(_NbDatepickerComponent)))(t || _NbDatepickerComponent);
  };
})();
_NbDatepickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbDatepickerComponent,
  selectors: [["nb-datepicker"]],
  inputs: {
    date: "date"
  },
  outputs: {
    dateChange: "dateChange"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbDatepickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbDatepickerComponent = _NbDatepickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-datepicker",
      template: ""
    }]
  }], null, {
    date: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }]
  });
})();
var _NbRangepickerComponent = class _NbRangepickerComponent extends NbBasePickerComponent {
  constructor() {
    super(...arguments);
    this.pickerClass = NbCalendarRangeComponent;
  }
  /**
   * Range which will be rendered as selected.
   * */
  set range(range2) {
    this.value = range2;
  }
  /**
   * Emits range when start selected and emits again when end selected.
   * */
  get rangeChange() {
    return this.valueChange;
  }
  get value() {
    return this.picker ? this.picker.range : void 0;
  }
  set value(range2) {
    if (!this.picker) {
      this.queue = range2;
      return;
    }
    if (range2) {
      const visibleDate = range2 && range2.start;
      this.visibleDate = visibleDate;
      this.picker.visibleDate = visibleDate;
      this.picker.range = range2;
    }
  }
  get pickerValueChange() {
    return this.picker.rangeChange;
  }
  shouldHide() {
    return super.shouldHide() && !!(this.value && this.value.start && this.value.end);
  }
  writeQueue() {
    if (this.queue) {
      const range2 = this.queue;
      this.queue = null;
      this.value = range2;
    }
  }
};
_NbRangepickerComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbRangepickerComponent_BaseFactory;
  return function NbRangepickerComponent_Factory(t) {
    return (ɵNbRangepickerComponent_BaseFactory || (ɵNbRangepickerComponent_BaseFactory = ɵɵgetInheritedFactory(_NbRangepickerComponent)))(t || _NbRangepickerComponent);
  };
})();
_NbRangepickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRangepickerComponent,
  selectors: [["nb-rangepicker"]],
  inputs: {
    range: "range"
  },
  outputs: {
    rangeChange: "rangeChange"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbRangepickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbRangepickerComponent = _NbRangepickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRangepickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-rangepicker",
      template: ""
    }]
  }], null, {
    range: [{
      type: Input
    }],
    rangeChange: [{
      type: Output
    }]
  });
})();
var _NbDateTimePickerComponent = class _NbDateTimePickerComponent extends NbBasePickerComponent {
  get value() {
    return this.picker ? this.picker.date : void 0;
  }
  set value(date) {
    if (!this.picker) {
      this.queue = date;
      return;
    }
    if (date) {
      this.visibleDate = date;
      this.picker.visibleDate = date;
      this.picker.date = date;
      this.picker.cd.markForCheck();
    }
  }
  /**
   * Defines 12 hours format like '07:00 PM'.
   * */
  get twelveHoursFormat() {
    return this._twelveHoursFormat;
  }
  set twelveHoursFormat(value) {
    this._twelveHoursFormat = convertToBoolProperty(value);
  }
  /**
   * Defines should show am/pm label if twelveHoursFormat enabled.
   * */
  get showAmPmLabel() {
    return this._showAmPmLabel;
  }
  set showAmPmLabel(value) {
    this._showAmPmLabel = convertToBoolProperty(value);
  }
  /**
   * Show seconds in timepicker.
   * Ignored when singleColumn is true.
   * */
  get withSeconds() {
    return this._withSeconds;
  }
  set withSeconds(value) {
    this._withSeconds = convertToBoolProperty(value);
  }
  /**
   * Show timepicker values in one column with 60 minutes step by default.
   * */
  get singleColumn() {
    return this._singleColumn;
  }
  set singleColumn(value) {
    this._singleColumn = convertToBoolProperty(value);
  }
  /**
   * Emits date with time when selected.
   * */
  get dateTimeChange() {
    return this.valueChange;
  }
  constructor(document2, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions, calendarWithTimeModelService) {
    super(document2, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions);
    this.calendarWithTimeModelService = calendarWithTimeModelService;
    this.pickerClass = NbCalendarWithTimeComponent;
    this.showCurrentTimeButton = true;
    this._showAmPmLabel = true;
  }
  ngOnInit() {
    this.format = this.format || this.buildTimeFormat();
    this.init$.next();
  }
  patchWithInputs() {
    this.picker.singleColumn = this.singleColumn;
    this.picker.twelveHoursFormat = this.twelveHoursFormat;
    this.picker.showAmPmLabel = this.showAmPmLabel;
    this.picker.withSeconds = this.withSeconds;
    this.picker.step = this.step;
    this.picker.title = this.title;
    this.picker.applyButtonText = this.applyButtonText;
    this.picker.currentTimeButtonText = this.currentTimeButtonText;
    this.picker.showCurrentTimeButton = this.showCurrentTimeButton;
    if (this.twelveHoursFormat) {
      this.picker.timeFormat = this.dateService.getTwelveHoursFormat();
    } else {
      this.picker.timeFormat = this.withSeconds && !this.singleColumn ? this.dateService.getTwentyFourHoursFormatWithSeconds() : this.dateService.getTwentyFourHoursFormat();
    }
    super.patchWithInputs();
    this.picker.cd.markForCheck();
  }
  get pickerValueChange() {
    return this.picker.dateChange;
  }
  writeQueue() {
    if (this.queue) {
      const date = this.queue;
      this.queue = null;
      this.value = date;
    }
  }
  buildTimeFormat() {
    if (this.singleColumn) {
      return this.calendarWithTimeModelService.buildDateFormat(this.twelveHoursFormat);
    } else {
      return this.calendarWithTimeModelService.buildDateFormat(this.twelveHoursFormat, this.withSeconds);
    }
  }
};
_NbDateTimePickerComponent.ɵfac = function NbDateTimePickerComponent_Factory(t) {
  return new (t || _NbDateTimePickerComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NB_DATE_SERVICE_OPTIONS, 8), ɵɵdirectiveInject(NbCalendarTimeModelService));
};
_NbDateTimePickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbDateTimePickerComponent,
  selectors: [["nb-date-timepicker"]],
  inputs: {
    step: "step",
    title: "title",
    applyButtonText: "applyButtonText",
    currentTimeButtonText: "currentTimeButtonText",
    showCurrentTimeButton: "showCurrentTimeButton",
    twelveHoursFormat: "twelveHoursFormat",
    showAmPmLabel: "showAmPmLabel",
    withSeconds: "withSeconds",
    singleColumn: "singleColumn"
  },
  outputs: {
    dateTimeChange: "dateTimeChange"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbDateTimePickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbDateTimePickerComponent = _NbDateTimePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-date-timepicker",
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: NbDateService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_DATE_SERVICE_OPTIONS]
    }]
  }, {
    type: NbCalendarTimeModelService
  }], {
    step: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    dateTimeChange: [{
      type: Output
    }]
  });
})();
function isUrlPathEqual(path, link) {
  const locationPath = getPathPartOfUrl(path);
  return link === locationPath;
}
function isUrlPathContain(path, link) {
  const locationPath = getPathPartOfUrl(path);
  const endOfUrlSegmentRegExp = /\/|^$/;
  return locationPath.startsWith(link) && locationPath.slice(link.length).charAt(0).search(endOfUrlSegmentRegExp) !== -1;
}
function getPathPartOfUrl(url) {
  return url.match(/.*?(?=[?;#]|$)/)[0];
}
function getFragmentPartOfUrl(url) {
  const matched = url.match(/#(.+)/);
  return matched ? matched[1] : "";
}
function isFragmentEqual(path, fragment) {
  return getFragmentPartOfUrl(path) === fragment;
}
function isFragmentContain(path, fragment) {
  return getFragmentPartOfUrl(path).includes(fragment);
}
var _NbRestoreScrollTopHelper = class _NbRestoreScrollTopHelper {
  constructor(router) {
    this.router = router;
  }
  shouldRestore() {
    return this.router.events.pipe(startWith(null), filter((event) => event === null || event instanceof NavigationEnd), pairwise(), map(([prev, current]) => this.pageChanged(prev, current)), filter((res) => !!res));
  }
  pageChanged(prev, current) {
    return !prev || getPathPartOfUrl(prev.url) !== getPathPartOfUrl(current.url);
  }
};
_NbRestoreScrollTopHelper.ɵfac = function NbRestoreScrollTopHelper_Factory(t) {
  return new (t || _NbRestoreScrollTopHelper)(ɵɵinject(Router));
};
_NbRestoreScrollTopHelper.ɵprov = ɵɵdefineInjectable({
  token: _NbRestoreScrollTopHelper,
  factory: _NbRestoreScrollTopHelper.ɵfac
});
var NbRestoreScrollTopHelper = _NbRestoreScrollTopHelper;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRestoreScrollTopHelper, [{
    type: Injectable
  }], () => [{
    type: Router
  }], null);
})();
var _NbLayoutComponent = class _NbLayoutComponent {
  /**
   * Defines whether the layout columns will be centered after some width
   * @param {boolean} val
   */
  set center(val) {
    this.centerValue = convertToBoolProperty(val);
  }
  /**
   * Defines whether the layout enters a 'window' mode, when the layout content (including sidebars and fixed header)
   * becomes centered by width with a margin from the top of the screen, like a floating window.
   * Automatically enables `withScroll` mode, as in the window mode scroll must be inside the layout and cannot be on
   * window. (TODO: check this)
   * @param {boolean} val
   */
  set windowMode(val) {
    this.windowModeValue = convertToBoolProperty(val);
    this.withScroll = this.windowModeValue;
  }
  /**
   * Defines whether to move the scrollbars to layout or leave it at the body level.
   * Automatically set to true when `windowMode` is enabled.
   * @param {boolean} val
   */
  set withScroll(val) {
    this.withScrollValue = convertToBoolProperty(val);
    const body = this.document.getElementsByTagName("body")[0];
    if (this.withScrollValue) {
      this.renderer.setStyle(body, "overflow", "hidden");
    } else {
      this.renderer.setStyle(body, "overflow", "initial");
    }
  }
  /**
   * Restores scroll to the top of the page after navigation
   * @param {boolean} val
   */
  set restoreScrollTop(val) {
    this.restoreScrollTopValue = convertToBoolProperty(val);
  }
  constructor(themeService, spinnerService, elementRef, renderer, window2, document2, platformId, layoutDirectionService, scrollService, rulerService, scrollTop, overlayContainer) {
    this.themeService = themeService;
    this.spinnerService = spinnerService;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.window = window2;
    this.document = document2;
    this.platformId = platformId;
    this.layoutDirectionService = layoutDirectionService;
    this.scrollService = scrollService;
    this.rulerService = rulerService;
    this.scrollTop = scrollTop;
    this.overlayContainer = overlayContainer;
    this.scrollBlockClass = "nb-global-scrollblock";
    this.isScrollBlocked = false;
    this.centerValue = false;
    this.restoreScrollTopValue = true;
    this.windowModeValue = false;
    this.withScrollValue = false;
    this.withSubheader = false;
    this.afterViewInit$ = new BehaviorSubject(null);
    this.destroy$ = new Subject();
    this.registerAsOverlayContainer();
    this.themeService.onThemeChange().pipe(takeUntil(this.destroy$)).subscribe((theme) => {
      const body = this.document.getElementsByTagName("body")[0];
      if (theme.previous) {
        this.renderer.removeClass(body, `nb-theme-${theme.previous}`);
      }
      this.renderer.addClass(body, `nb-theme-${theme.name}`);
    });
    this.themeService.onAppendLayoutClass().pipe(takeUntil(this.destroy$)).subscribe((className) => {
      this.renderer.addClass(this.elementRef.nativeElement, className);
    });
    this.themeService.onRemoveLayoutClass().pipe(takeUntil(this.destroy$)).subscribe((className) => {
      this.renderer.removeClass(this.elementRef.nativeElement, className);
    });
    this.spinnerService.registerLoader(new Promise((resolve) => {
      this.afterViewInit$.pipe(takeUntil(this.destroy$)).subscribe((_) => resolve());
    }));
    this.spinnerService.load();
    this.rulerService.onGetDimensions().pipe(takeUntil(this.destroy$)).subscribe(({
      listener
    }) => {
      listener.next(this.getDimensions());
      listener.complete();
    });
    this.scrollService.onGetPosition().pipe(takeUntil(this.destroy$)).subscribe(({
      listener
    }) => {
      listener.next(this.getScrollPosition());
      listener.complete();
    });
    this.scrollTop.shouldRestore().pipe(filter(() => this.restoreScrollTopValue), takeUntil(this.destroy$)).subscribe(() => {
      this.scroll(0, 0);
    });
    this.scrollService.onScrollableChange().pipe(filter(() => this.withScrollValue), takeUntil(this.destroy$)).subscribe((scrollable) => {
      if (scrollable) {
        this.enableScroll();
      } else {
        this.blockScroll();
      }
    });
    if (isPlatformBrowser(this.platformId)) {
      this.themeService.changeWindowWidth(this.window.innerWidth);
    }
  }
  ngAfterViewInit() {
    this.layoutDirectionService.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe((direction) => this.document.dir = direction);
    this.scrollService.onManualScroll().pipe(takeUntil(this.destroy$)).subscribe(({
      x,
      y
    }) => this.scroll(x, y));
    this.afterViewInit$.next(true);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.unregisterAsOverlayContainer();
  }
  onScroll($event) {
    this.scrollService.fireScrollChange($event);
  }
  onResize(event) {
    this.themeService.changeWindowWidth(event.target.innerWidth);
  }
  /**
   * Returns scroll and client height/width
   *
   * Depending on the current scroll mode (`withScroll=true`) returns sizes from the body element
   * or from the `.scrollable-container`
   * @returns {NbLayoutDimensions}
   */
  getDimensions() {
    let clientWidth, clientHeight, scrollWidth, scrollHeight = 0;
    if (this.withScrollValue) {
      const container = this.scrollableContainerRef.nativeElement;
      clientWidth = container.clientWidth;
      clientHeight = container.clientHeight;
      scrollWidth = container.scrollWidth;
      scrollHeight = container.scrollHeight;
    } else {
      const {
        documentElement,
        body
      } = this.document;
      clientWidth = documentElement.clientWidth || body.clientWidth;
      clientHeight = documentElement.clientHeight || body.clientHeight;
      scrollWidth = documentElement.scrollWidth || body.scrollWidth;
      scrollHeight = documentElement.scrollHeight || body.scrollHeight;
    }
    return {
      clientWidth,
      clientHeight,
      scrollWidth,
      scrollHeight
    };
  }
  /**
   * Returns scroll position of current scroll container.
   *
   * If `withScroll` = true, returns scroll position of the `.scrollable-container` element,
   * otherwise - of the scrollable element of the window (which may be different depending of a browser)
   *
   * @returns {NbScrollPosition}
   */
  getScrollPosition() {
    if (!isPlatformBrowser(this.platformId)) {
      return {
        x: 0,
        y: 0
      };
    }
    if (this.withScrollValue) {
      const container = this.scrollableContainerRef.nativeElement;
      return {
        x: container.scrollLeft,
        y: container.scrollTop
      };
    }
    const documentRect = this.document.documentElement.getBoundingClientRect();
    const x = -documentRect.left || this.document.body.scrollLeft || this.window.scrollX || this.document.documentElement.scrollLeft || 0;
    const y = -documentRect.top || this.document.body.scrollTop || this.window.scrollY || this.document.documentElement.scrollTop || 0;
    return {
      x,
      y
    };
  }
  registerAsOverlayContainer() {
    if (this.overlayContainer.setContainer) {
      this.overlayContainer.setContainer(this.elementRef.nativeElement);
    }
  }
  unregisterAsOverlayContainer() {
    if (this.overlayContainer.clearContainer) {
      this.overlayContainer.clearContainer();
    }
  }
  scroll(x = null, y = null) {
    const {
      x: currentX,
      y: currentY
    } = this.getScrollPosition();
    x = x == null ? currentX : x;
    y = y == null ? currentY : y;
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    if (this.withScrollValue) {
      const scrollable = this.scrollableContainerRef.nativeElement;
      if (scrollable.scrollTo) {
        scrollable.scrollTo(x, y);
      } else {
        scrollable.scrollLeft = x;
        scrollable.scrollTop = y;
      }
    } else {
      this.window.scrollTo(x, y);
    }
  }
  // TODO: Extract into block scroll strategy
  blockScroll() {
    if (this.isScrollBlocked) {
      return;
    }
    this.isScrollBlocked = true;
    this.renderer.addClass(this.document.documentElement, this.scrollBlockClass);
    const scrollableContainerElement = this.scrollableContainerRef.nativeElement;
    const layoutElement = this.layoutContainerRef.nativeElement;
    const layoutWithScrollWidth = layoutElement.clientWidth;
    this.scrollableContainerOverflowOldValue = scrollableContainerElement.style.overflow;
    scrollableContainerElement.style.overflow = "hidden";
    const layoutWithoutScrollWidth = layoutElement.clientWidth;
    const scrollWidth = layoutWithoutScrollWidth - layoutWithScrollWidth;
    if (!scrollWidth) {
      return;
    }
    this.layoutPaddingOldValue = {
      left: layoutElement.style.paddingLeft,
      right: layoutElement.style.paddingRight
    };
    if (this.layoutDirectionService.isLtr()) {
      layoutElement.style.paddingRight = `${scrollWidth}px`;
    } else {
      layoutElement.style.paddingLeft = `${scrollWidth}px`;
    }
  }
  enableScroll() {
    if (this.isScrollBlocked) {
      this.isScrollBlocked = false;
      this.renderer.removeClass(this.document.documentElement, this.scrollBlockClass);
      this.scrollableContainerRef.nativeElement.style.overflow = this.scrollableContainerOverflowOldValue;
      if (this.layoutPaddingOldValue) {
        const layoutElement = this.layoutContainerRef.nativeElement;
        layoutElement.style.paddingLeft = this.layoutPaddingOldValue.left;
        layoutElement.style.paddingRight = this.layoutPaddingOldValue.right;
        this.layoutPaddingOldValue = null;
      }
    }
  }
};
_NbLayoutComponent.ɵfac = function NbLayoutComponent_Factory(t) {
  return new (t || _NbLayoutComponent)(ɵɵdirectiveInject(NbThemeService), ɵɵdirectiveInject(NbSpinnerService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbLayoutScrollService), ɵɵdirectiveInject(NbLayoutRulerService), ɵɵdirectiveInject(NbRestoreScrollTopHelper), ɵɵdirectiveInject(NbOverlayContainerAdapter));
};
_NbLayoutComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbLayoutComponent,
  selectors: [["nb-layout"]],
  viewQuery: function NbLayoutComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c122, 5, ViewContainerRef);
      ɵɵviewQuery(_c132, 7, ElementRef);
      ɵɵviewQuery(_c14, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.veryTopRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scrollableContainerRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.layoutContainerRef = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function NbLayoutComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("scroll", function NbLayoutComponent_scroll_HostBindingHandler($event) {
        return ctx.onScroll($event);
      }, false, ɵɵresolveWindow)("resize", function NbLayoutComponent_resize_HostBindingHandler($event) {
        return ctx.onResize($event);
      }, false, ɵɵresolveWindow);
    }
    if (rf & 2) {
      ɵɵclassProp("window-mode", ctx.windowModeValue)("with-scroll", ctx.withScrollValue)("with-subheader", ctx.withSubheader);
    }
  },
  inputs: {
    center: "center",
    windowMode: "windowMode",
    withScroll: "withScroll",
    restoreScrollTop: "restoreScrollTop"
  },
  ngContentSelectors: _c16,
  decls: 12,
  vars: 2,
  consts: [["scrollableContainer", ""], ["layoutContainer", ""], [1, "scrollable-container", 3, "scroll"], [1, "layout"], [1, "layout-container"], [1, "content"], [1, "columns"]],
  template: function NbLayoutComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c15);
      ɵɵelementStart(0, "div", 2, 0);
      ɵɵlistener("scroll", function NbLayoutComponent_Template_div_scroll_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onScroll($event));
      });
      ɵɵelementStart(2, "div", 3, 1);
      ɵɵprojection(4);
      ɵɵelementStart(5, "div", 4);
      ɵɵprojection(6, 1);
      ɵɵelementStart(7, "div", 5);
      ɵɵprojection(8, 2);
      ɵɵelementStart(9, "div", 6);
      ɵɵprojection(10, 3);
      ɵɵelementEnd();
      ɵɵprojection(11, 4);
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      ɵɵadvance(7);
      ɵɵclassProp("center", ctx.centerValue);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{-webkit-font-smoothing:antialiased}[dir=ltr]   [_nghost-%COMP%]{text-align:left}[dir=rtl]   [_nghost-%COMP%]{text-align:right}[_nghost-%COMP%]   .layout[_ngcontent-%COMP%]{display:flex;flex-direction:column}[_nghost-%COMP%]     nb-layout-header{display:block}[_nghost-%COMP%]     nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}[_nghost-%COMP%]     nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:2}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:2}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.end{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content.center[_ngcontent-%COMP%]{max-width:100%;position:relative;margin-left:auto;margin-right:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.start{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer{display:block;margin-top:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer nav{justify-content:center;display:flex}"]
});
var NbLayoutComponent = _NbLayoutComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout",
      template: `
    <div class="scrollable-container" #scrollableContainer (scroll)="onScroll($event)">
      <div class="layout" #layoutContainer>
        <ng-content select="nb-layout-header:not([subheader])"></ng-content>
        <div class="layout-container">
          <ng-content select="nb-sidebar"></ng-content>
          <div class="content" [class.center]="centerValue">
            <ng-content select="nb-layout-header[subheader]"></ng-content>
            <div class="columns">
              <ng-content select="nb-layout-column"></ng-content>
            </div>
            <ng-content select="nb-layout-footer"></ng-content>
          </div>
        </div>
      </div>
    </div>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{-webkit-font-smoothing:antialiased}[dir=ltr] :host{text-align:left}[dir=rtl] :host{text-align:right}:host .layout{display:flex;flex-direction:column}:host ::ng-deep nb-layout-header{display:block}:host ::ng-deep nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}:host ::ng-deep nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}:host .layout-container{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.left{order:0}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.left{order:2}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.right{order:2}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.right{order:0}:host .layout-container ::ng-deep nb-sidebar.end{order:2}:host .layout-container ::ng-deep nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}:host .layout-container .content{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}:host .layout-container .content.center{max-width:100%;position:relative;margin-left:auto;margin-right:auto}:host .layout-container .content .columns{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}:host .layout-container .content .columns ::ng-deep nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:0}[dir=rtl] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:2}:host .layout-container .content .columns ::ng-deep nb-layout-column.start{order:0}:host .layout-container .content ::ng-deep nb-layout-footer{display:block;margin-top:auto}:host .layout-container .content ::ng-deep nb-layout-footer nav{justify-content:center;display:flex}\n"]
    }]
  }], () => [{
    type: NbThemeService
  }, {
    type: NbSpinnerService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbLayoutScrollService
  }, {
    type: NbLayoutRulerService
  }, {
    type: NbRestoreScrollTopHelper
  }, {
    type: NbOverlayContainerAdapter
  }], {
    windowModeValue: [{
      type: HostBinding,
      args: ["class.window-mode"]
    }],
    withScrollValue: [{
      type: HostBinding,
      args: ["class.with-scroll"]
    }],
    withSubheader: [{
      type: HostBinding,
      args: ["class.with-subheader"]
    }],
    center: [{
      type: Input
    }],
    windowMode: [{
      type: Input
    }],
    withScroll: [{
      type: Input
    }],
    restoreScrollTop: [{
      type: Input
    }],
    veryTopRef: [{
      type: ViewChild,
      args: ["layoutTopDynamicArea", {
        read: ViewContainerRef
      }]
    }],
    scrollableContainerRef: [{
      type: ViewChild,
      args: ["scrollableContainer", {
        read: ElementRef,
        static: true
      }]
    }],
    layoutContainerRef: [{
      type: ViewChild,
      args: ["layoutContainer", {
        read: ElementRef
      }]
    }],
    onScroll: [{
      type: HostListener,
      args: ["window:scroll", ["$event"]]
    }],
    onResize: [{
      type: HostListener,
      args: ["window:resize", ["$event"]]
    }]
  });
})();
var _NbLayoutColumnComponent = class _NbLayoutColumnComponent {
  /**
   * Move the column to the very left position in the layout.
   * @param {boolean} val
   */
  set left(val) {
    this.leftValue = convertToBoolProperty(val);
    this.startValue = false;
  }
  /**
   * Make column first in the layout.
   * @param {boolean} val
   */
  set start(val) {
    this.startValue = convertToBoolProperty(val);
    this.leftValue = false;
  }
};
_NbLayoutColumnComponent.ɵfac = function NbLayoutColumnComponent_Factory(t) {
  return new (t || _NbLayoutColumnComponent)();
};
_NbLayoutColumnComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbLayoutColumnComponent,
  selectors: [["nb-layout-column"]],
  hostVars: 4,
  hostBindings: function NbLayoutColumnComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("left", ctx.leftValue)("start", ctx.startValue);
    }
  },
  inputs: {
    left: "left",
    start: "start"
  },
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbLayoutColumnComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbLayoutColumnComponent = _NbLayoutColumnComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutColumnComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-column",
      template: `<ng-content></ng-content>`
    }]
  }], null, {
    leftValue: [{
      type: HostBinding,
      args: ["class.left"]
    }],
    startValue: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    left: [{
      type: Input
    }],
    start: [{
      type: Input
    }]
  });
})();
var _NbLayoutHeaderComponent = class _NbLayoutHeaderComponent {
  constructor(layout) {
    this.layout = layout;
  }
  /**
   * Makes the header sticky to the top of the nb-layout.
   * @param {boolean} val
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
  /**
   * Places header on a side of the sidebar, and not above.
   * Disables fixed mode for this header and remove a shadow from the sidebar.
   * @param {boolean} val
   */
  set subheader(val) {
    this.subheaderValue = convertToBoolProperty(val);
    this.fixedValue = false;
    this.layout.withSubheader = this.subheaderValue;
  }
};
_NbLayoutHeaderComponent.ɵfac = function NbLayoutHeaderComponent_Factory(t) {
  return new (t || _NbLayoutHeaderComponent)(ɵɵdirectiveInject(NbLayoutComponent));
};
_NbLayoutHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbLayoutHeaderComponent,
  selectors: [["nb-layout-header"]],
  hostVars: 4,
  hostBindings: function NbLayoutHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("fixed", ctx.fixedValue)("subheader", ctx.subheaderValue);
    }
  },
  inputs: {
    fixed: "fixed",
    subheader: "subheader"
  },
  ngContentSelectors: _c03,
  decls: 2,
  vars: 2,
  template: function NbLayoutHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "nav");
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("fixed", ctx.fixedValue);
    }
  },
  encapsulation: 2
});
var NbLayoutHeaderComponent = _NbLayoutHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-header",
      template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `
    }]
  }], () => [{
    type: NbLayoutComponent
  }], {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    subheaderValue: [{
      type: HostBinding,
      args: ["class.subheader"]
    }],
    fixed: [{
      type: Input
    }],
    subheader: [{
      type: Input
    }]
  });
})();
var _NbLayoutFooterComponent = class _NbLayoutFooterComponent {
  /**
   * Makes the footer sticky to the bottom of the window.
   * @param {boolean} val
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
};
_NbLayoutFooterComponent.ɵfac = function NbLayoutFooterComponent_Factory(t) {
  return new (t || _NbLayoutFooterComponent)();
};
_NbLayoutFooterComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbLayoutFooterComponent,
  selectors: [["nb-layout-footer"]],
  hostVars: 2,
  hostBindings: function NbLayoutFooterComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("fixed", ctx.fixedValue);
    }
  },
  inputs: {
    fixed: "fixed"
  },
  ngContentSelectors: _c03,
  decls: 2,
  vars: 2,
  template: function NbLayoutFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "nav");
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("fixed", ctx.fixedValue);
    }
  },
  encapsulation: 2
});
var NbLayoutFooterComponent = _NbLayoutFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-footer",
      template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `
    }]
  }], null, {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    fixed: [{
      type: Input
    }]
  });
})();
var _NbBaseLayoutDirectionDirective = class _NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService, directionToShow) {
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
    this.directionToShow = directionToShow;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.directionService.onDirectionChange().pipe(map((layoutDirection) => layoutDirection === this.directionToShow), distinctUntilChanged(), takeUntil(this.destroy$)).subscribe((shouldShow) => this.updateView(shouldShow));
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  updateView(shouldShow) {
    if (shouldShow && !this.viewContainer.length) {
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.cd.markForCheck();
    } else if (!shouldShow && this.viewContainer.length) {
      this.viewContainer.clear();
    }
  }
};
_NbBaseLayoutDirectionDirective.ɵfac = function NbBaseLayoutDirectionDirective_Factory(t) {
  return new (t || _NbBaseLayoutDirectionDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbLayoutDirection));
};
_NbBaseLayoutDirectionDirective.ɵdir = ɵɵdefineDirective({
  type: _NbBaseLayoutDirectionDirective
});
var NbBaseLayoutDirectionDirective = _NbBaseLayoutDirectionDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseLayoutDirectionDirective, [{
    type: Directive
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbLayoutDirection
  }], null);
})();
var _NbLtrDirective = class _NbLtrDirective extends NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService) {
    super(templateRef, viewContainer, cd, directionService, NbLayoutDirection.LTR);
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
  }
};
_NbLtrDirective.ɵfac = function NbLtrDirective_Factory(t) {
  return new (t || _NbLtrDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService));
};
_NbLtrDirective.ɵdir = ɵɵdefineDirective({
  type: _NbLtrDirective,
  selectors: [["", "nbLtr", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
var NbLtrDirective = _NbLtrDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLtrDirective, [{
    type: Directive,
    args: [{
      selector: "[nbLtr]"
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var _NbRtlDirective = class _NbRtlDirective extends NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService) {
    super(templateRef, viewContainer, cd, directionService, NbLayoutDirection.RTL);
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
  }
};
_NbRtlDirective.ɵfac = function NbRtlDirective_Factory(t) {
  return new (t || _NbRtlDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService));
};
_NbRtlDirective.ɵdir = ɵɵdefineDirective({
  type: _NbRtlDirective,
  selectors: [["", "nbRtl", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
var NbRtlDirective = _NbRtlDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRtlDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRtl]"
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var NB_LAYOUT_COMPONENTS = [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent];
var NB_LAYOUT_DIRECTIVES = [NbLtrDirective, NbRtlDirective];
var _NbLayoutModule = class _NbLayoutModule {
};
_NbLayoutModule.ɵfac = function NbLayoutModule_Factory(t) {
  return new (t || _NbLayoutModule)();
};
_NbLayoutModule.ɵmod = ɵɵdefineNgModule({
  type: _NbLayoutModule,
  declarations: [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent, NbLtrDirective, NbRtlDirective],
  imports: [NbSharedModule],
  exports: [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent, NbLtrDirective, NbRtlDirective]
});
_NbLayoutModule.ɵinj = ɵɵdefineInjector({
  providers: [NbRestoreScrollTopHelper],
  imports: [NbSharedModule]
});
var NbLayoutModule = _NbLayoutModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_LAYOUT_COMPONENTS, ...NB_LAYOUT_DIRECTIVES],
      providers: [NbRestoreScrollTopHelper],
      exports: [...NB_LAYOUT_COMPONENTS, ...NB_LAYOUT_DIRECTIVES]
    }]
  }], null, null);
})();
var itemClick$ = new Subject();
var addItems$ = new ReplaySubject(1);
var navigateHome$ = new ReplaySubject(1);
var getSelectedItem$ = new ReplaySubject(1);
var itemSelect$ = new ReplaySubject(1);
var itemHover$ = new ReplaySubject(1);
var submenuToggle$ = new ReplaySubject(1);
var collapseAll$ = new ReplaySubject(1);
var NbMenuItem = class {
  constructor() {
    this.pathMatch = "full";
  }
  /**
   * @returns item parents in top-down order
   */
  static getParents(item) {
    const parents = [];
    let parent = item.parent;
    while (parent) {
      parents.unshift(parent);
      parent = parent.parent;
    }
    return parents;
  }
  static isParent(item, possibleChild) {
    return possibleChild.parent ? possibleChild.parent === item || this.isParent(item, possibleChild.parent) : false;
  }
};
var _NbMenuService = class _NbMenuService {
  /**
   * Add items to the end of the menu items list
   * @param {List<NbMenuItem>} items
   * @param {string} tag
   */
  addItems(items, tag) {
    addItems$.next({
      tag,
      items
    });
  }
  /**
   * Collapses all menu items
   * @param {string} tag
   */
  collapseAll(tag) {
    collapseAll$.next({
      tag
    });
  }
  /**
   * Navigate to the home menu item
   * @param {string} tag
   */
  navigateHome(tag) {
    navigateHome$.next({
      tag
    });
  }
  /**
   * Returns currently selected item. Won't subscribe to the future events.
   * @param {string} tag
   * @returns {Observable<{tag: string; item: NbMenuItem}>}
   */
  getSelectedItem(tag) {
    const listener = new BehaviorSubject(null);
    getSelectedItem$.next({
      tag,
      listener
    });
    return listener.asObservable();
  }
  onItemClick() {
    return itemClick$.pipe(share());
  }
  onItemSelect() {
    return itemSelect$.pipe(share());
  }
  onItemHover() {
    return itemHover$.pipe(share());
  }
  onSubmenuToggle() {
    return submenuToggle$.pipe(share());
  }
};
_NbMenuService.ɵfac = function NbMenuService_Factory(t) {
  return new (t || _NbMenuService)();
};
_NbMenuService.ɵprov = ɵɵdefineInjectable({
  token: _NbMenuService,
  factory: _NbMenuService.ɵfac
});
var NbMenuService = _NbMenuService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuService, [{
    type: Injectable
  }], null, null);
})();
var _NbMenuInternalService = class _NbMenuInternalService {
  constructor(location) {
    this.location = location;
  }
  prepareItems(items) {
    const defaultItem = new NbMenuItem();
    items.forEach((i) => {
      this.applyDefaults(i, defaultItem);
      this.setParent(i);
    });
  }
  selectFromUrl(items, tag, collapseOther = false) {
    const selectedItem = this.findItemByUrl(items);
    if (selectedItem) {
      this.selectItem(selectedItem, items, collapseOther, tag);
    }
  }
  selectItem(item, items, collapseOther = false, tag) {
    const unselectedItems = this.resetSelection(items);
    const collapsedItems = collapseOther ? this.collapseItems(items) : [];
    for (const parent of NbMenuItem.getParents(item)) {
      parent.selected = true;
      if (!unselectedItems.includes(parent)) {
        this.itemSelect(parent, tag);
      }
      const wasNotExpanded = !parent.expanded;
      parent.expanded = true;
      const i = collapsedItems.indexOf(parent);
      if (i === -1 && wasNotExpanded) {
        this.submenuToggle(parent, tag);
      } else {
        collapsedItems.splice(i, 1);
      }
    }
    item.selected = true;
    if (!unselectedItems.includes(item)) {
      this.itemSelect(item, tag);
    }
    for (const collapsedItem of collapsedItems) {
      this.submenuToggle(collapsedItem, tag);
    }
  }
  collapseAll(items, tag, except) {
    const collapsedItems = this.collapseItems(items, except);
    for (const item of collapsedItems) {
      this.submenuToggle(item, tag);
    }
  }
  onAddItem() {
    return addItems$.pipe(share());
  }
  onNavigateHome() {
    return navigateHome$.pipe(share());
  }
  onCollapseAll() {
    return collapseAll$.pipe(share());
  }
  onGetSelectedItem() {
    return getSelectedItem$.pipe(share());
  }
  itemHover(item, tag) {
    itemHover$.next({
      tag,
      item
    });
  }
  submenuToggle(item, tag) {
    submenuToggle$.next({
      tag,
      item
    });
  }
  itemSelect(item, tag) {
    itemSelect$.next({
      tag,
      item
    });
  }
  itemClick(item, tag) {
    itemClick$.next({
      tag,
      item
    });
  }
  /**
   * Unselect all given items deeply.
   * @param items array of items to unselect.
   * @returns items which selected value was changed.
   */
  resetSelection(items) {
    const unselectedItems = [];
    for (const item of items) {
      if (item.selected) {
        unselectedItems.push(item);
      }
      item.selected = false;
      if (item.children) {
        unselectedItems.push(...this.resetSelection(item.children));
      }
    }
    return unselectedItems;
  }
  /**
   * Collapse all given items deeply.
   * @param items array of items to collapse.
   * @param except menu item which shouldn't be collapsed, also disables collapsing for parents of this item.
   * @returns items which expanded value was changed.
   */
  collapseItems(items, except) {
    const collapsedItems = [];
    for (const item of items) {
      if (except && (item === except || NbMenuItem.isParent(item, except))) {
        continue;
      }
      if (item.expanded) {
        collapsedItems.push(item);
      }
      item.expanded = false;
      if (item.children) {
        collapsedItems.push(...this.collapseItems(item.children));
      }
    }
    return collapsedItems;
  }
  applyDefaults(item, defaultItem) {
    const menuItem = __spreadValues({}, item);
    Object.assign(item, defaultItem, menuItem);
    item.children && item.children.forEach((child) => {
      this.applyDefaults(child, defaultItem);
    });
  }
  setParent(item) {
    item.children && item.children.forEach((child) => {
      child.parent = item;
      this.setParent(child);
    });
  }
  /**
   * Find deepest item which link matches current URL path.
   * @param items array of items to search in.
   * @returns found item of undefined.
   */
  findItemByUrl(items) {
    let selectedItem;
    items.some((item) => {
      if (item.children) {
        selectedItem = this.findItemByUrl(item.children);
      }
      if (!selectedItem && this.isSelectedInUrl(item)) {
        selectedItem = item;
      }
      return selectedItem;
    });
    return selectedItem;
  }
  isSelectedInUrl(item) {
    const exact = item.pathMatch === "full";
    const link = item.link;
    const isSelectedInPath = exact ? isUrlPathEqual(this.location.path(), link) : isUrlPathContain(this.location.path(), link);
    if (isSelectedInPath && item.fragment != null) {
      return exact ? isFragmentEqual(this.location.path(true), item.fragment) : isFragmentContain(this.location.path(true), item.fragment);
    }
    return isSelectedInPath;
  }
};
_NbMenuInternalService.ɵfac = function NbMenuInternalService_Factory(t) {
  return new (t || _NbMenuInternalService)(ɵɵinject(Location));
};
_NbMenuInternalService.ɵprov = ɵɵdefineInjectable({
  token: _NbMenuInternalService,
  factory: _NbMenuInternalService.ɵfac
});
var NbMenuInternalService = _NbMenuInternalService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuInternalService, [{
    type: Injectable
  }], () => [{
    type: Location
  }], null);
})();
var _NbBadgeComponent = class _NbBadgeComponent {
  /**
   * Badge position
   *
   * Can be set to any class or to one of predefined positions:
   * 'top left', 'top right', 'bottom left', 'bottom right',
   * 'top start', 'top end', 'bottom start', 'bottom end'
   * @type string
   */
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value || this._defaultPosition;
  }
  /**
   * Shows badge as a dot. No text is shown.
   * @type boolean
   */
  get dotMode() {
    return this._dotMode;
  }
  set dotMode(value) {
    this._dotMode = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get top() {
    return this.position.includes("top");
  }
  get right() {
    return this.position.includes("right");
  }
  get bottom() {
    return this.position.includes("bottom");
  }
  get left() {
    return this.position.includes("left");
  }
  get start() {
    return this.position.includes("start");
  }
  get end() {
    return this.position.includes("end");
  }
  get center() {
    return this.position.includes("center");
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.text = "";
    this._defaultPosition = "top right";
    this._position = this._defaultPosition;
    this.status = "basic";
  }
};
_NbBadgeComponent.ɵfac = function NbBadgeComponent_Factory(t) {
  return new (t || _NbBadgeComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbBadgeComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbBadgeComponent,
  selectors: [["nb-badge"]],
  hostVars: 32,
  hostBindings: function NbBadgeComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("dot-mode", ctx.dotMode)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("position-top", ctx.top)("position-right", ctx.right)("position-bottom", ctx.bottom)("position-left", ctx.left)("position-start", ctx.start)("position-end", ctx.end)("position-center", ctx.center);
    }
  },
  inputs: {
    text: "text",
    position: "position",
    dotMode: "dotMode",
    status: "status"
  },
  decls: 1,
  vars: 1,
  template: function NbBadgeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtext(0);
    }
    if (rf & 2) {
      ɵɵtextInterpolate(ctx.dotMode ? "" : ctx.text);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}.position-top[_nghost-%COMP%]{top:0}.position-right[_nghost-%COMP%]{right:0}.position-bottom[_nghost-%COMP%]{bottom:0}.position-left[_nghost-%COMP%]{left:0}.position-center[_nghost-%COMP%]{top:50%;transform:translateY(-50%)}[dir=ltr]   .position-start[_nghost-%COMP%]{left:0}[dir=rtl]   .position-start[_nghost-%COMP%]{right:0}[dir=ltr]   .position-end[_nghost-%COMP%]{right:0}[dir=rtl]   .position-end[_nghost-%COMP%]{left:0}"]
});
var NbBadgeComponent = _NbBadgeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBadgeComponent, [{
    type: Component,
    args: [{
      selector: "nb-badge",
      template: `{{dotMode ? '' : text}}`,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}:host(.position-top){top:0}:host(.position-right){right:0}:host(.position-bottom){bottom:0}:host(.position-left){left:0}:host(.position-center){top:50%;transform:translateY(-50%)}[dir=ltr] :host(.position-start){left:0}[dir=rtl] :host(.position-start){right:0}[dir=ltr] :host(.position-end){right:0}[dir=rtl] :host(.position-end){left:0}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    text: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    dotMode: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.dot-mode"]
    }],
    status: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    top: [{
      type: HostBinding,
      args: ["class.position-top"]
    }],
    right: [{
      type: HostBinding,
      args: ["class.position-right"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.position-bottom"]
    }],
    left: [{
      type: HostBinding,
      args: ["class.position-left"]
    }],
    start: [{
      type: HostBinding,
      args: ["class.position-start"]
    }],
    end: [{
      type: HostBinding,
      args: ["class.position-end"]
    }],
    center: [{
      type: HostBinding,
      args: ["class.position-center"]
    }]
  });
})();
var NbToggleStates;
(function(NbToggleStates2) {
  NbToggleStates2["Expanded"] = "expanded";
  NbToggleStates2["Collapsed"] = "collapsed";
})(NbToggleStates || (NbToggleStates = {}));
var _NbMenuItemComponent = class _NbMenuItemComponent {
  constructor(menuService, directionService) {
    this.menuService = menuService;
    this.directionService = directionService;
    this.menuItem = null;
    this.hoverItem = new EventEmitter();
    this.toggleSubMenu = new EventEmitter();
    this.selectItem = new EventEmitter();
    this.itemClick = new EventEmitter();
    this.destroy$ = new Subject();
  }
  ngDoCheck() {
    this.toggleState = this.menuItem.expanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed;
  }
  ngAfterViewInit() {
    this.menuService.onSubmenuToggle().pipe(filter(({
      item
    }) => item === this.menuItem), map(({
      item
    }) => item.expanded), takeUntil(this.destroy$)).subscribe((isExpanded) => this.toggleState = isExpanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  onToggleSubMenu(item) {
    this.toggleSubMenu.emit(item);
  }
  onHoverItem(item) {
    this.hoverItem.emit(item);
  }
  onSelectItem(item) {
    this.selectItem.emit(item);
  }
  onItemClick(item) {
    this.itemClick.emit(item);
  }
  getExpandStateIcon() {
    if (this.menuItem.expanded) {
      return "chevron-down-outline";
    }
    return this.directionService.isLtr() ? "chevron-left-outline" : "chevron-right-outline";
  }
};
_NbMenuItemComponent.ɵfac = function NbMenuItemComponent_Factory(t) {
  return new (t || _NbMenuItemComponent)(ɵɵdirectiveInject(NbMenuService), ɵɵdirectiveInject(NbLayoutDirectionService));
};
_NbMenuItemComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbMenuItemComponent,
  selectors: [["", "nbMenuItem", ""]],
  inputs: {
    menuItem: "menuItem",
    badge: "badge"
  },
  outputs: {
    hoverItem: "hoverItem",
    toggleSubMenu: "toggleSubMenu",
    selectItem: "selectItem",
    itemClick: "itemClick"
  },
  attrs: _c17,
  decls: 8,
  vars: 6,
  consts: [["badgeTemplate", ""], [4, "ngIf"], [3, "routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "active", "mouseenter", "click", 4, "ngIf"], [3, "active", "mouseenter", "click", 4, "ngIf"], ["href", "#", 3, "active", "click", "mouseenter", 4, "ngIf"], ["class", "menu-items", 3, "collapsed", "expanded", 4, "ngIf"], ["class", "menu-icon", 3, "config", 4, "ngIf"], [1, "menu-icon", 3, "config"], [3, "mouseenter", "click", "routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange"], [1, "menu-title"], [3, "ngTemplateOutlet", 4, "ngIf"], [3, "ngTemplateOutlet"], [3, "mouseenter", "click"], ["href", "#", 3, "click", "mouseenter"], ["pack", "nebular-essentials", 1, "expand-state", 3, "icon"], [1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "badge", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "hoverItem", "toggleSubMenu", "selectItem", "itemClick", "menuItem", "badge"], [3, "text", "dotMode", "status"]],
  template: function NbMenuItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbMenuItemComponent_span_0_Template, 3, 2, "span", 1)(1, NbMenuItemComponent_a_1_Template, 5, 14, "a", 2)(2, NbMenuItemComponent_a_2_Template, 5, 9, "a", 3)(3, NbMenuItemComponent_a_3_Template, 5, 8, "a", 3)(4, NbMenuItemComponent_a_4_Template, 6, 10, "a", 4)(5, NbMenuItemComponent_ul_5_Template, 2, 6, "ul", 5)(6, NbMenuItemComponent_ng_template_6_Template, 1, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.menuItem.group);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.group);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.group);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.group);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuItem.children);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuItem.children);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, RouterLink, NbIconComponent, NbBadgeComponent, _NbMenuItemComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("toggle", [state(NbToggleStates.Collapsed, style({
      height: "0",
      margin: "0"
    })), state(NbToggleStates.Expanded, style({
      height: "*"
    })), transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300))])]
  }
});
var NbMenuItemComponent = _NbMenuItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuItemComponent, [{
    type: Component,
    args: [{
      selector: "[nbMenuItem]",
      animations: [trigger("toggle", [state(NbToggleStates.Collapsed, style({
        height: "0",
        margin: "0"
      })), state(NbToggleStates.Expanded, style({
        height: "*"
      })), transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300))])],
      template: '<span *ngIf="menuItem.group">\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  {{ menuItem.title }}\n</span>\n<a\n  *ngIf="menuItem.link && !menuItem.url && !menuItem.children && !menuItem.group"\n  [routerLink]="menuItem.link"\n  [queryParams]="menuItem.queryParams"\n  [fragment]="menuItem.fragment"\n  [queryParamsHandling]="menuItem.queryParamsHandling"\n  [preserveFragment]="menuItem.preserveFragment"\n  [skipLocationChange]="menuItem.skipLocationChange"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="onItemClick(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="menuItem.url && !menuItem.children && !menuItem.link && !menuItem.group"\n  [attr.href]="menuItem.url"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="onSelectItem(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="!menuItem.children && !menuItem.link && !menuItem.url && !menuItem.group"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="$event.preventDefault(); onItemClick(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="menuItem.children"\n  (click)="$event.preventDefault(); onToggleSubMenu(menuItem)"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.aria-expanded]="menuItem.expanded ?? false"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  href="#"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n  <nb-icon class="expand-state" [icon]="getExpandStateIcon()" pack="nebular-essentials"></nb-icon>\n</a>\n<ul\n  *ngIf="menuItem.children"\n  [class.collapsed]="!(menuItem.children && menuItem.expanded)"\n  [class.expanded]="menuItem.expanded"\n  [@toggle]="toggleState"\n  class="menu-items"\n>\n  <ng-container *ngFor="let item of menuItem.children">\n    <li\n      nbMenuItem\n      *ngIf="!item.hidden"\n      [menuItem]="item"\n      [badge]="item.badge"\n      [class.menu-group]="item.group"\n      (hoverItem)="onHoverItem($event)"\n      (toggleSubMenu)="onToggleSubMenu($event)"\n      (selectItem)="onSelectItem($event)"\n      (itemClick)="onItemClick($event)"\n      class="menu-item"\n    ></li>\n  </ng-container>\n</ul>\n\n<ng-template #badgeTemplate>\n  <nb-badge [text]="badge.text" [dotMode]="badge.dotMode" [status]="badge.status"> </nb-badge>\n</ng-template>\n'
    }]
  }], () => [{
    type: NbMenuService
  }, {
    type: NbLayoutDirectionService
  }], {
    menuItem: [{
      type: Input
    }],
    badge: [{
      type: Input
    }],
    hoverItem: [{
      type: Output
    }],
    toggleSubMenu: [{
      type: Output
    }],
    selectItem: [{
      type: Output
    }],
    itemClick: [{
      type: Output
    }]
  });
})();
var _NbMenuComponent = class _NbMenuComponent {
  /**
   * Collapse all opened submenus on the toggle event
   * Default value is "false"
   * @type boolean
   */
  get autoCollapse() {
    return this._autoCollapse;
  }
  set autoCollapse(value) {
    this._autoCollapse = convertToBoolProperty(value);
  }
  constructor(window2, platformId, menuInternalService, router) {
    this.window = window2;
    this.platformId = platformId;
    this.menuInternalService = menuInternalService;
    this.router = router;
    this._autoCollapse = false;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.menuInternalService.prepareItems(this.items);
    this.menuInternalService.onAddItem().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe((data) => this.onAddItem(data));
    this.menuInternalService.onNavigateHome().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe(() => this.navigateHome());
    this.menuInternalService.onGetSelectedItem().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe((data) => {
      data.listener.next({
        tag: this.tag,
        item: this.getSelectedItem(this.items)
      });
    });
    this.menuInternalService.onCollapseAll().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe(() => this.collapseAll());
    this.router.events.pipe(filter((event) => event instanceof NavigationEnd), takeUntil(this.destroy$)).subscribe(() => {
      this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
    });
  }
  ngAfterViewInit() {
    setTimeout(() => this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse));
  }
  onAddItem(data) {
    this.items.push(...data.items);
    this.menuInternalService.prepareItems(this.items);
    this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
  }
  onHoverItem(item) {
    this.menuInternalService.itemHover(item, this.tag);
  }
  onToggleSubMenu(item) {
    if (this.autoCollapse) {
      this.menuInternalService.collapseAll(this.items, this.tag, item);
    }
    item.expanded = !item.expanded;
    this.menuInternalService.submenuToggle(item, this.tag);
  }
  // TODO: is not fired on page reload
  onSelectItem(item) {
    this.menuInternalService.selectItem(item, this.items, this.autoCollapse, this.tag);
  }
  onItemClick(item) {
    this.menuInternalService.itemClick(item, this.tag);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  navigateHome() {
    const homeItem = this.getHomeItem(this.items);
    if (homeItem) {
      if (homeItem.link) {
        const extras = {
          queryParams: homeItem.queryParams,
          queryParamsHandling: homeItem.queryParamsHandling,
          fragment: homeItem.fragment,
          preserveFragment: homeItem.preserveFragment
        };
        this.router.navigate([homeItem.link], extras);
      }
      if (homeItem.url && isPlatformBrowser(this.platformId)) {
        this.window.location.href = homeItem.url;
      }
    }
  }
  collapseAll() {
    this.menuInternalService.collapseAll(this.items, this.tag);
  }
  getHomeItem(items) {
    for (const item of items) {
      if (item.home) {
        return item;
      }
      const homeItem = item.children && this.getHomeItem(item.children);
      if (homeItem) {
        return homeItem;
      }
    }
    return void 0;
  }
  compareTag(tag) {
    return !tag || tag === this.tag;
  }
  getSelectedItem(items) {
    let selected = null;
    items.forEach((item) => {
      if (item.selected) {
        selected = item;
      }
      if (item.selected && item.children && item.children.length > 0) {
        selected = this.getSelectedItem(item.children);
      }
    });
    return selected;
  }
};
_NbMenuComponent.ɵfac = function NbMenuComponent_Factory(t) {
  return new (t || _NbMenuComponent)(ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NbMenuInternalService), ɵɵdirectiveInject(Router));
};
_NbMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbMenuComponent,
  selectors: [["nb-menu"]],
  inputs: {
    tag: "tag",
    items: "items",
    autoCollapse: "autoCollapse"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "badge", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "hoverItem", "toggleSubMenu", "selectItem", "itemClick", "menuItem", "badge"]],
  template: function NbMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "ul", 0);
      ɵɵtemplate(1, NbMenuComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.items);
    }
  },
  dependencies: [NgForOf, NgIf, NbMenuItemComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]    {display:block}[_nghost-%COMP%]     .menu-items, [_nghost-%COMP%]     .menu-item>.menu-items{list-style-type:none;overflow:hidden}[_nghost-%COMP%]     .menu-item a{display:flex;text-decoration:none;align-items:center}[_nghost-%COMP%]     .menu-item a .menu-title{flex:1 0 auto;pointer-events:none}[dir=rtl]   [_nghost-%COMP%]     .menu-item a .menu-title{text-align:right}[_nghost-%COMP%]     .menu-item nb-badge{position:static}[_nghost-%COMP%]     .menu-group span{display:flex}"]
});
var NbMenuComponent = _NbMenuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuComponent, [{
    type: Component,
    args: [{
      selector: "nb-menu",
      template: `
    <ul class="menu-items">
      <ng-container *ngFor="let item of items">
        <li nbMenuItem *ngIf="!item.hidden"
            [menuItem]="item"
            [badge]="item.badge"
            [class.menu-group]="item.group"
            (hoverItem)="onHoverItem($event)"
            (toggleSubMenu)="onToggleSubMenu($event)"
            (selectItem)="onSelectItem($event)"
            (itemClick)="onItemClick($event)"
            class="menu-item">
        </li>
      </ng-container>
    </ul>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host ::ng-deep{display:block}:host ::ng-deep .menu-items,:host ::ng-deep .menu-item>.menu-items{list-style-type:none;overflow:hidden}:host ::ng-deep .menu-item a{display:flex;text-decoration:none;align-items:center}:host ::ng-deep .menu-item a .menu-title{flex:1 0 auto;pointer-events:none}[dir=rtl] :host ::ng-deep .menu-item a .menu-title{text-align:right}:host ::ng-deep .menu-item nb-badge{position:static}:host ::ng-deep .menu-group span{display:flex}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NbMenuInternalService
  }, {
    type: Router
  }], {
    tag: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    autoCollapse: [{
      type: Input
    }]
  });
})();
var _NbBadgeModule = class _NbBadgeModule {
};
_NbBadgeModule.ɵfac = function NbBadgeModule_Factory(t) {
  return new (t || _NbBadgeModule)();
};
_NbBadgeModule.ɵmod = ɵɵdefineNgModule({
  type: _NbBadgeModule,
  declarations: [NbBadgeComponent],
  exports: [NbBadgeComponent]
});
_NbBadgeModule.ɵinj = ɵɵdefineInjector({});
var NbBadgeModule = _NbBadgeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBadgeModule, [{
    type: NgModule,
    args: [{
      exports: [NbBadgeComponent],
      declarations: [NbBadgeComponent]
    }]
  }], null, null);
})();
var nbMenuComponents = [NbMenuComponent, NbMenuItemComponent];
var NB_MENU_PROVIDERS = [NbMenuService, NbMenuInternalService];
var _NbMenuModule = class _NbMenuModule {
  static forRoot() {
    return {
      ngModule: _NbMenuModule,
      providers: [...NB_MENU_PROVIDERS]
    };
  }
};
_NbMenuModule.ɵfac = function NbMenuModule_Factory(t) {
  return new (t || _NbMenuModule)();
};
_NbMenuModule.ɵmod = ɵɵdefineNgModule({
  type: _NbMenuModule,
  declarations: [NbMenuComponent, NbMenuItemComponent],
  imports: [NbSharedModule, NbIconModule, NbBadgeModule],
  exports: [NbMenuComponent, NbMenuItemComponent]
});
_NbMenuModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule, NbBadgeModule]
});
var NbMenuModule = _NbMenuModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule, NbBadgeModule],
      declarations: [...nbMenuComponents],
      exports: [...nbMenuComponents]
    }]
  }], null, null);
})();
var _NbMergeConfigsPipe = class _NbMergeConfigsPipe {
  transform(...configs) {
    return Object.assign({}, ...configs);
  }
};
_NbMergeConfigsPipe.ɵfac = function NbMergeConfigsPipe_Factory(t) {
  return new (t || _NbMergeConfigsPipe)();
};
_NbMergeConfigsPipe.ɵpipe = ɵɵdefinePipe({
  name: "nbMergeConfigs",
  type: _NbMergeConfigsPipe,
  pure: true
});
var NbMergeConfigsPipe = _NbMergeConfigsPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMergeConfigsPipe, [{
    type: Pipe,
    args: [{
      name: "nbMergeConfigs"
    }]
  }], null, null);
})();
var _NbRouteTabsetComponent = class _NbRouteTabsetComponent {
  constructor() {
    this.fullWidthValue = false;
    this.activeLinkOptions = {
      exact: true
    };
    this.changeTab = new EventEmitter();
  }
  /**
   * Take full width of a parent
   * @param {boolean} val
   */
  set fullWidth(val) {
    this.fullWidthValue = convertToBoolProperty(val);
  }
  selectTab(tab) {
    this.changeTab.emit(tab);
  }
};
_NbRouteTabsetComponent.ɵfac = function NbRouteTabsetComponent_Factory(t) {
  return new (t || _NbRouteTabsetComponent)();
};
_NbRouteTabsetComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRouteTabsetComponent,
  selectors: [["nb-route-tabset"]],
  hostVars: 2,
  hostBindings: function NbRouteTabsetComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("full-width", ctx.fullWidthValue);
    }
  },
  inputs: {
    tabs: "tabs",
    activeLinkOptions: "activeLinkOptions",
    fullWidth: "fullWidth"
  },
  outputs: {
    changeTab: "changeTab"
  },
  decls: 3,
  vars: 1,
  consts: [["enabled", ""], [1, "route-tabset"], [4, "ngFor", "ngForOf"], ["class", "route-tab disabled", "tabindex", "-1", 3, "responsive", 4, "ngIf", "ngIfElse"], ["tabindex", "-1", 1, "route-tab", "disabled"], ["tabindex", "-1", 1, "tab-link"], [3, "config", 4, "ngIf"], ["class", "tab-text", 4, "ngIf"], [3, "config"], [1, "tab-text"], ["routerLinkActive", "active", 1, "route-tab", 3, "routerLinkActiveOptions"], [1, "tab-link", 3, "click", "routerLink", "queryParams", "queryParamsHandling", "fragment", "preserveFragment", "skipLocationChange", "replaceUrl", "state"]],
  template: function NbRouteTabsetComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "ul", 1);
      ɵɵtemplate(1, NbRouteTabsetComponent_ng_container_1_Template, 4, 2, "ng-container", 2);
      ɵɵelementEnd();
      ɵɵelement(2, "router-outlet");
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.tabs);
    }
  },
  dependencies: [NgForOf, NgIf, RouterOutlet, RouterLink, RouterLinkActive, NbIconComponent, NbMergeConfigsPipe],
  styles: ['\n\n\n\n\n.route-tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{display:block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{position:relative;text-decoration:none;display:inline-block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tab-link[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tab-link[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}.full-width[_nghost-%COMP%]   .route-tabset[_ngcontent-%COMP%]{justify-content:space-around}']
});
var NbRouteTabsetComponent = _NbRouteTabsetComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRouteTabsetComponent, [{
    type: Component,
    args: [{
      selector: "nb-route-tabset",
      template: `
    <ul class="route-tabset">
      <ng-container *ngFor="let tab of tabs">
        <li
          *ngIf="tab.disabled; else enabled"
          [class.responsive]="tab.responsive"
          class="route-tab disabled"
          tabindex="-1"
        >
          <a tabindex="-1" class="tab-link">
            <nb-icon *ngIf="tab.icon" [config]="tab.icon"></nb-icon>
            <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
          </a>
        </li>

        <ng-template #enabled>
          <li
            routerLinkActive="active"
            [routerLinkActiveOptions]="activeLinkOptions | nbMergeConfigs: tab.activeLinkOptions"
            class="route-tab"
          >
            <a
              (click)="selectTab(tab)"
              [routerLink]="tab.route"
              [class.responsive]="tab.responsive"
              [queryParams]="tab.queryParams"
              [queryParamsHandling]="tab.queryParamsHandling"
              [fragment]="tab.fragment"
              [preserveFragment]="tab.preserveFragment"
              [skipLocationChange]="tab.skipLocationChange"
              [replaceUrl]="tab.replaceUrl"
              [state]="tab.state"
              class="tab-link"
            >
              <nb-icon *ngIf="tab.icon" [config]="tab.icon"></nb-icon>
              <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
            </a>
          </li>
        </ng-template>
      </ng-container>
    </ul>
    <router-outlet></router-outlet>
  `,
      styles: ['/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */.route-tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}.route-tabset .route-tab{margin-bottom:-1px;text-align:center;padding:0}.route-tabset .route-tab.active a:before{display:block}.route-tabset .route-tab a{position:relative;text-decoration:none;display:inline-block}.route-tabset .route-tab a:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset .route-tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tab-link nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tab-link nb-icon+span{margin-right:.5rem}:host(.full-width) .route-tabset{justify-content:space-around}\n']
    }]
  }], null, {
    fullWidthValue: [{
      type: HostBinding,
      args: ["class.full-width"]
    }],
    tabs: [{
      type: Input
    }],
    activeLinkOptions: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }],
    changeTab: [{
      type: Output
    }]
  });
})();
var _NbRouteTabsetModule = class _NbRouteTabsetModule {
};
_NbRouteTabsetModule.ɵfac = function NbRouteTabsetModule_Factory(t) {
  return new (t || _NbRouteTabsetModule)();
};
_NbRouteTabsetModule.ɵmod = ɵɵdefineNgModule({
  type: _NbRouteTabsetModule,
  declarations: [NbRouteTabsetComponent, NbMergeConfigsPipe],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbRouteTabsetComponent]
});
_NbRouteTabsetModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbRouteTabsetModule = _NbRouteTabsetModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRouteTabsetModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbRouteTabsetComponent, NbMergeConfigsPipe],
      exports: [NbRouteTabsetComponent]
    }]
  }], null, null);
})();
var getSidebarState$ = new Subject();
var getSidebarResponsiveState$ = new Subject();
var _NbSidebarService = class _NbSidebarService {
  constructor() {
    this.toggle$ = new Subject();
    this.expand$ = new Subject();
    this.collapse$ = new Subject();
    this.compact$ = new Subject();
  }
  /**
   * Subscribe to toggle events
   *
   * @returns Observable<{ compact: boolean, tag: string }>
   */
  onToggle() {
    return this.toggle$.pipe(share());
  }
  /**
   * Subscribe to expand events
   * @returns Observable<{ tag: string }>
   */
  onExpand() {
    return this.expand$.pipe(share());
  }
  /**
   * Subscribe to collapse evens
   * @returns Observable<{ tag: string }>
   */
  onCollapse() {
    return this.collapse$.pipe(share());
  }
  /**
   * Subscribe to compact evens
   * @returns Observable<{ tag: string }>
   */
  onCompact() {
    return this.compact$.pipe(share());
  }
  /**
   * Toggle a sidebar
   * @param {boolean} compact
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  toggle(compact = false, tag) {
    this.toggle$.next({
      compact,
      tag
    });
  }
  /**
   * Expands a sidebar
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  expand(tag) {
    this.expand$.next({
      tag
    });
  }
  /**
   * Collapses a sidebar
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  collapse(tag) {
    this.collapse$.next({
      tag
    });
  }
  /**
   * Makes sidebar compact
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  compact(tag) {
    this.compact$.next({
      tag
    });
  }
  /**
   * Returns sidebar state observable which emits once
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar state you need
   */
  getSidebarState(tag) {
    const observer = new ReplaySubject(1);
    getSidebarState$.next({
      observer,
      tag
    });
    return observer.pipe(publish(), refCount());
  }
  /**
   * Returns sidebar state observable which emits once
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar responsive state you need
   */
  getSidebarResponsiveState(tag) {
    const observer = new ReplaySubject();
    getSidebarResponsiveState$.next({
      observer,
      tag
    });
    return observer.pipe(publish(), refCount());
  }
};
_NbSidebarService.ɵfac = function NbSidebarService_Factory(t) {
  return new (t || _NbSidebarService)();
};
_NbSidebarService.ɵprov = ɵɵdefineInjectable({
  token: _NbSidebarService,
  factory: _NbSidebarService.ɵfac
});
var NbSidebarService = _NbSidebarService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarService, [{
    type: Injectable
  }], null, null);
})();
var _NbSidebarHeaderComponent = class _NbSidebarHeaderComponent {
};
_NbSidebarHeaderComponent.ɵfac = function NbSidebarHeaderComponent_Factory(t) {
  return new (t || _NbSidebarHeaderComponent)();
};
_NbSidebarHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSidebarHeaderComponent,
  selectors: [["nb-sidebar-header"]],
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbSidebarHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbSidebarHeaderComponent = _NbSidebarHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar-header",
      template: ` <ng-content></ng-content> `
    }]
  }], null, null);
})();
var _NbSidebarFooterComponent = class _NbSidebarFooterComponent {
};
_NbSidebarFooterComponent.ɵfac = function NbSidebarFooterComponent_Factory(t) {
  return new (t || _NbSidebarFooterComponent)();
};
_NbSidebarFooterComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSidebarFooterComponent,
  selectors: [["nb-sidebar-footer"]],
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbSidebarFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbSidebarFooterComponent = _NbSidebarFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar-footer",
      template: ` <ng-content></ng-content> `
    }]
  }], null, null);
})();
var _NbSidebarComponent = class _NbSidebarComponent {
  get expanded() {
    return this.state === "expanded";
  }
  get collapsed() {
    return this.state === "collapsed";
  }
  get compacted() {
    return this.state === "compacted";
  }
  /**
   * Places sidebar on the right side
   * @type {boolean}
   */
  set right(val) {
    this.rightValue = convertToBoolProperty(val);
    this.leftValue = !this.rightValue;
    this.startValue = false;
    this.endValue = false;
  }
  /**
   * Places sidebar on the left side
   * @type {boolean}
   */
  set left(val) {
    this.leftValue = convertToBoolProperty(val);
    this.rightValue = !this.leftValue;
    this.startValue = false;
    this.endValue = false;
  }
  /**
   * Places sidebar on the start edge of layout
   * @type {boolean}
   */
  set start(val) {
    this.startValue = convertToBoolProperty(val);
    this.endValue = !this.startValue;
    this.leftValue = false;
    this.rightValue = false;
  }
  /**
   * Places sidebar on the end edge of layout
   * @type {boolean}
   */
  set end(val) {
    this.endValue = convertToBoolProperty(val);
    this.startValue = !this.endValue;
    this.leftValue = false;
    this.rightValue = false;
  }
  /**
   * Makes sidebar fixed (shown above the layout content)
   * @type {boolean}
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
  /**
   * Makes sidebar container fixed
   * @type {boolean}
   */
  set containerFixed(val) {
    this.containerFixedValue = convertToBoolProperty(val);
  }
  /**
   * Initial sidebar state, `expanded`|`collapsed`|`compacted`
   * @type {string}
   */
  get state() {
    return this._state;
  }
  set state(value) {
    this._state = value;
  }
  /**
   * Makes sidebar listen to media query events and change its behaviour
   * @type {boolean}
   */
  get responsive() {
    return this._responsive;
  }
  set responsive(value) {
    if (this.responsive !== convertToBoolProperty(value)) {
      this._responsive = !this.responsive;
      this.responsiveValueChange$.next(this.responsive);
    }
  }
  constructor(sidebarService, themeService, element, cd) {
    this.sidebarService = sidebarService;
    this.themeService = themeService;
    this.element = element;
    this.cd = cd;
    this.responsiveValueChange$ = new Subject();
    this.responsiveState = "pc";
    this.destroy$ = new Subject();
    this.containerFixedValue = true;
    this.fixedValue = false;
    this.rightValue = false;
    this.leftValue = true;
    this.startValue = false;
    this.endValue = false;
    this._state = "expanded";
    this._responsive = false;
    this.compactedBreakpoints = ["xs", "is", "sm", "md", "lg"];
    this.collapsedBreakpoints = ["xs", "is"];
    this.stateChange = new EventEmitter();
    this.responsiveStateChange = new EventEmitter();
  }
  ngOnInit() {
    this.sidebarService.onToggle().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      compact
    }) => this.toggle(compact));
    this.sidebarService.onExpand().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.expand());
    this.sidebarService.onCollapse().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.collapse());
    this.sidebarService.onCompact().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.compact());
    getSidebarState$.pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      observer
    }) => observer.next(this.state));
    getSidebarResponsiveState$.pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      observer
    }) => observer.next(this.responsiveState));
    this.responsiveValueChange$.pipe(filter((responsive) => !responsive), takeUntil(this.destroy$)).subscribe(() => this.expand());
    this.subscribeToMediaQueryChange();
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  // TODO: this is more of a workaround, should be a better way to make components communicate to each other
  onClick(event) {
    const menu = this.element.nativeElement.querySelector("nb-menu");
    if (menu && menu.contains(event.target)) {
      const link = this.getMenuLink(event.target);
      if (link && link.nextElementSibling && link.nextElementSibling.classList.contains("menu-items")) {
        this.sidebarService.expand(this.tag);
      }
    }
  }
  /**
   * Collapses the sidebar
   */
  collapse() {
    this.updateState("collapsed");
  }
  /**
   * Expands the sidebar
   */
  expand() {
    this.updateState("expanded");
  }
  /**
   * Compacts the sidebar (minimizes)
   */
  compact() {
    this.updateState("compacted");
  }
  /**
   * Toggles sidebar state (expanded|collapsed|compacted)
   * @param {boolean} compact If true, then sidebar state will be changed between expanded & compacted,
   * otherwise - between expanded & collapsed. False by default.
   *
   * Toggle sidebar state
   *
   * ```ts
   * this.sidebar.toggle(true);
   * ```
   */
  toggle(compact = false) {
    if (this.responsive) {
      if (this.responsiveState === "mobile") {
        compact = false;
      }
    }
    if (this.state === "compacted" || this.state === "collapsed") {
      this.updateState("expanded");
    } else {
      this.updateState(compact ? "compacted" : "collapsed");
    }
  }
  subscribeToMediaQueryChange() {
    combineLatest([this.responsiveValueChange$.pipe(startWith(this.responsive)), this.themeService.onMediaQueryChange()]).pipe(filter(([responsive]) => responsive), map(([, breakpoints]) => breakpoints), takeUntil(this.destroy$)).subscribe(([prev, current]) => {
      const isCollapsed = this.collapsedBreakpoints.includes(current.name);
      const isCompacted = this.compactedBreakpoints.includes(current.name);
      let newResponsiveState;
      if (isCompacted) {
        this.fixed = this.containerFixedValue;
        this.compact();
        newResponsiveState = "tablet";
      }
      if (isCollapsed) {
        this.fixed = true;
        this.collapse();
        newResponsiveState = "mobile";
      }
      if (!isCollapsed && !isCompacted && (!prev.width || prev.width < current.width)) {
        this.expand();
        this.fixed = false;
        newResponsiveState = "pc";
      }
      if (newResponsiveState && newResponsiveState !== this.responsiveState) {
        this.responsiveState = newResponsiveState;
        this.responsiveStateChange.emit(this.responsiveState);
        this.cd.markForCheck();
      }
    });
  }
  getMenuLink(element) {
    if (!element || element.tagName.toLowerCase() === "nb-menu") {
      return void 0;
    }
    if (element.tagName.toLowerCase() === "a") {
      return element;
    }
    return this.getMenuLink(element.parentElement);
  }
  updateState(state2) {
    if (this.state !== state2) {
      this.state = state2;
      this.stateChange.emit(this.state);
      this.cd.markForCheck();
    }
  }
};
_NbSidebarComponent.ɵfac = function NbSidebarComponent_Factory(t) {
  return new (t || _NbSidebarComponent)(ɵɵdirectiveInject(NbSidebarService), ɵɵdirectiveInject(NbThemeService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbSidebarComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSidebarComponent,
  selectors: [["nb-sidebar"]],
  hostVars: 16,
  hostBindings: function NbSidebarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("fixed", ctx.fixedValue)("right", ctx.rightValue)("left", ctx.leftValue)("start", ctx.startValue)("end", ctx.endValue)("expanded", ctx.expanded)("collapsed", ctx.collapsed)("compacted", ctx.compacted);
    }
  },
  inputs: {
    right: "right",
    left: "left",
    start: "start",
    end: "end",
    fixed: "fixed",
    containerFixed: "containerFixed",
    state: "state",
    responsive: "responsive",
    tag: "tag",
    compactedBreakpoints: "compactedBreakpoints",
    collapsedBreakpoints: "collapsedBreakpoints"
  },
  outputs: {
    stateChange: "stateChange",
    responsiveStateChange: "responsiveStateChange"
  },
  ngContentSelectors: _c19,
  decls: 5,
  vars: 2,
  consts: [[1, "main-container"], [1, "scrollable", 3, "click"]],
  template: function NbSidebarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c18);
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementStart(2, "div", 1);
      ɵɵlistener("click", function NbSidebarComponent_Template_div_click_2_listener($event) {
        return ctx.onClick($event);
      });
      ɵɵprojection(3, 1);
      ɵɵelementEnd();
      ɵɵprojection(4, 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("main-container-fixed", ctx.containerFixedValue);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}[_nghost-%COMP%]   .scrollable[_ngcontent-%COMP%]{overflow-y:auto;overflow-x:hidden;flex:1}[_nghost-%COMP%]   .main-container[_ngcontent-%COMP%]{transform:translateZ(0);display:flex;flex-direction:column}[_nghost-%COMP%]   .main-container-fixed[_ngcontent-%COMP%]{position:fixed}.right[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=ltr]   .right[_nghost-%COMP%]{order:4}[dir=rtl]   .right[_nghost-%COMP%]{order:0}.end[_nghost-%COMP%]{order:4}[dir=ltr]   .end[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=rtl]   .end[_nghost-%COMP%]{margin-left:0;margin-right:auto}.fixed[_nghost-%COMP%]{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}.fixed.right[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.start[_nghost-%COMP%]{left:0}[dir=rtl]   .fixed.start[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.end[_nghost-%COMP%]{right:0}[dir=rtl]   .fixed.end[_nghost-%COMP%]{left:0}[_nghost-%COMP%]     nb-sidebar-footer{margin-top:auto;display:block}[_nghost-%COMP%]     nb-sidebar-header{display:block}"],
  changeDetection: 0
});
var NbSidebarComponent = _NbSidebarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar",
      template: `
    <div class="main-container" [class.main-container-fixed]="containerFixedValue">
      <ng-content select="nb-sidebar-header"></ng-content>
      <div class="scrollable" (click)="onClick($event)">
        <ng-content></ng-content>
      </div>
      <ng-content select="nb-sidebar-footer"></ng-content>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}:host .scrollable{overflow-y:auto;overflow-x:hidden;flex:1}:host .main-container{transform:translateZ(0);display:flex;flex-direction:column}:host .main-container-fixed{position:fixed}:host.right{margin-right:0;margin-left:auto}[dir=ltr] :host.right{order:4}[dir=rtl] :host.right{order:0}:host.end{order:4}[dir=ltr] :host.end{margin-right:0;margin-left:auto}[dir=rtl] :host.end{margin-left:0;margin-right:auto}:host.fixed{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}:host.fixed.right{right:0}[dir=ltr] :host.fixed.start{left:0}[dir=rtl] :host.fixed.start{right:0}[dir=ltr] :host.fixed.end{right:0}[dir=rtl] :host.fixed.end{left:0}:host ::ng-deep nb-sidebar-footer{margin-top:auto;display:block}:host ::ng-deep nb-sidebar-header{display:block}\n"]
    }]
  }], () => [{
    type: NbSidebarService
  }, {
    type: NbThemeService
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    rightValue: [{
      type: HostBinding,
      args: ["class.right"]
    }],
    leftValue: [{
      type: HostBinding,
      args: ["class.left"]
    }],
    startValue: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    endValue: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.expanded"]
    }],
    collapsed: [{
      type: HostBinding,
      args: ["class.collapsed"]
    }],
    compacted: [{
      type: HostBinding,
      args: ["class.compacted"]
    }],
    right: [{
      type: Input
    }],
    left: [{
      type: Input
    }],
    start: [{
      type: Input
    }],
    end: [{
      type: Input
    }],
    fixed: [{
      type: Input
    }],
    containerFixed: [{
      type: Input
    }],
    state: [{
      type: Input
    }],
    responsive: [{
      type: Input
    }],
    tag: [{
      type: Input
    }],
    compactedBreakpoints: [{
      type: Input
    }],
    collapsedBreakpoints: [{
      type: Input
    }],
    stateChange: [{
      type: Output
    }],
    responsiveStateChange: [{
      type: Output
    }]
  });
})();
var NB_SIDEBAR_COMPONENTS = [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent];
var NB_SIDEBAR_PROVIDERS = [NbSidebarService];
var _NbSidebarModule = class _NbSidebarModule {
  static forRoot() {
    return {
      ngModule: _NbSidebarModule,
      providers: [...NB_SIDEBAR_PROVIDERS]
    };
  }
};
_NbSidebarModule.ɵfac = function NbSidebarModule_Factory(t) {
  return new (t || _NbSidebarModule)();
};
_NbSidebarModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSidebarModule,
  declarations: [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent],
  imports: [NbSharedModule],
  exports: [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent]
});
_NbSidebarModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbSidebarModule = _NbSidebarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_SIDEBAR_COMPONENTS],
      exports: [...NB_SIDEBAR_COMPONENTS]
    }]
  }], null, null);
})();
var _NbTabContentDirective = class _NbTabContentDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
_NbTabContentDirective.ɵfac = function NbTabContentDirective_Factory(t) {
  return new (t || _NbTabContentDirective)(ɵɵdirectiveInject(TemplateRef));
};
_NbTabContentDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTabContentDirective,
  selectors: [["", "nbTabContent", ""]]
});
var NbTabContentDirective = _NbTabContentDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabContentDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTabContent]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NbTabTitleDirective = class _NbTabTitleDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
_NbTabTitleDirective.ɵfac = function NbTabTitleDirective_Factory(t) {
  return new (t || _NbTabTitleDirective)(ɵɵdirectiveInject(TemplateRef));
};
_NbTabTitleDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTabTitleDirective,
  selectors: [["", "nbTabTitle", ""]]
});
var NbTabTitleDirective = _NbTabTitleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabTitleDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTabTitle]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NbTabComponent = class _NbTabComponent {
  constructor() {
    this.activeValue = false;
    this.responsiveValue = false;
    this.disabledValue = false;
    this.badgeStatus = "basic";
    this.init = false;
  }
  /**
   * Use badge dot mode
   * @type {boolean}
   */
  get badgeDot() {
    return this._badgeDot;
  }
  set badgeDot(val) {
    this._badgeDot = convertToBoolProperty(val);
  }
  /**
   * Item is disabled and cannot be opened.
   * @type {boolean}
   */
  get disabled() {
    return this.disabledValue;
  }
  set disabled(val) {
    this.disabledValue = convertToBoolProperty(val);
  }
  /**
   * Show only icons when width is smaller than `tabs-icon-only-max-width`
   * @type {boolean}
   */
  set responsive(val) {
    this.responsiveValue = convertToBoolProperty(val);
  }
  get responsive() {
    return this.responsiveValue;
  }
  /**
   * Specifies active tab
   * @returns {boolean}
   */
  get active() {
    return this.activeValue;
  }
  set active(val) {
    this.activeValue = convertToBoolProperty(val);
    if (this.activeValue) {
      this.init = true;
    }
  }
  /**
   * Lazy load content before tab selection
   * @docs-private
   * @deprecated This setting never worked. Wrap content into a `nbTabContent` to make it lazy.
   * @breaking-change Remove 12.0.0
   */
  set lazyLoad(val) {
    this.init = convertToBoolProperty(val);
  }
};
_NbTabComponent.ɵfac = function NbTabComponent_Factory(t) {
  return new (t || _NbTabComponent)();
};
_NbTabComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTabComponent,
  selectors: [["nb-tab"]],
  contentQueries: function NbTabComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbTabContentDirective, 5);
      ɵɵcontentQuery(dirIndex, NbTabTitleDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabContentDirective = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabTitleDirective = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function NbTabComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("disabled", ctx.disabled)("content-active", ctx.activeValue);
    }
  },
  inputs: {
    tabTitle: "tabTitle",
    tabId: "tabId",
    badgeDot: "badgeDot",
    tabIcon: "tabIcon",
    disabled: "disabled",
    responsive: "responsive",
    route: "route",
    active: "active",
    lazyLoad: "lazyLoad",
    badgeText: "badgeText",
    badgeStatus: "badgeStatus",
    badgePosition: "badgePosition"
  },
  ngContentSelectors: _c03,
  decls: 3,
  vars: 2,
  consts: [["projectedContent", ""], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"]],
  template: function NbTabComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, NbTabComponent_ng_container_0_Template, 1, 1, "ng-container", 1)(1, NbTabComponent_ng_template_1_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const projectedContent_r2 = ɵɵreference(2);
      ɵɵproperty("ngIf", ctx.tabContentDirective)("ngIfElse", projectedContent_r2);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
var NbTabComponent = _NbTabComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabComponent, [{
    type: Component,
    args: [{
      selector: "nb-tab",
      template: `
    <ng-container
      *ngIf="tabContentDirective; else projectedContent"
      [ngTemplateOutlet]="tabContentDirective.templateRef"
    ></ng-container>

    <ng-template #projectedContent>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    tabContentDirective: [{
      type: ContentChild,
      args: [NbTabContentDirective]
    }],
    tabTitleDirective: [{
      type: ContentChild,
      args: [NbTabTitleDirective]
    }],
    tabTitle: [{
      type: Input
    }],
    tabId: [{
      type: Input
    }],
    badgeDot: [{
      type: Input
    }],
    tabIcon: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    responsive: [{
      type: Input
    }],
    route: [{
      type: Input
    }],
    activeValue: [{
      type: HostBinding,
      args: ["class.content-active"]
    }],
    active: [{
      type: Input
    }],
    lazyLoad: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }]
  });
})();
var _NbTabsetComponent = class _NbTabsetComponent {
  /**
   * Take full width of a parent
   * @param {boolean} val
   */
  set fullWidth(val) {
    this.fullWidthValue = convertToBoolProperty(val);
  }
  constructor(route, changeDetectorRef) {
    this.route = route;
    this.changeDetectorRef = changeDetectorRef;
    this.fullWidthValue = false;
    this.changeTab = new EventEmitter();
    this.destroy$ = new Subject();
  }
  // TODO: refactoring this component, avoid change detection loop
  ngAfterContentInit() {
    this.route.params.pipe(map((params) => this.tabs.find((tab) => this.routeParam ? tab.route === params[this.routeParam] : tab.active)), delay(0), map((tab) => tab || this.tabs.first), filter((tab) => !!tab), takeUntil(this.destroy$)).subscribe((tabToSelect) => {
      this.selectTab(tabToSelect);
      this.changeDetectorRef.markForCheck();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  // TODO: navigate to routeParam
  selectTab(selectedTab) {
    if (!selectedTab.disabled) {
      this.tabs.forEach((tab) => tab.active = tab === selectedTab);
      this.changeTab.emit(selectedTab);
    }
  }
};
_NbTabsetComponent.ɵfac = function NbTabsetComponent_Factory(t) {
  return new (t || _NbTabsetComponent)(ɵɵdirectiveInject(ActivatedRoute), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbTabsetComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTabsetComponent,
  selectors: [["nb-tabset"]],
  contentQueries: function NbTabsetComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbTabComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabs = _t);
    }
  },
  hostVars: 2,
  hostBindings: function NbTabsetComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("full-width", ctx.fullWidthValue);
    }
  },
  inputs: {
    fullWidth: "fullWidth",
    routeParam: "routeParam"
  },
  outputs: {
    changeTab: "changeTab"
  },
  ngContentSelectors: _c21,
  decls: 3,
  vars: 1,
  consts: [["textTitleTemplate", ""], [1, "tabset"], ["class", "tab", 3, "responsive", "active", "disabled", "click", "keyup.space", "keyup.enter", 4, "ngFor", "ngForOf"], [1, "tab", 3, "click", "keyup.space", "keyup.enter"], ["href", "", "tabindex", "-1", 1, "tab-link", 3, "click"], [3, "config", 4, "ngIf"], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], [3, "text", "dotMode", "status", "position", 4, "ngIf"], [3, "config"], [3, "ngTemplateOutlet"], [1, "tab-text"], [3, "text", "dotMode", "status", "position"]],
  template: function NbTabsetComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c20);
      ɵɵelementStart(0, "ul", 1);
      ɵɵtemplate(1, NbTabsetComponent_li_1_Template, 7, 12, "li", 2);
      ɵɵelementEnd();
      ɵɵprojection(2);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.tabs);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, NbBadgeComponent, NbIconComponent],
  styles: ['\n\n\n\n\n[_nghost-%COMP%]{display:block}.full-width[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{justify-content:space-around}[_nghost-%COMP%]     nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}[_nghost-%COMP%]     nb-tab.content-active{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;position:relative}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{display:flex;position:relative;text-decoration:none}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}']
});
var NbTabsetComponent = _NbTabsetComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabsetComponent, [{
    type: Component,
    args: [{
      selector: "nb-tabset",
      template: `
    <ul class="tabset">
      <li
        *ngFor="let tab of tabs"
        (click)="selectTab(tab)"
        (keyup.space)="selectTab(tab)"
        (keyup.enter)="selectTab(tab)"
        [class.responsive]="tab.responsive"
        [class.active]="tab.active"
        [class.disabled]="tab.disabled"
        [attr.tabindex]="tab.disabled ? -1 : 0"
        [attr.data-tab-id]="tab.tabId"
        class="tab"
      >
        <a href (click)="$event.preventDefault()" tabindex="-1" class="tab-link">
          <nb-icon *ngIf="tab.tabIcon" [config]="tab.tabIcon"></nb-icon>
          <ng-container
            *ngIf="tab.tabTitleDirective; else textTitleTemplate"
            [ngTemplateOutlet]="tab.tabTitleDirective.templateRef"
          ></ng-container>
          <ng-template #textTitleTemplate>
            <span class="tab-text">{{ tab.tabTitle }}</span>
          </ng-template>
        </a>
        <nb-badge
          *ngIf="tab.badgeText || tab.badgeDot"
          [text]="tab.badgeText"
          [dotMode]="tab.badgeDot"
          [status]="tab.badgeStatus"
          [position]="tab.badgePosition"
        >
        </nb-badge>
      </li>
    </ul>
    <ng-content select="nb-tab"></ng-content>
  `,
      styles: ['/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:block}:host.full-width .tabset{justify-content:space-around}:host ::ng-deep nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}:host ::ng-deep nb-tab.content-active{display:block}:host .tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}:host .tabset .tab{margin-bottom:-1px;text-align:center;position:relative}:host .tabset .tab.active a:before{display:block}:host .tabset .tab a{display:flex;position:relative;text-decoration:none}:host .tabset .tab a:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}:host .tabset .tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tabset .tab a nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tabset .tab a nb-icon+span{margin-right:.5rem}\n']
    }]
  }], () => [{
    type: ActivatedRoute
  }, {
    type: ChangeDetectorRef
  }], {
    tabs: [{
      type: ContentChildren,
      args: [NbTabComponent]
    }],
    fullWidthValue: [{
      type: HostBinding,
      args: ["class.full-width"]
    }],
    fullWidth: [{
      type: Input
    }],
    routeParam: [{
      type: Input
    }],
    changeTab: [{
      type: Output
    }]
  });
})();
var NB_TABSET_COMPONENTS = [NbTabsetComponent, NbTabComponent];
var NB_TABSET_DIRECTIVES = [NbTabContentDirective, NbTabTitleDirective];
var _NbTabsetModule = class _NbTabsetModule {
};
_NbTabsetModule.ɵfac = function NbTabsetModule_Factory(t) {
  return new (t || _NbTabsetModule)();
};
_NbTabsetModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTabsetModule,
  declarations: [NbTabsetComponent, NbTabComponent, NbTabContentDirective, NbTabTitleDirective],
  imports: [NbSharedModule, NbBadgeModule, NbIconModule],
  exports: [NbTabsetComponent, NbTabComponent, NbTabContentDirective, NbTabTitleDirective]
});
_NbTabsetModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbBadgeModule, NbIconModule]
});
var NbTabsetModule = _NbTabsetModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabsetModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule, NbIconModule],
      declarations: [...NB_TABSET_COMPONENTS, ...NB_TABSET_DIRECTIVES],
      exports: [...NB_TABSET_COMPONENTS, ...NB_TABSET_DIRECTIVES]
    }]
  }], null, null);
})();
var _NbUserComponent = class _NbUserComponent {
  /**
   * Absolute path to a user picture or base64 image.
   * User name initials will be shown if no picture specified (JD for John Doe).
   * @type string
   */
  set picture(value) {
    this.imageBackgroundStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
  }
  /**
   * Whether to show a user name or not
   */
  get showName() {
    return this._showName;
  }
  set showName(val) {
    this._showName = convertToBoolProperty(val);
  }
  /**
   * Whether to show a user title or not
   * @type boolean
   */
  get showTitle() {
    return this._showTitle;
  }
  set showTitle(val) {
    this._showTitle = convertToBoolProperty(val);
  }
  /**
   * Whether to show a user initials (if no picture specified) or not
   * @type boolean
   */
  get showInitials() {
    return this._showInitials;
  }
  set showInitials(val) {
    this._showInitials = convertToBoolProperty(val);
  }
  /**
   * Whether to show only a picture or also show the name and title
   * @type boolean
   */
  get onlyPicture() {
    return !this.showName && !this.showTitle;
  }
  set onlyPicture(val) {
    this.showName = this.showTitle = !convertToBoolProperty(val);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get round() {
    return this.shape === "round";
  }
  constructor(domSanitizer) {
    this.domSanitizer = domSanitizer;
    this.name = "Anonymous";
    this.size = "medium";
    this.shape = "round";
    this._showName = true;
    this._showTitle = true;
    this._showInitials = true;
    this.badgeStatus = "basic";
  }
  getInitials() {
    if (this.name) {
      const names = this.name.split(" ");
      return names.map((n) => n.charAt(0)).splice(0, 2).join("").toUpperCase();
    }
    return "";
  }
};
_NbUserComponent.ɵfac = function NbUserComponent_Factory(t) {
  return new (t || _NbUserComponent)(ɵɵdirectiveInject(DomSanitizer));
};
_NbUserComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbUserComponent,
  selectors: [["nb-user"]],
  hostVars: 16,
  hostBindings: function NbUserComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
    }
  },
  inputs: {
    name: "name",
    title: "title",
    picture: "picture",
    color: "color",
    size: "size",
    shape: "shape",
    showName: "showName",
    showTitle: "showTitle",
    showInitials: "showInitials",
    onlyPicture: "onlyPicture",
    badgeText: "badgeText",
    badgeStatus: "badgeStatus",
    badgePosition: "badgePosition"
  },
  decls: 6,
  vars: 4,
  consts: [[1, "user-container"], ["class", "user-picture image", 3, "background-image", 4, "ngIf"], ["class", "user-picture initials", 3, "background-color", 4, "ngIf"], [1, "info-container"], ["class", "user-name", 4, "ngIf"], ["class", "user-title", 4, "ngIf"], [1, "user-picture", "image"], [3, "text", "status", "position", 4, "ngIf"], [3, "text", "status", "position"], [1, "user-picture", "initials"], [4, "ngIf"], [1, "user-name"], [1, "user-title"]],
  template: function NbUserComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, NbUserComponent_div_1_Template, 2, 3, "div", 1)(2, NbUserComponent_div_2_Template, 3, 4, "div", 2);
      ɵɵelementStart(3, "div", 3);
      ɵɵtemplate(4, NbUserComponent_div_4_Template, 2, 1, "div", 4)(5, NbUserComponent_div_5_Template, 2, 1, "div", 5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.imageBackgroundStyle);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.imageBackgroundStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showName && ctx.name);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showTitle && ctx.title);
    }
  },
  dependencies: [NgIf, NbBadgeComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex}[_nghost-%COMP%]   .user-container[_ngcontent-%COMP%]{position:relative;display:flex;align-items:center}[_nghost-%COMP%]   .user-picture[_ngcontent-%COMP%]{position:relative;flex-shrink:0}[_nghost-%COMP%]   .user-picture.image[_ngcontent-%COMP%]{background-size:cover;background-repeat:no-repeat}[_nghost-%COMP%]   .user-picture.initials[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}[dir=rtl]   [_nghost-%COMP%]   .user-name[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .user-title[_ngcontent-%COMP%]{text-align:right}[dir=ltr]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-right:.5rem}"]
});
var NbUserComponent = _NbUserComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbUserComponent, [{
    type: Component,
    args: [{
      selector: "nb-user",
      template: '<div class="user-container">\n  <div *ngIf="imageBackgroundStyle" class="user-picture image" [style.background-image]="imageBackgroundStyle">\n    <nb-badge *ngIf="badgeText" [text]="badgeText" [status]="badgeStatus" [position]="badgePosition"></nb-badge>\n  </div>\n  <div *ngIf="!imageBackgroundStyle" class="user-picture initials" [style.background-color]="color">\n    <ng-container *ngIf="showInitials">\n      {{ getInitials() }}\n    </ng-container>\n    <nb-badge *ngIf="badgeText" [text]="badgeText" [status]="badgeStatus" [position]="badgePosition"></nb-badge>\n  </div>\n\n  <div class="info-container">\n    <div *ngIf="showName && name" class="user-name">{{ name }}</div>\n    <div *ngIf="showTitle && title" class="user-title">{{ title }}</div>\n  </div>\n</div>\n',
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex}:host .user-container{position:relative;display:flex;align-items:center}:host .user-picture{position:relative;flex-shrink:0}:host .user-picture.image{background-size:cover;background-repeat:no-repeat}:host .user-picture.initials{display:flex;align-items:center;justify-content:center}[dir=rtl] :host .user-name,[dir=rtl] :host .user-title{text-align:right}[dir=ltr] :host .info-container{margin-left:.5rem}[dir=rtl] :host .info-container{margin-right:.5rem}\n"]
    }]
  }], () => [{
    type: DomSanitizer
  }], {
    name: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    picture: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    showName: [{
      type: Input
    }],
    showTitle: [{
      type: Input
    }],
    showInitials: [{
      type: Input
    }],
    onlyPicture: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }]
  });
})();
var NB_USER_COMPONENTS = [NbUserComponent];
var _NbUserModule = class _NbUserModule {
};
_NbUserModule.ɵfac = function NbUserModule_Factory(t) {
  return new (t || _NbUserModule)();
};
_NbUserModule.ɵmod = ɵɵdefineNgModule({
  type: _NbUserModule,
  declarations: [NbUserComponent],
  imports: [NbSharedModule, NbBadgeModule],
  exports: [NbUserComponent]
});
_NbUserModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbBadgeModule]
});
var NbUserModule = _NbUserModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbUserModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule],
      declarations: [...NB_USER_COMPONENTS],
      exports: [...NB_USER_COMPONENTS]
    }]
  }], null, null);
})();
var _NbActionComponent = class _NbActionComponent {
  constructor() {
    this.title = "";
    this._disabled = false;
    this.badgeStatus = "basic";
  }
  /**
   * Visually disables the item
   * @type boolean
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * Use badge dot mode
   * @type boolean
   */
  get badgeDot() {
    return this._badgeDot;
  }
  set badgeDot(value) {
    this._badgeDot = convertToBoolProperty(value);
  }
};
_NbActionComponent.ɵfac = function NbActionComponent_Factory(t) {
  return new (t || _NbActionComponent)();
};
_NbActionComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbActionComponent,
  selectors: [["nb-action"]],
  hostVars: 2,
  hostBindings: function NbActionComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("disabled", ctx.disabled);
    }
  },
  inputs: {
    link: "link",
    href: "href",
    title: "title",
    icon: "icon",
    disabled: "disabled",
    badgeDot: "badgeDot",
    badgeText: "badgeText",
    badgeStatus: "badgeStatus",
    badgePosition: "badgePosition"
  },
  ngContentSelectors: _c03,
  decls: 5,
  vars: 2,
  consts: [["projectedContent", ""], ["badgeTemplate", ""], [4, "ngIf", "ngIfElse"], ["class", "icon-container", 3, "routerLink", "title", 4, "ngIf"], ["class", "icon-container", 3, "href", "title", 4, "ngIf"], ["class", "icon-container", "href", "#", 3, "title", "click", 4, "ngIf"], [1, "icon-container", 3, "routerLink", "title"], [3, "config"], [3, "ngTemplateOutlet"], [1, "icon-container", 3, "href", "title"], ["href", "#", 1, "icon-container", 3, "click", "title"], [3, "text", "dotMode", "status", "position", 4, "ngIf"], [3, "text", "dotMode", "status", "position"]],
  template: function NbActionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, NbActionComponent_ng_container_0_Template, 4, 3, "ng-container", 2)(1, NbActionComponent_ng_template_1_Template, 2, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, NbActionComponent_ng_template_3_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const projectedContent_r4 = ɵɵreference(2);
      ɵɵproperty("ngIf", ctx.icon)("ngIfElse", projectedContent_r4);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, RouterLink, NbBadgeComponent, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{background:transparent;display:flex;align-items:center;position:relative}.disabled[_nghost-%COMP%]{cursor:not-allowed}.disabled[_nghost-%COMP%]   a[_ngcontent-%COMP%], .disabled[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{cursor:not-allowed}nb-actions.full-width[_nghost-%COMP%], nb-actions.full-width   [_nghost-%COMP%]{justify-content:center;width:100%}a.icon-container[_ngcontent-%COMP%]{position:relative}a.icon-container[_ngcontent-%COMP%]:hover, a.icon-container[_ngcontent-%COMP%]:focus{text-decoration:none}nb-icon[_ngcontent-%COMP%]:hover{cursor:pointer}"]
});
var NbActionComponent = _NbActionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionComponent, [{
    type: Component,
    args: [{
      selector: "nb-action",
      template: `
    <ng-container *ngIf="icon; else projectedContent">
      <a class="icon-container"
         [routerLink]="link"
         [title]="title"
         *ngIf="link">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
      <a class="icon-container"
         [href]="href"
         [title]="title"
         *ngIf="href && !link">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
      <a class="icon-container"
         href="#"
         [title]="title"
         *ngIf="!href && !link"
         (click)="$event.preventDefault()">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
    </ng-container>

    <ng-template #projectedContent>
      <ng-content></ng-content>
      <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
    </ng-template>
    <ng-template #badgeTemplate>
      <nb-badge *ngIf="badgeText || badgeDot"
                [text]="badgeText"
                [dotMode]="badgeDot"
                [status]="badgeStatus"
                [position]="badgePosition">
      </nb-badge>
    </ng-template>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{background:transparent;display:flex;align-items:center;position:relative}:host(.disabled){cursor:not-allowed}:host(.disabled) a,:host(.disabled) nb-icon{cursor:not-allowed}:host-context(nb-actions.full-width){justify-content:center;width:100%}a.icon-container{position:relative}a.icon-container:hover,a.icon-container:focus{text-decoration:none}nb-icon:hover{cursor:pointer}\n"]
    }]
  }], null, {
    link: [{
      type: Input
    }],
    href: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    badgeDot: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }]
  });
})();
var _NbActionsComponent = class _NbActionsComponent {
  constructor() {
    this._size = "small";
    this._fullWidth = false;
  }
  /**
   * Size of the component: 'tiny', 'small' (default), 'medium', 'large', 'giant'
   */
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
  }
  /**
   * Component will fill full width of the container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
};
_NbActionsComponent.ɵfac = function NbActionsComponent_Factory(t) {
  return new (t || _NbActionsComponent)();
};
_NbActionsComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbActionsComponent,
  selectors: [["nb-actions"]],
  hostVars: 12,
  hostBindings: function NbActionsComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    }
  },
  inputs: {
    size: "size",
    fullWidth: "fullWidth"
  },
  ngContentSelectors: _c23,
  decls: 1,
  vars: 0,
  template: function NbActionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c22);
      ɵɵprojection(0);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;align-items:center}"]
});
var NbActionsComponent = _NbActionsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionsComponent, [{
    type: Component,
    args: [{
      selector: "nb-actions",
      template: `
    <ng-content select="nb-action"></ng-content>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;align-items:center}\n"]
    }]
  }], null, {
    size: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var NB_ACTIONS_COMPONENTS = [NbActionComponent, NbActionsComponent];
var _NbActionsModule = class _NbActionsModule {
};
_NbActionsModule.ɵfac = function NbActionsModule_Factory(t) {
  return new (t || _NbActionsModule)();
};
_NbActionsModule.ɵmod = ɵɵdefineNgModule({
  type: _NbActionsModule,
  declarations: [NbActionComponent, NbActionsComponent],
  imports: [NbSharedModule, NbBadgeModule, NbIconModule],
  exports: [NbActionComponent, NbActionsComponent]
});
_NbActionsModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbBadgeModule, NbIconModule]
});
var NbActionsModule = _NbActionsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionsModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule, NbIconModule],
      declarations: [...NB_ACTIONS_COMPONENTS],
      exports: [...NB_ACTIONS_COMPONENTS]
    }]
  }], null, null);
})();
var _NbSearchService = class _NbSearchService {
  constructor() {
    this.searchSubmittings$ = new Subject();
    this.searchActivations$ = new Subject();
    this.searchDeactivations$ = new Subject();
    this.searchInput$ = new Subject();
  }
  /***
   * Activate (open) search component
   * @param {string} searchType
   * @param {string} tag
   */
  activateSearch(searchType, tag) {
    this.searchActivations$.next({
      searchType,
      tag
    });
  }
  /**
   * Deactibate (close) search component
   * @param {string} searchType
   * @param {string} tag
   */
  deactivateSearch(searchType, tag) {
    this.searchDeactivations$.next({
      searchType,
      tag
    });
  }
  /**
   * Trigger search submit
   * @param {string} term
   * @param {string} tag
   */
  submitSearch(term, tag) {
    this.searchSubmittings$.next({
      term,
      tag
    });
  }
  /**
   * Trigger search submit by input event
   * @param {string} term
   * @param {string} tag
   */
  searchInput(term, tag) {
    this.searchInput$.next({
      term,
      tag
    });
  }
  /**
   * Subscribe to 'activate' event
   * @returns Observable<{searchType: string; tag?: string}>
   */
  onSearchActivate() {
    return this.searchActivations$.pipe(share());
  }
  /**
   * Subscribe to 'deactivate' event
   * @returns Observable<{searchType: string; tag?: string}>
   */
  onSearchDeactivate() {
    return this.searchDeactivations$.pipe(share());
  }
  /**
   * Subscribe to 'submit' event (when submit button clicked)
   * @returns Observable<{term: string; tag?: string}>
   */
  onSearchSubmit() {
    return this.searchSubmittings$.pipe(share());
  }
  /**
   * Subscribe to input event
   * @returns Observable<{term: string; tag?: string}>
   */
  onSearchInput() {
    return this.searchInput$.pipe(share());
  }
};
_NbSearchService.ɵfac = function NbSearchService_Factory(t) {
  return new (t || _NbSearchService)();
};
_NbSearchService.ɵprov = ɵɵdefineInjectable({
  token: _NbSearchService,
  factory: _NbSearchService.ɵfac
});
var NbSearchService = _NbSearchService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchService, [{
    type: Injectable
  }], null, null);
})();
var _NbSearchFieldComponent = class _NbSearchFieldComponent {
  constructor() {
    this.show = false;
    this.close = new EventEmitter();
    this.search = new EventEmitter();
    this.searchInput = new EventEmitter();
  }
  get showClass() {
    return this.show;
  }
  get modalZoomin() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_ZOOMIN;
  }
  get rotateLayout() {
    return this.type === _NbSearchFieldComponent.TYPE_ROTATE_LAYOUT;
  }
  get modalMove() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_MOVE;
  }
  get curtain() {
    return this.type === _NbSearchFieldComponent.TYPE_CURTAIN;
  }
  get columnCurtain() {
    return this.type === _NbSearchFieldComponent.TYPE_COLUMN_CURTAIN;
  }
  get modalDrop() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_DROP;
  }
  get modalHalf() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_HALF;
  }
  ngOnChanges({
    show
  }) {
    const becameHidden = !show.isFirstChange() && show.currentValue === false;
    if (becameHidden && this.inputElement) {
      this.inputElement.nativeElement.value = "";
    }
    this.focusInput();
  }
  ngAfterViewInit() {
    this.focusInput();
  }
  emitClose() {
    this.close.emit();
  }
  submitSearch(term) {
    if (term) {
      this.search.emit(term);
    }
  }
  emitSearchInput(term) {
    this.searchInput.emit(term);
  }
  focusInput() {
    if (this.show && this.inputElement) {
      this.inputElement.nativeElement.focus();
    }
  }
};
_NbSearchFieldComponent.TYPE_MODAL_ZOOMIN = "modal-zoomin";
_NbSearchFieldComponent.TYPE_ROTATE_LAYOUT = "rotate-layout";
_NbSearchFieldComponent.TYPE_MODAL_MOVE = "modal-move";
_NbSearchFieldComponent.TYPE_CURTAIN = "curtain";
_NbSearchFieldComponent.TYPE_COLUMN_CURTAIN = "column-curtain";
_NbSearchFieldComponent.TYPE_MODAL_DROP = "modal-drop";
_NbSearchFieldComponent.TYPE_MODAL_HALF = "modal-half";
_NbSearchFieldComponent.ɵfac = function NbSearchFieldComponent_Factory(t) {
  return new (t || _NbSearchFieldComponent)();
};
_NbSearchFieldComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSearchFieldComponent,
  selectors: [["nb-search-field"]],
  viewQuery: function NbSearchFieldComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c24, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    }
  },
  hostVars: 16,
  hostBindings: function NbSearchFieldComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("show", ctx.showClass)("modal-zoomin", ctx.modalZoomin)("rotate-layout", ctx.rotateLayout)("modal-move", ctx.modalMove)("curtain", ctx.curtain)("column-curtain", ctx.columnCurtain)("modal-drop", ctx.modalDrop)("modal-half", ctx.modalHalf);
    }
  },
  inputs: {
    type: "type",
    placeholder: "placeholder",
    hint: "hint",
    show: "show"
  },
  outputs: {
    close: "close",
    search: "search",
    searchInput: "searchInput"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 10,
  vars: 2,
  consts: [["searchInput", ""], [1, "search", 3, "keyup.esc"], ["nbButton", "", "ghost", "", 1, "close-button", 3, "click"], ["icon", "close-outline", "pack", "nebular-essentials"], [1, "form-wrapper"], [1, "form", 3, "keyup.enter"], [1, "form-content"], ["autocomplete", "off", "tabindex", "-1", 1, "search-input", 3, "input", "blur"], [1, "info"]],
  template: function NbSearchFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 1);
      ɵɵlistener("keyup.esc", function NbSearchFieldComponent_Template_div_keyup_esc_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.emitClose());
      });
      ɵɵelementStart(1, "button", 2);
      ɵɵlistener("click", function NbSearchFieldComponent_Template_button_click_1_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.emitClose());
      });
      ɵɵelement(2, "nb-icon", 3);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 4)(4, "form", 5);
      ɵɵlistener("keyup.enter", function NbSearchFieldComponent_Template_form_keyup_enter_4_listener() {
        ɵɵrestoreView(_r1);
        const searchInput_r2 = ɵɵreference(7);
        return ɵɵresetView(ctx.submitSearch(searchInput_r2.value));
      });
      ɵɵelementStart(5, "div", 6)(6, "input", 7, 0);
      ɵɵlistener("input", function NbSearchFieldComponent_Template_input_input_6_listener() {
        ɵɵrestoreView(_r1);
        const searchInput_r2 = ɵɵreference(7);
        return ɵɵresetView(ctx.emitSearchInput(searchInput_r2.value));
      })("blur", function NbSearchFieldComponent_Template_input_blur_6_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.focusInput());
      });
      ɵɵelementEnd()();
      ɵɵelementStart(8, "span", 8);
      ɵɵtext(9);
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      ɵɵadvance(6);
      ɵɵattribute("placeholder", ctx.placeholder);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.hint);
    }
  },
  dependencies: [ɵNgNoValidate, NgControlStatusGroup, NgForm, NbIconComponent, NbButtonComponent],
  styles: ['\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]   button[_ngcontent-%COMP%]{margin:0;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:.05rem 0;-webkit-appearance:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]:focus{outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]::placeholder{opacity:.3}[_nghost-%COMP%]   span[_ngcontent-%COMP%]{font-size:90%;font-weight:700;display:block;width:75%;margin:0 auto;padding:.85rem 0;text-align:right}.modal-zoomin[_nghost-%COMP%]{display:block}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before, .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{content:"";position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px,-15px,0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px,15px,0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before, .modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{transform:translateZ(0);transition:transform .5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40rem){.modal-zoomin[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0 1rem}.modal-zoomin[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}', "\n\n\n\n\n  nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}  nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform .5s cubic-bezier(.2,1,.3,1)}  nb-layout.rotate-layout.with-search .scrollable-container{transition:transform .5s cubic-bezier(.2,1,.3,1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0,50vh,0) rotateX(30deg);pointer-events:none}.rotate-layout[_nghost-%COMP%]{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:.4s}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(.7,.7,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:75%}.rotate-layout.show[_nghost-%COMP%]{opacity:1;transition-delay:0s}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}", "\n\n\n\n\n  nb-layout.modal-move .layout{transition:transform .5s}  nb-layout.modal-move.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{transform:scaleZ(1);transition-duration:.5s}@media screen and (max-width: 40rem){.modal-move[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}", '\n\n\n\n\n\n\n\n\n\n.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform .3s;transition-delay:.4s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transition:transform .3s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;transition:opacity .1s;transition-delay:.3s}[dir=ltr]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:50%;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;font-size:6vw}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{width:100%;pointer-events:auto;transform:translate3d(-100%,0,0);transition-delay:0s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{transform:translate3d(100%,0,0);transition-delay:.4s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40em){.curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2em;width:90%}}  nb-layout.curtain .scrollable-container{position:relative;z-index:0}', '\n\n\n\n\n\n\n\n\n\n  nb-layout.column-curtain.with-search .layout{pointer-events:none}.column-curtain[_nghost-%COMP%]{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}.column-curtain[_nghost-%COMP%]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s;transition-timing-function:cubic-bezier(.86,0,.07,1)}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:relative;padding:2.5rem 1.5rem 0;background:transparent}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:2rem}[dir=rtl]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:2rem}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:85%;transform:translate3d(-150%,0,0);transition:transform .3s}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:2.5rem;width:100%}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:85%}.column-curtain.show[_nghost-%COMP%]{pointer-events:auto}.column-curtain.show[_nghost-%COMP%]:before{transform:scaleZ(1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{transform:translateZ(0);transition-delay:.15s;transition-timing-function:cubic-bezier(.86,0,.07,1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;z-index:100}@media screen and (max-width: 40rem){.column-curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.column-curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2rem;width:90%}}', '\n\n\n\n\n  nb-layout.modal-drop .layout{position:relative;transition:transform .4s,opacity .4s;transition-timing-function:cubic-bezier(.4,0,.2,1)}  nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(.9,.9,1);pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{content:"";position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity .4s}[dir=ltr]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{position:relative;margin:5rem 0 2rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:6vw;width:60%;padding:.25rem;text-align:center;opacity:0;transition:opacity .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:relative;z-index:9;display:block;width:60%;padding:.85rem 0;opacity:0;transform:translate3d(0,-50px,0);transition:opacity .4s,transform .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{position:relative;z-index:10;overflow:hidden;transform:translate3d(0,-50px,0);transition:transform .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]:after{content:"";position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{transform:translateZ(0);transition:none}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]:after{animation:_ngcontent-%COMP%_scaleUpDown .8s cubic-bezier(.4,0,.2,1) forwards}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{opacity:1;transition:opacity 0s .4s}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{opacity:1;transform:translateZ(0);transition-delay:.4s;transition-timing-function:ease-out}@keyframes _ngcontent-%COMP%_scaleUpDown{0%{opacity:1;transform:scale3d(1,0,1)}50%{transform:scaleZ(1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}to{opacity:1;transform:scale3d(1,0,1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){.modal-drop[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:2rem 0}.modal-drop[_nghost-%COMP%]   input[_ngcontent-%COMP%]{width:100%;left:0}}', '\n\n\n\n\n  nb-layout.modal-half .layout{transition:transform .6s,opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}  nb-layout.modal-half.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .6s,transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1);transform:translate3d(0,-100%,0)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:75%;margin:0 auto}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:100%}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{opacity:1}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{transform:translateZ(0)}'],
  changeDetection: 0
});
var NbSearchFieldComponent = _NbSearchFieldComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchFieldComponent, [{
    type: Component,
    args: [{
      selector: "nb-search-field",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <div class="search" (keyup.esc)="emitClose()">
      <button (click)="emitClose()" nbButton ghost class="close-button">
        <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
      </button>
      <div class="form-wrapper">
        <form class="form" (keyup.enter)="submitSearch(searchInput.value)">
          <div class="form-content">
            <input class="search-input"
                   #searchInput
                   (input)="emitSearchInput(searchInput.value)"
                   autocomplete="off"
                   [attr.placeholder]="placeholder"
                   tabindex="-1"
                   (blur)="focusInput()"/>
          </div>
          <span class="info">{{ hint }}</span>
        </form>
      </div>
    </div>
  `,
      styles: ['/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host button{margin:0;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}:host input{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:.05rem 0;-webkit-appearance:none}:host input:focus{outline:none}:host input::placeholder{opacity:.3}:host span{font-size:90%;font-weight:700;display:block;width:75%;margin:0 auto;padding:.85rem 0;text-align:right}:host.modal-zoomin{display:block}:host.modal-zoomin .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}:host.modal-zoomin .search:before,:host.modal-zoomin .search:after{content:"";position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}:host.modal-zoomin .search:before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px,-15px,0)}:host.modal-zoomin .search:after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px,15px,0)}:host.modal-zoomin .search button{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr] :host.modal-zoomin .search button{right:3rem}[dir=rtl] :host.modal-zoomin .search button{left:3rem}:host.modal-zoomin .search input{font-size:10vw;width:75%}:host.modal-zoomin .search button{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-zoomin .search form{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-zoomin.show .search{pointer-events:auto;opacity:1}:host.modal-zoomin.show .search:before,:host.modal-zoomin.show .search:after{transform:translateZ(0);transition:transform .5s}:host.modal-zoomin.show .search button{opacity:1;transform:scaleZ(1)}:host.modal-zoomin.show .search form{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40rem){:host.modal-zoomin form{margin:5rem 0 1rem}:host.modal-zoomin span{text-align:left}}\n', "/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */::ng-deep nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}::ng-deep nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform .5s cubic-bezier(.2,1,.3,1)}::ng-deep nb-layout.rotate-layout.with-search .scrollable-container{transition:transform .5s cubic-bezier(.2,1,.3,1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0,50vh,0) rotateX(30deg);pointer-events:none}:host.rotate-layout{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:.4s}:host.rotate-layout .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.rotate-layout .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr] :host.rotate-layout .search button{right:3rem}[dir=rtl] :host.rotate-layout .search button{left:3rem}:host.rotate-layout .search form{margin:5rem 0;opacity:0;transform:scale3d(.7,.7,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.rotate-layout .search input{font-size:7vw;width:75%}:host.rotate-layout.show{opacity:1;transition-delay:0s}:host.rotate-layout.show .search{pointer-events:auto;opacity:1}:host.rotate-layout.show .search button{opacity:1;transform:scaleZ(1)}:host.rotate-layout.show .search form{opacity:1;transform:scaleZ(1)}\n", "/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */::ng-deep nb-layout.modal-move .layout{transition:transform .5s}::ng-deep nb-layout.modal-move.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}:host.modal-move .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}:host.modal-move .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr] :host.modal-move .search button{right:3rem}[dir=rtl] :host.modal-move .search button{left:3rem}:host.modal-move .search form{margin:5rem 0;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-move .search input{font-size:10vw;width:75%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s}:host.modal-move.show .search{pointer-events:auto;opacity:1}:host.modal-move.show .search button{opacity:1}:host.modal-move.show .search form{opacity:1;transform:scaleZ(1)}:host.modal-move.show .search input{transform:scaleZ(1);transition-duration:.5s}@media screen and (max-width: 40rem){:host.modal-move span{text-align:left}}\n", '/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host.curtain .search{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform .3s;transition-delay:.4s;transition-timing-function:ease-out}:host.curtain .search:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transition:transform .3s;transition-timing-function:ease-out}:host.curtain .search button{font-size:2.5rem;position:absolute;top:3rem;transition:opacity .1s;transition-delay:.3s}[dir=ltr] :host.curtain .search button{right:3rem}[dir=rtl] :host.curtain .search button{left:3rem}:host.curtain .search form{width:50%;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.curtain .search input{width:100%;font-size:6vw}:host.curtain.show .search{width:100%;pointer-events:auto;transform:translate3d(-100%,0,0);transition-delay:0s}:host.curtain.show .search:after{transform:translate3d(100%,0,0);transition-delay:.4s}:host.curtain.show .search button{opacity:1;transform:scaleZ(1)}:host.curtain.show .search form{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40em){:host.curtain span{width:90%}:host.curtain input{font-size:2em;width:90%}}::ng-deep nb-layout.curtain .scrollable-container{position:relative;z-index:0}\n', '/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */::ng-deep nb-layout.column-curtain.with-search .layout{pointer-events:none}:host.column-curtain{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}:host.column-curtain:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s;transition-timing-function:cubic-bezier(.86,0,.07,1)}:host.column-curtain .search{position:relative;padding:2.5rem 1.5rem 0;background:transparent}:host.column-curtain .search button{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr] :host.column-curtain .search button{right:2rem}[dir=rtl] :host.column-curtain .search button{left:2rem}:host.column-curtain .search form{width:85%;transform:translate3d(-150%,0,0);transition:transform .3s}:host.column-curtain .search input{font-size:2.5rem;width:100%}:host.column-curtain .search span{font-size:85%}:host.column-curtain.show{pointer-events:auto}:host.column-curtain.show:before{transform:scaleZ(1)}:host.column-curtain.show .search form{transform:translateZ(0);transition-delay:.15s;transition-timing-function:cubic-bezier(.86,0,.07,1)}:host.column-curtain.show .search button{opacity:1;z-index:100}@media screen and (max-width: 40rem){:host.column-curtain span{width:90%}:host.column-curtain input{font-size:2rem;width:90%}}\n', '/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */::ng-deep nb-layout.modal-drop .layout{position:relative;transition:transform .4s,opacity .4s;transition-timing-function:cubic-bezier(.4,0,.2,1)}::ng-deep nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(.9,.9,1);pointer-events:none}:host.modal-drop .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-drop .search:before{content:"";position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity .4s}:host.modal-drop .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity .4s}[dir=ltr] :host.modal-drop .search button{right:3rem}[dir=rtl] :host.modal-drop .search button{left:3rem}:host.modal-drop .search form{position:relative;margin:5rem 0 2rem}:host.modal-drop .search input{font-size:6vw;width:60%;padding:.25rem;text-align:center;opacity:0;transition:opacity .4s}:host.modal-drop .search span{position:relative;z-index:9;display:block;width:60%;padding:.85rem 0;opacity:0;transform:translate3d(0,-50px,0);transition:opacity .4s,transform .4s}:host.modal-drop .search .form-content{position:relative;z-index:10;overflow:hidden;transform:translate3d(0,-50px,0);transition:transform .4s}:host.modal-drop .search .form-content:after{content:"";position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}:host.modal-drop.show .search{pointer-events:auto}:host.modal-drop.show .search:before{opacity:1}:host.modal-drop.show .search button{opacity:1}:host.modal-drop.show .search .form-content{transform:translateZ(0);transition:none}:host.modal-drop.show .search .form-content:after{animation:scaleUpDown .8s cubic-bezier(.4,0,.2,1) forwards}:host.modal-drop.show .search input{opacity:1;transition:opacity 0s .4s}:host.modal-drop.show .search span{opacity:1;transform:translateZ(0);transition-delay:.4s;transition-timing-function:ease-out}@keyframes scaleUpDown{0%{opacity:1;transform:scale3d(1,0,1)}50%{transform:scaleZ(1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}to{opacity:1;transform:scale3d(1,0,1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){:host.modal-drop form{margin:2rem 0}:host.modal-drop input{width:100%;left:0}}\n', '/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */::ng-deep nb-layout.modal-half .layout{transition:transform .6s,opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}::ng-deep nb-layout.modal-half.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}:host.modal-half .search{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-half .search:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.modal-half .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .6s,transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr] :host.modal-half .search button{right:3rem}[dir=rtl] :host.modal-half .search button{left:3rem}:host.modal-half .search .form-wrapper{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1);transform:translate3d(0,-100%,0)}:host.modal-half .search form{width:75%;margin:0 auto}:host.modal-half .search input{font-size:7vw;width:100%}:host.modal-half.show .search{pointer-events:auto}:host.modal-half.show .search:before{opacity:1}:host.modal-half.show .search button{opacity:1;transform:scaleZ(1)}:host.modal-half.show .search .form-wrapper{transform:translateZ(0)}\n']
    }]
  }], null, {
    type: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    show: [{
      type: Input
    }],
    close: [{
      type: Output
    }],
    search: [{
      type: Output
    }],
    searchInput: [{
      type: Output
    }],
    inputElement: [{
      type: ViewChild,
      args: ["searchInput"]
    }],
    showClass: [{
      type: HostBinding,
      args: ["class.show"]
    }],
    modalZoomin: [{
      type: HostBinding,
      args: ["class.modal-zoomin"]
    }],
    rotateLayout: [{
      type: HostBinding,
      args: ["class.rotate-layout"]
    }],
    modalMove: [{
      type: HostBinding,
      args: ["class.modal-move"]
    }],
    curtain: [{
      type: HostBinding,
      args: ["class.curtain"]
    }],
    columnCurtain: [{
      type: HostBinding,
      args: ["class.column-curtain"]
    }],
    modalDrop: [{
      type: HostBinding,
      args: ["class.modal-drop"]
    }],
    modalHalf: [{
      type: HostBinding,
      args: ["class.modal-half"]
    }]
  });
})();
var _NbSearchComponent = class _NbSearchComponent {
  constructor(searchService, themeService, router, overlayService, changeDetector) {
    this.searchService = searchService;
    this.themeService = themeService;
    this.router = router;
    this.overlayService = overlayService;
    this.changeDetector = changeDetector;
    this.destroy$ = new Subject();
    this.showSearchField = false;
    this.placeholder = "Search...";
    this.hint = "Hit enter to search";
  }
  ngOnInit() {
    this.router.events.pipe(filter((event) => event instanceof NavigationEnd), takeUntil(this.destroy$)).subscribe(() => this.hideSearch());
    this.searchService.onSearchActivate().pipe(filter((data) => !this.tag || data.tag === this.tag), takeUntil(this.destroy$)).subscribe(() => this.openSearch());
    this.searchService.onSearchDeactivate().pipe(filter((data) => !this.tag || data.tag === this.tag), takeUntil(this.destroy$)).subscribe(() => this.hideSearch());
  }
  ngOnDestroy() {
    if (this.overlayRef && this.overlayRef.hasAttached()) {
      this.removeLayoutClasses();
      this.overlayRef.detach();
    }
    this.destroy$.next();
    this.destroy$.complete();
  }
  openSearch() {
    if (!this.overlayRef) {
      this.overlayRef = this.overlayService.create();
      this.overlayRef.attach(this.searchFieldPortal);
    }
    this.themeService.appendLayoutClass(this.type);
    of(null).pipe(delay(0)).subscribe(() => {
      this.themeService.appendLayoutClass("with-search");
      this.showSearchField = true;
      this.changeDetector.detectChanges();
    });
  }
  hideSearch() {
    this.removeLayoutClasses();
    this.showSearchField = false;
    this.changeDetector.detectChanges();
    this.searchButton.nativeElement.focus();
  }
  search(term) {
    this.searchService.submitSearch(term, this.tag);
    this.hideSearch();
  }
  emitInput(term) {
    this.searchService.searchInput(term, this.tag);
  }
  emitActivate() {
    this.searchService.activateSearch(this.type, this.tag);
  }
  emitDeactivate() {
    this.searchService.deactivateSearch(this.type, this.tag);
  }
  removeLayoutClasses() {
    this.themeService.removeLayoutClass("with-search");
    of(null).pipe(delay(500)).subscribe(() => {
      this.themeService.removeLayoutClass(this.type);
    });
  }
};
_NbSearchComponent.ɵfac = function NbSearchComponent_Factory(t) {
  return new (t || _NbSearchComponent)(ɵɵdirectiveInject(NbSearchService), ɵɵdirectiveInject(NbThemeService), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbSearchComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSearchComponent,
  selectors: [["nb-search"]],
  viewQuery: function NbSearchComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalDirective, 5);
      ɵɵviewQuery(_c25, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchFieldPortal = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchButton = _t.first);
    }
  },
  inputs: {
    tag: "tag",
    placeholder: "placeholder",
    hint: "hint",
    type: "type"
  },
  decls: 4,
  vars: 0,
  consts: [["searchButton", ""], ["nbButton", "", "ghost", "", 1, "start-search", 3, "click"], ["icon", "search-outline", "pack", "nebular-essentials"], [3, "show", "type", "placeholder", "hint", "search", "searchInput", "close", 4, "nbPortal"], [3, "search", "searchInput", "close", "show", "type", "placeholder", "hint"]],
  template: function NbSearchComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "button", 1, 0);
      ɵɵlistener("click", function NbSearchComponent_Template_button_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.emitActivate());
      });
      ɵɵelement(2, "nb-icon", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, NbSearchComponent_nb_search_field_3_Template, 1, 4, "nb-search-field", 3);
    }
  },
  dependencies: [NbPortalDirective, NbIconComponent, NbButtonComponent, NbSearchFieldComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]   button[_ngcontent-%COMP%]{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}  nb-layout.with-search .scrollable-container{position:relative;z-index:0}"],
  changeDetection: 0
});
var NbSearchComponent = _NbSearchComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchComponent, [{
    type: Component,
    args: [{
      selector: "nb-search",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <button #searchButton class="start-search" (click)="emitActivate()" nbButton ghost>
      <nb-icon icon="search-outline" pack="nebular-essentials"></nb-icon>
    </button>
    <nb-search-field
      *nbPortal
      [show]="showSearchField"
      [type]="type"
      [placeholder]="placeholder"
      [hint]="hint"
      (search)="search($event)"
      (searchInput)="emitInput($event)"
      (close)="emitDeactivate()">
    </nb-search-field>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host button{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}::ng-deep nb-layout.with-search .scrollable-container{position:relative;z-index:0}\n"]
    }]
  }], () => [{
    type: NbSearchService
  }, {
    type: NbThemeService
  }, {
    type: Router
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }], {
    tag: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    searchFieldPortal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    searchButton: [{
      type: ViewChild,
      args: ["searchButton", {
        read: ElementRef
      }]
    }]
  });
})();
var _NbSearchModule = class _NbSearchModule {
};
_NbSearchModule.ɵfac = function NbSearchModule_Factory(t) {
  return new (t || _NbSearchModule)();
};
_NbSearchModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSearchModule,
  declarations: [NbSearchComponent, NbSearchFieldComponent],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule],
  exports: [NbSearchComponent, NbSearchFieldComponent]
});
_NbSearchModule.ɵinj = ɵɵdefineInjector({
  providers: [NbSearchService],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule]
});
var NbSearchModule = _NbSearchModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule],
      declarations: [NbSearchComponent, NbSearchFieldComponent],
      exports: [NbSearchComponent, NbSearchFieldComponent],
      providers: [NbSearchService]
    }]
  }], null, null);
})();
var _NbCheckboxComponent = class _NbCheckboxComponent {
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._checked = convertToBoolProperty(value);
  }
  /**
   * Controls input disabled state
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * Controls checkbox indeterminate state
   */
  get indeterminate() {
    return this._indeterminate;
  }
  set indeterminate(value) {
    this._indeterminate = convertToBoolProperty(value);
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get info() {
    return this.status === "info";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(changeDetector, renderer, hostElement, zone, statusService) {
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.zone = zone;
    this.statusService = statusService;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this._indeterminate = false;
    this.checkedChange = new EventEmitter();
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(val) {
    this._checked = val;
    this.changeDetector.markForCheck();
  }
  setDisabledState(val) {
    this.disabled = convertToBoolProperty(val);
    this.changeDetector.markForCheck();
  }
  setTouched() {
    this.onTouched();
  }
  updateValueAndIndeterminate(event) {
    const input = event.target;
    this.checked = input.checked;
    this.checkedChange.emit(this.checked);
    this.onChange(this.checked);
    this.indeterminate = input.indeterminate;
  }
};
_NbCheckboxComponent.ɵfac = function NbCheckboxComponent_Factory(t) {
  return new (t || _NbCheckboxComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbCheckboxComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCheckboxComponent,
  selectors: [["nb-checkbox"]],
  hostVars: 16,
  hostBindings: function NbCheckboxComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    checked: "checked",
    disabled: "disabled",
    status: "status",
    indeterminate: "indeterminate"
  },
  outputs: {
    checkedChange: "checkedChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbCheckboxComponent),
    multi: true
  }])],
  ngContentSelectors: _c03,
  decls: 7,
  vars: 9,
  consts: [[1, "label"], ["type", "checkbox", 1, "native-input", "visually-hidden", 3, "change", "blur", "click", "disabled", "checked", "indeterminate"], [1, "custom-checkbox"], ["icon", "minus-bold-outline", "pack", "nebular-essentials", "class", "custom-checkbox-icon", 4, "ngIf"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", "class", "custom-checkbox-icon", 4, "ngIf"], [1, "text"], ["icon", "minus-bold-outline", "pack", "nebular-essentials", 1, "custom-checkbox-icon"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 1, "custom-checkbox-icon"]],
  template: function NbCheckboxComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "label", 0)(1, "input", 1);
      ɵɵlistener("change", function NbCheckboxComponent_Template_input_change_1_listener($event) {
        return ctx.updateValueAndIndeterminate($event);
      })("blur", function NbCheckboxComponent_Template_input_blur_1_listener() {
        return ctx.setTouched();
      })("click", function NbCheckboxComponent_Template_input_click_1_listener($event) {
        return $event.stopPropagation();
      });
      ɵɵelementEnd();
      ɵɵelementStart(2, "span", 2);
      ɵɵtemplate(3, NbCheckboxComponent_nb_icon_3_Template, 1, 0, "nb-icon", 3)(4, NbCheckboxComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
      ɵɵelementEnd();
      ɵɵelementStart(5, "span", 5);
      ɵɵprojection(6);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("disabled", ctx.disabled)("checked", ctx.checked)("indeterminate", ctx.indeterminate);
      ɵɵadvance();
      ɵɵclassProp("indeterminate", ctx.indeterminate)("checked", ctx.checked);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.indeterminate);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.checked && !ctx.indeterminate);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]   .label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{flex-shrink:0}.nb-transition[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.nb-transition[_nghost-%COMP%]   .text[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:color;transition-timing-function:ease-in}"],
  changeDetection: 0
});
var NbCheckboxComponent = _NbCheckboxComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCheckboxComponent, [{
    type: Component,
    args: [{
      selector: "nb-checkbox",
      template: `
    <label class="label">
      <input type="checkbox" class="native-input visually-hidden"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValueAndIndeterminate($event)"
             (blur)="setTouched()"
             (click)="$event.stopPropagation()"
             [indeterminate]="indeterminate">
      <span [class.indeterminate]="indeterminate" [class.checked]="checked" class="custom-checkbox">
        <nb-icon *ngIf="indeterminate" icon="minus-bold-outline" pack="nebular-essentials" class="custom-checkbox-icon"></nb-icon>
        <nb-icon *ngIf="checked && !indeterminate" icon="checkmark-bold-outline" pack="nebular-essentials" class="custom-checkbox-icon"></nb-icon>
      </span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbCheckboxComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host .label{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}:host .custom-checkbox{flex-shrink:0}:host(.nb-transition) .custom-checkbox{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}:host(.nb-transition) .text{transition-duration:.15s;transition-property:color;transition-timing-function:ease-in}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    indeterminate: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbCheckboxModule = class _NbCheckboxModule {
};
_NbCheckboxModule.ɵfac = function NbCheckboxModule_Factory(t) {
  return new (t || _NbCheckboxModule)();
};
_NbCheckboxModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCheckboxModule,
  declarations: [NbCheckboxComponent],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbCheckboxComponent]
});
_NbCheckboxModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbCheckboxModule = _NbCheckboxModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCheckboxModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbCheckboxComponent],
      exports: [NbCheckboxComponent]
    }]
  }], null, null);
})();
var _NbDynamicOverlay = class _NbDynamicOverlay {
  get isAttached() {
    return this.ref && this.ref.hasAttached();
  }
  get isShown() {
    return this.isShown$.pipe(distinctUntilChanged());
  }
  constructor(overlay, componentFactoryResolver, zone, overlayContainer) {
    this.overlay = overlay;
    this.componentFactoryResolver = componentFactoryResolver;
    this.zone = zone;
    this.overlayContainer = overlayContainer;
    this.context = {};
    this.overlayConfig = {};
    this.disabled = false;
    this.positionStrategyChange$ = new Subject();
    this.isShown$ = new BehaviorSubject(false);
    this.destroy$ = new Subject();
    this.overlayDestroy$ = new Subject();
  }
  create(componentType, content, context, positionStrategy, overlayConfig = {}, disabled = false) {
    this.setContentAndContext(content, context);
    this.setComponent(componentType);
    this.setPositionStrategy(positionStrategy);
    this.setOverlayConfig(overlayConfig);
    this.setDisabled(disabled);
    return this;
  }
  setContent(content) {
    this.content = content;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setContext(context) {
    this.context = context;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setContentAndContext(content, context) {
    this.content = content;
    this.context = context;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setComponent(componentType) {
    this.componentType = componentType;
    const wasAttached = this.isAttached;
    this.disposeOverlayRef();
    if (wasAttached) {
      this.show();
    }
  }
  setPositionStrategy(positionStrategy) {
    this.positionStrategyChange$.next();
    this.positionStrategy = positionStrategy;
    this.positionStrategy.positionChange.pipe(filter(() => !!this.container), takeUntil(merge(this.positionStrategyChange$, this.destroy$))).subscribe((position) => {
      this.lastAppliedPosition = position;
      patch(this.container, {
        position
      });
    });
    if (this.ref) {
      this.ref.updatePositionStrategy(this.positionStrategy);
    }
  }
  setOverlayConfig(overlayConfig) {
    this.overlayConfig = overlayConfig;
    const wasAttached = this.isAttached;
    this.disposeOverlayRef();
    if (wasAttached) {
      this.show();
    }
  }
  setDisabled(disabled) {
    if (disabled && this.isShown$.value) {
      this.hide();
    }
    this.disabled = disabled;
  }
  show() {
    if (this.disabled) {
      return;
    }
    if (!this.ref) {
      this.createOverlay();
    }
    this.renderContainer();
    if (!this.hasOverlayInContainer()) {
      this.disposeOverlayRef();
      return this.show();
    }
    this.isShown$.next(true);
  }
  hide() {
    if (!this.ref) {
      return;
    }
    this.ref.detach();
    this.container = null;
    this.isShown$.next(false);
  }
  toggle() {
    if (this.isAttached) {
      this.hide();
    } else {
      this.show();
    }
  }
  dispose() {
    this.destroy$.next();
    this.destroy$.complete();
    this.hide();
    this.disposeOverlayRef();
    this.isShown$.complete();
    this.positionStrategyChange$.complete();
    this.overlayDestroy$.complete();
  }
  getContainer() {
    return this.container;
  }
  createOverlay() {
    this.ref = this.overlay.create(__spreadValues({
      positionStrategy: this.positionStrategy,
      scrollStrategy: this.overlay.scrollStrategies.reposition()
    }, this.overlayConfig));
    this.updatePositionWhenStable(this.ref);
  }
  renderContainer() {
    const containerContext = this.createContainerContext();
    if (!this.container) {
      this.container = createContainer(this.ref, this.componentType, containerContext, this.componentFactoryResolver);
    }
    this.container.instance.renderContent();
  }
  updateContext() {
    const containerContext = this.createContainerContext();
    Object.assign(this.container.instance, containerContext);
    this.container.instance.renderContent();
    this.container.changeDetectorRef.detectChanges();
  }
  createContainerContext() {
    return {
      content: this.content,
      context: this.context,
      cfr: this.componentFactoryResolver,
      position: this.lastAppliedPosition
    };
  }
  /**
   * Dimensions of the container may change after content update. So we listen to zone.stable event to
   * reposition the container.
   */
  updatePositionWhenStable(overlay) {
    const overlayDestroy$ = this.overlayDestroy$.pipe(filter((destroyedOverlay) => destroyedOverlay === overlay));
    this.zone.onStable.pipe(take(1), takeUntil(merge(this.destroy$, overlayDestroy$))).subscribe(() => this.updatePosition());
  }
  updatePosition() {
    if (this.ref) {
      this.ref.updatePosition();
    }
  }
  hasOverlayInContainer() {
    return this.overlayContainer.getContainerElement().contains(this.ref.hostElement);
  }
  disposeOverlayRef() {
    if (this.ref) {
      this.ref.dispose();
      this.overlayDestroy$.next(this.ref);
      this.ref = null;
      this.container = null;
    }
  }
};
_NbDynamicOverlay.ɵfac = function NbDynamicOverlay_Factory(t) {
  return new (t || _NbDynamicOverlay)(ɵɵinject(NbOverlayService), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NgZone), ɵɵinject(NbOverlayContainer));
};
_NbDynamicOverlay.ɵprov = ɵɵdefineInjectable({
  token: _NbDynamicOverlay,
  factory: _NbDynamicOverlay.ɵfac
});
var NbDynamicOverlay = _NbDynamicOverlay;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDynamicOverlay, [{
    type: Injectable
  }], () => [{
    type: NbOverlayService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: NgZone
  }, {
    type: NbOverlayContainer
  }], null);
})();
var NbDynamicOverlayChange = class extends SimpleChange {
  constructor(previousValue, currentValue, firstChange = false) {
    super(previousValue, currentValue, firstChange);
  }
  isChanged() {
    return this.currentValue !== this.previousValue;
  }
};
var _NbDynamicOverlayHandler = class _NbDynamicOverlayHandler {
  constructor(positionBuilder, triggerStrategyBuilder, dynamicOverlayService, directionService) {
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.dynamicOverlayService = dynamicOverlayService;
    this.directionService = directionService;
    this._context = {};
    this._trigger = NbTrigger.NOOP;
    this._disabled = false;
    this._position = NbPosition.TOP;
    this._adjustment = NbAdjustment.NOOP;
    this._offset = 15;
    this._overlayConfig = {};
    this.changes = {};
    this.destroy$ = new Subject();
  }
  host(host) {
    this.changes.host = new NbDynamicOverlayChange(this._host, host);
    this._host = host;
    return this;
  }
  trigger(trigger2) {
    this.changes.trigger = new NbDynamicOverlayChange(this._trigger, trigger2);
    this._trigger = trigger2;
    return this;
  }
  disabled(disabled) {
    this.changes.disabled = new NbDynamicOverlayChange(this._disabled, disabled);
    this._disabled = disabled;
    return this;
  }
  position(position) {
    this.changes.position = new NbDynamicOverlayChange(this._position, position);
    this._position = position;
    return this;
  }
  adjustment(adjustment) {
    this.changes.adjustment = new NbDynamicOverlayChange(this._adjustment, adjustment);
    this._adjustment = adjustment;
    return this;
  }
  componentType(componentType) {
    this.changes.componentType = new NbDynamicOverlayChange(this._componentType, componentType);
    this._componentType = componentType;
    return this;
  }
  content(content) {
    this.changes.content = new NbDynamicOverlayChange(this._content, content);
    this._content = content;
    return this;
  }
  context(context) {
    this.changes.context = new NbDynamicOverlayChange(this._context, context);
    this._context = context;
    return this;
  }
  offset(offset) {
    this.changes.offset = new NbDynamicOverlayChange(this._offset, offset);
    this._offset = offset;
    return this;
  }
  overlayConfig(overlayConfig) {
    this.changes.overlayConfig = new NbDynamicOverlayChange(this._overlayConfig, overlayConfig);
    this._overlayConfig = overlayConfig;
    return this;
  }
  build() {
    if (!this._componentType || !this._host) {
      throw Error(`NbDynamicOverlayHandler: at least 'componentType' and 'host' should be
      passed before building a dynamic overlay.`);
    }
    this.dynamicOverlay = this.dynamicOverlayService.create(this._componentType, this._content, this._context, this.createPositionStrategy(), this._overlayConfig, this._disabled);
    this.connect();
    this.clearChanges();
    return this.dynamicOverlay;
  }
  rebuild() {
    if (!this.dynamicOverlay) {
      return void 0;
    }
    if (this.isPositionStrategyUpdateRequired()) {
      this.dynamicOverlay.setPositionStrategy(this.createPositionStrategy());
    }
    if (this.isTriggerStrategyUpdateRequired()) {
      this.connect();
    }
    if (this.isContainerRerenderRequired()) {
      this.dynamicOverlay.setContentAndContext(this._content, this._context);
    }
    if (this.isComponentTypeUpdateRequired()) {
      this.dynamicOverlay.setComponent(this._componentType);
    }
    if (this.isOverlayConfigUpdateRequired()) {
      this.dynamicOverlay.setOverlayConfig(this._overlayConfig);
    }
    if (this.isDisabledUpdated()) {
      this.dynamicOverlay.setDisabled(this._disabled);
    }
    this.clearChanges();
    return this.dynamicOverlay;
  }
  connect() {
    if (!this.dynamicOverlay) {
      throw new Error(`NbDynamicOverlayHandler: cannot connect to DynamicOverlay
      as it is not created yet. Call build() first`);
    }
    this.disconnect();
    this.subscribeOnTriggers(this.dynamicOverlay);
    this.subscribeOnDirectionChange();
  }
  disconnect() {
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  destroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.disconnect();
    this.clearChanges();
    if (this.dynamicOverlay) {
      this.dynamicOverlay.dispose();
    }
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this._host).position(this._position).adjustment(this._adjustment).offset(this._offset).direction(this.directionService.getDirection());
  }
  subscribeOnTriggers(dynamicOverlay) {
    this.triggerStrategy = this.triggerStrategyBuilder.trigger(this._trigger).host(this._host.nativeElement).container(() => dynamicOverlay.getContainer()).build();
    this.triggerStrategy.show$.subscribe(() => dynamicOverlay.show());
    this.triggerStrategy.hide$.subscribe(() => dynamicOverlay.hide());
  }
  subscribeOnDirectionChange() {
    this.directionService.onDirectionChange().pipe(skip(1), takeUntil(this.destroy$)).subscribe(() => {
      this.dynamicOverlay.setPositionStrategy(this.createPositionStrategy());
    });
  }
  isContainerRerenderRequired() {
    return this.isContentUpdated() || this.isContextUpdated() || this.isPositionStrategyUpdateRequired();
  }
  isPositionStrategyUpdateRequired() {
    return this.isAdjustmentUpdated() || this.isPositionUpdated() || this.isOffsetUpdated() || this.isHostUpdated();
  }
  isTriggerStrategyUpdateRequired() {
    return this.isTriggerUpdated() || this.isHostUpdated();
  }
  isComponentTypeUpdateRequired() {
    return this.isComponentTypeUpdated();
  }
  isOverlayConfigUpdateRequired() {
    return this.isOverlayConfigUpdated();
  }
  isComponentTypeUpdated() {
    return this.changes.componentType && this.changes.componentType.isChanged();
  }
  isContentUpdated() {
    return this.changes.content && this.changes.content.isChanged();
  }
  isContextUpdated() {
    return this.changes.context && this.changes.context.isChanged();
  }
  isAdjustmentUpdated() {
    return this.changes.adjustment && this.changes.adjustment.isChanged();
  }
  isPositionUpdated() {
    return this.changes.position && this.changes.position.isChanged();
  }
  isHostUpdated() {
    return this.changes.host && this.changes.host.isChanged();
  }
  isTriggerUpdated() {
    return this.changes.trigger && this.changes.trigger.isChanged();
  }
  isOffsetUpdated() {
    return this.changes.offset && this.changes.offset.isChanged();
  }
  isOverlayConfigUpdated() {
    return this.changes.overlayConfig && this.changes.overlayConfig.isChanged();
  }
  isDisabledUpdated() {
    return this.changes.disabled && this.changes.disabled.isChanged();
  }
  clearChanges() {
    this.changes = {};
  }
};
_NbDynamicOverlayHandler.ɵfac = function NbDynamicOverlayHandler_Factory(t) {
  return new (t || _NbDynamicOverlayHandler)(ɵɵinject(NbPositionBuilderService), ɵɵinject(NbTriggerStrategyBuilderService), ɵɵinject(NbDynamicOverlay), ɵɵinject(NbLayoutDirectionService));
};
_NbDynamicOverlayHandler.ɵprov = ɵɵdefineInjectable({
  token: _NbDynamicOverlayHandler,
  factory: _NbDynamicOverlayHandler.ɵfac
});
var NbDynamicOverlayHandler = _NbDynamicOverlayHandler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDynamicOverlayHandler, [{
    type: Injectable
  }], () => [{
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbDynamicOverlay
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var _NbPopoverComponent = class _NbPopoverComponent extends NbPositionedContainerComponent {
  renderContent() {
    this.detachContent();
    this.attachContent();
  }
  detachContent() {
    this.overlayContainer.detach();
  }
  attachContent() {
    if (this.content instanceof TemplateRef) {
      this.attachTemplate();
    } else if (this.content instanceof Type) {
      this.attachComponent();
    } else {
      this.attachString();
    }
  }
  attachTemplate() {
    this.overlayContainer.attachTemplatePortal(new NbTemplatePortal(this.content, null, {
      $implicit: this.context
    }));
  }
  attachComponent() {
    const portal = new NbComponentPortal(this.content, null, null, this.cfr);
    const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
    ref.changeDetectorRef.detectChanges();
  }
  attachString() {
    this.overlayContainer.attachStringContent(this.content);
  }
};
_NbPopoverComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbPopoverComponent_BaseFactory;
  return function NbPopoverComponent_Factory(t) {
    return (ɵNbPopoverComponent_BaseFactory || (ɵNbPopoverComponent_BaseFactory = ɵɵgetInheritedFactory(_NbPopoverComponent)))(t || _NbPopoverComponent);
  };
})();
_NbPopoverComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbPopoverComponent,
  selectors: [["nb-popover"]],
  viewQuery: function NbPopoverComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbOverlayContainerComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    }
  },
  inputs: {
    content: "content",
    context: "context",
    cfr: "cfr"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 0,
  consts: [[1, "arrow"]],
  template: function NbPopoverComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "span", 0)(1, "nb-overlay-container");
    }
  },
  dependencies: [NbOverlayContainerComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}"]
});
var NbPopoverComponent = _NbPopoverComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverComponent, [{
    type: Component,
    args: [{
      selector: "nb-popover",
      template: `
    <span class="arrow"></span>
    <nb-overlay-container></nb-overlay-container>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host .arrow{position:absolute;width:0;height:0}\n"]
    }]
  }], null, {
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent]
    }],
    content: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    cfr: [{
      type: Input
    }]
  });
})();
var _NbPopoverDirective = class _NbPopoverDirective {
  /**
   * Container position will be changes automatically based on this strategy if container can't fit view port.
   * Set this property to `noop` value if you want to disable automatically adjustment.
   * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
   * */
  get adjustment() {
    return this._adjustment;
  }
  set adjustment(value) {
    this._adjustment = value;
  }
  get popoverClass() {
    return this._popoverClass;
  }
  set popoverClass(value) {
    if (value !== this.popoverClass) {
      this._popoverClass = value;
      this.overlayConfig = {
        panelClass: this.popoverClass
      };
    }
  }
  get isShown() {
    return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
  }
  constructor(hostRef, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.popoverComponent = NbPopoverComponent;
    this.destroy$ = new Subject();
    this.context = {};
    this.position = NbPosition.TOP;
    this._adjustment = NbAdjustment.CLOCKWISE;
    this.trigger = NbTrigger.CLICK;
    this.offset = 15;
    this.disabled = false;
    this._popoverClass = "";
    this.nbPopoverShowStateChange = new EventEmitter();
    this.overlayConfig = {
      panelClass: this.popoverClass
    };
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(this.popoverComponent);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.dynamicOverlay.isShown.pipe(skip(1), takeUntil(this.destroy$)).subscribe((isShown) => this.nbPopoverShowStateChange.emit({
      isShown
    }));
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).disabled(this.disabled).offset(this.offset).adjustment(this.adjustment).content(this.content).context(this.context).overlayConfig(this.overlayConfig);
  }
};
_NbPopoverDirective.ɵfac = function NbPopoverDirective_Factory(t) {
  return new (t || _NbPopoverDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbDynamicOverlayHandler));
};
_NbPopoverDirective.ɵdir = ɵɵdefineDirective({
  type: _NbPopoverDirective,
  selectors: [["", "nbPopover", ""]],
  inputs: {
    content: [InputFlags.None, "nbPopover", "content"],
    context: [InputFlags.None, "nbPopoverContext", "context"],
    position: [InputFlags.None, "nbPopoverPlacement", "position"],
    adjustment: [InputFlags.None, "nbPopoverAdjustment", "adjustment"],
    trigger: [InputFlags.None, "nbPopoverTrigger", "trigger"],
    offset: [InputFlags.None, "nbPopoverOffset", "offset"],
    disabled: [InputFlags.None, "nbTooltipDisabled", "disabled"],
    popoverClass: [InputFlags.None, "nbPopoverClass", "popoverClass"]
  },
  outputs: {
    nbPopoverShowStateChange: "nbPopoverShowStateChange"
  },
  exportAs: ["nbPopover"],
  features: [ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵɵNgOnChangesFeature]
});
var NbPopoverDirective = _NbPopoverDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPopover]",
      exportAs: "nbPopover",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbDynamicOverlayHandler
  }], {
    content: [{
      type: Input,
      args: ["nbPopover"]
    }],
    context: [{
      type: Input,
      args: ["nbPopoverContext"]
    }],
    position: [{
      type: Input,
      args: ["nbPopoverPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbPopoverAdjustment"]
    }],
    trigger: [{
      type: Input,
      args: ["nbPopoverTrigger"]
    }],
    offset: [{
      type: Input,
      args: ["nbPopoverOffset"]
    }],
    disabled: [{
      type: Input,
      args: ["nbTooltipDisabled"]
    }],
    popoverClass: [{
      type: Input,
      args: ["nbPopoverClass"]
    }],
    nbPopoverShowStateChange: [{
      type: Output
    }]
  });
})();
var _NbPopoverModule = class _NbPopoverModule {
};
_NbPopoverModule.ɵfac = function NbPopoverModule_Factory(t) {
  return new (t || _NbPopoverModule)();
};
_NbPopoverModule.ɵmod = ɵɵdefineNgModule({
  type: _NbPopoverModule,
  declarations: [NbPopoverDirective, NbPopoverComponent],
  imports: [NbOverlayModule],
  exports: [NbPopoverDirective]
});
_NbPopoverModule.ɵinj = ɵɵdefineInjector({
  imports: [NbOverlayModule]
});
var NbPopoverModule = _NbPopoverModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverModule, [{
    type: NgModule,
    args: [{
      imports: [NbOverlayModule],
      declarations: [NbPopoverDirective, NbPopoverComponent],
      exports: [NbPopoverDirective]
    }]
  }], null, null);
})();
var _NbContextMenuComponent = class _NbContextMenuComponent extends NbPositionedContainerComponent {
  constructor() {
    super(...arguments);
    this.items = [];
    this.context = {
      items: []
    };
  }
  /**
   * The method is empty since we don't need to do anything additionally
   * render is handled by change detection
   */
  renderContent() {
  }
};
_NbContextMenuComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbContextMenuComponent_BaseFactory;
  return function NbContextMenuComponent_Factory(t) {
    return (ɵNbContextMenuComponent_BaseFactory || (ɵNbContextMenuComponent_BaseFactory = ɵɵgetInheritedFactory(_NbContextMenuComponent)))(t || _NbContextMenuComponent);
  };
})();
_NbContextMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbContextMenuComponent,
  selectors: [["nb-context-menu"]],
  inputs: {
    items: "items",
    tag: "tag",
    context: "context"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 2,
  consts: [[1, "context-menu", 3, "items", "tag"]],
  template: function NbContextMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "nb-menu", 0);
    }
    if (rf & 2) {
      ɵɵproperty("items", ctx.context.items)("tag", ctx.context.tag);
    }
  },
  dependencies: [NbMenuComponent],
  encapsulation: 2
});
var NbContextMenuComponent = _NbContextMenuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuComponent, [{
    type: Component,
    args: [{
      selector: "nb-context-menu",
      template: `
    <nb-menu class="context-menu" [items]="context.items" [tag]="context.tag"></nb-menu>
  `
    }]
  }], null, {
    items: [{
      type: Input
    }],
    tag: [{
      type: Input
    }],
    context: [{
      type: Input
    }]
  });
})();
var _NbContextMenuDirective = class _NbContextMenuDirective {
  /**
   * Position will be calculated relatively host element based on the position.
   * Can be top, right, bottom and left.
   * */
  get position() {
    return this._position;
  }
  set position(value) {
    if (value !== this.position) {
      this._position = value;
      this.updateOverlayContext();
    }
  }
  /**
   * Set NbMenu tag, which helps identify menu when working with NbMenuService.
   * */
  get tag() {
    return this._tag;
  }
  set tag(value) {
    if (value !== this.tag) {
      this._tag = value;
      this.updateOverlayContext();
    }
  }
  /**
   * Basic menu items, will be passed to the internal NbMenuComponent.
   * */
  get items() {
    return this._items;
  }
  set items(items) {
    this.validateItems(items);
    this._items = items;
    this.updateOverlayContext();
  }
  get contextMenuClass() {
    return this._contextMenuClass;
  }
  set contextMenuClass(value) {
    if (value !== this.contextMenuClass) {
      this._contextMenuClass = value;
      this.overlayConfig = {
        panelClass: this.contextMenuClass
      };
    }
  }
  constructor(hostRef, menuService, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.menuService = menuService;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.contextMenuHost = true;
    this._position = NbPosition.BOTTOM;
    this.adjustment = NbAdjustment.CLOCKWISE;
    this.trigger = NbTrigger.CLICK;
    this._contextMenuClass = "";
    this.overlayConfig = {
      panelClass: this.contextMenuClass
    };
    this.overlayContext = {
      items: this.items,
      tag: this.tag,
      position: this.position
    };
    this.destroy$ = new Subject();
    this._items = [];
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(NbContextMenuComponent);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.subscribeOnItemClick();
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).adjustment(this.adjustment).context(this.overlayContext).overlayConfig(this.overlayConfig);
  }
  /*
   * NbMenuComponent will crash if don't pass menu items to it.
   * So, we just validating them and throw custom obvious error.
   * */
  validateItems(items) {
    if (!items || !items.length) {
      throw Error(`List of menu items expected, but given: ${items}`);
    }
  }
  subscribeOnItemClick() {
    this.menuService.onItemClick().pipe(filter(({
      tag
    }) => tag === this.tag && this.trigger !== NbTrigger.NOOP), takeUntil(this.destroy$)).subscribe(() => this.hide());
  }
  updateOverlayContext() {
    this.overlayContext = {
      items: this.items,
      position: this.position,
      tag: this.tag
    };
  }
};
_NbContextMenuDirective.ɵfac = function NbContextMenuDirective_Factory(t) {
  return new (t || _NbContextMenuDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbMenuService), ɵɵdirectiveInject(NbDynamicOverlayHandler));
};
_NbContextMenuDirective.ɵdir = ɵɵdefineDirective({
  type: _NbContextMenuDirective,
  selectors: [["", "nbContextMenu", ""]],
  hostVars: 2,
  hostBindings: function NbContextMenuDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("context-menu-host", ctx.contextMenuHost);
    }
  },
  inputs: {
    position: [InputFlags.None, "nbContextMenuPlacement", "position"],
    adjustment: [InputFlags.None, "nbContextMenuAdjustment", "adjustment"],
    tag: [InputFlags.None, "nbContextMenuTag", "tag"],
    items: [InputFlags.None, "nbContextMenu", "items"],
    trigger: [InputFlags.None, "nbContextMenuTrigger", "trigger"],
    contextMenuClass: [InputFlags.None, "nbContextMenuClass", "contextMenuClass"]
  },
  features: [ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵɵNgOnChangesFeature]
});
var NbContextMenuDirective = _NbContextMenuDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuDirective, [{
    type: Directive,
    args: [{
      selector: "[nbContextMenu]",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbMenuService
  }, {
    type: NbDynamicOverlayHandler
  }], {
    contextMenuHost: [{
      type: HostBinding,
      args: ["class.context-menu-host"]
    }],
    position: [{
      type: Input,
      args: ["nbContextMenuPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbContextMenuAdjustment"]
    }],
    tag: [{
      type: Input,
      args: ["nbContextMenuTag"]
    }],
    items: [{
      type: Input,
      args: ["nbContextMenu"]
    }],
    trigger: [{
      type: Input,
      args: ["nbContextMenuTrigger"]
    }],
    contextMenuClass: [{
      type: Input,
      args: ["nbContextMenuClass"]
    }]
  });
})();
var _NbContextMenuModule = class _NbContextMenuModule {
};
_NbContextMenuModule.ɵfac = function NbContextMenuModule_Factory(t) {
  return new (t || _NbContextMenuModule)();
};
_NbContextMenuModule.ɵmod = ɵɵdefineNgModule({
  type: _NbContextMenuModule,
  declarations: [NbContextMenuDirective, NbContextMenuComponent],
  imports: [CommonModule, NbOverlayModule, NbMenuModule],
  exports: [NbContextMenuDirective]
});
_NbContextMenuModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbOverlayModule, NbMenuModule]
});
var NbContextMenuModule = _NbContextMenuModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbMenuModule],
      exports: [NbContextMenuDirective],
      declarations: [NbContextMenuDirective, NbContextMenuComponent]
    }]
  }], null, null);
})();
var _NbProgressBarComponent = class _NbProgressBarComponent {
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.value = 0;
    this.status = "basic";
    this.size = "medium";
    this.displayValue = false;
  }
};
_NbProgressBarComponent.ɵfac = function NbProgressBarComponent_Factory(t) {
  return new (t || _NbProgressBarComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbProgressBarComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbProgressBarComponent,
  selectors: [["nb-progress-bar"]],
  hostVars: 26,
  hostBindings: function NbProgressBarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    value: "value",
    status: "status",
    size: "size",
    displayValue: "displayValue"
  },
  ngContentSelectors: _c03,
  decls: 4,
  vars: 3,
  consts: [[1, "progress-container"], [1, "progress-value"], [4, "ngIf"]],
  template: function NbProgressBarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵtemplate(2, NbProgressBarComponent_span_2_Template, 2, 1, "span", 2);
      ɵɵprojection(3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵstyleProp("width", ctx.value, "%");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.displayValue);
    }
  },
  dependencies: [NgIf],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:block}.progress-container[_ngcontent-%COMP%]{overflow:hidden}.progress-value[_ngcontent-%COMP%]{height:100%;text-align:center;overflow:hidden}"]
});
var NbProgressBarComponent = _NbProgressBarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbProgressBarComponent, [{
    type: Component,
    args: [{
      selector: "nb-progress-bar",
      template: `
    <div class="progress-container">
      <div class="progress-value" [style.width.%]="value">
        <span *ngIf="displayValue">{{ value }}%</span>
        <ng-content></ng-content>
      </div>
    </div>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:block}.progress-container{overflow:hidden}.progress-value{height:100%;text-align:center;overflow:hidden}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    value: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    displayValue: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbProgressBarModule = class _NbProgressBarModule {
};
_NbProgressBarModule.ɵfac = function NbProgressBarModule_Factory(t) {
  return new (t || _NbProgressBarModule)();
};
_NbProgressBarModule.ɵmod = ɵɵdefineNgModule({
  type: _NbProgressBarModule,
  declarations: [NbProgressBarComponent],
  imports: [NbSharedModule],
  exports: [NbProgressBarComponent]
});
_NbProgressBarModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbProgressBarModule = _NbProgressBarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbProgressBarModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [NbProgressBarComponent],
      exports: [NbProgressBarComponent]
    }]
  }], null, null);
})();
var _NbAlertComponent = class _NbAlertComponent {
  /**
   * Shows `close` icon
   */
  get closable() {
    return this._closable;
  }
  set closable(value) {
    this._closable = convertToBoolProperty(value);
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.size = "";
    this.status = "basic";
    this.accent = "";
    this.outline = "";
    this._closable = false;
    this.close = new EventEmitter();
  }
  /**
   * Emits the removed chip event
   */
  onClose() {
    this.close.emit();
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get primaryAccent() {
    return this.accent === "primary";
  }
  get successAccent() {
    return this.accent === "success";
  }
  get infoAccent() {
    return this.accent === "info";
  }
  get warningAccent() {
    return this.accent === "warning";
  }
  get dangerAccent() {
    return this.accent === "danger";
  }
  get basicAccent() {
    return this.accent === "basic";
  }
  get controlAccent() {
    return this.accent === "control";
  }
  get primaryOutline() {
    return this.outline === "primary";
  }
  get successOutline() {
    return this.outline === "success";
  }
  get infoOutline() {
    return this.outline === "info";
  }
  get warningOutline() {
    return this.outline === "warning";
  }
  get dangerOutline() {
    return this.outline === "danger";
  }
  get basicOutline() {
    return this.outline === "basic";
  }
  get controlOutline() {
    return this.outline === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
};
_NbAlertComponent.ɵfac = function NbAlertComponent_Factory(t) {
  return new (t || _NbAlertComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbAlertComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAlertComponent,
  selectors: [["nb-alert"]],
  hostVars: 56,
  hostBindings: function NbAlertComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("closable", ctx.closable)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent-primary", ctx.primaryAccent)("accent-success", ctx.successAccent)("accent-info", ctx.infoAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent)("outline-primary", ctx.primaryOutline)("outline-success", ctx.successOutline)("outline-info", ctx.infoOutline)("outline-warning", ctx.warningOutline)("outline-danger", ctx.dangerOutline)("outline-basic", ctx.basicOutline)("outline-control", ctx.controlOutline);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    accent: "accent",
    outline: "outline",
    closable: "closable"
  },
  outputs: {
    close: "close"
  },
  ngContentSelectors: _c03,
  decls: 2,
  vars: 1,
  consts: [["type", "button", "class", "close", "aria-label", "Close", 3, "click", 4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "close", 3, "click"], ["aria-hidden", "true"]],
  template: function NbAlertComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, NbAlertComponent_button_0_Template, 3, 0, "button", 0);
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.closable);
    }
  },
  dependencies: [NgIf],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative}[dir=ltr]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{right:0}[dir=rtl]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{left:0}.close[_ngcontent-%COMP%]{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}"]
});
var NbAlertComponent = _NbAlertComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAlertComponent, [{
    type: Component,
    args: [{
      selector: "nb-alert",
      template: `
    <button *ngIf="closable" type="button" class="close" aria-label="Close" (click)="onClose()">
      <span aria-hidden="true">&times;</span>
    </button>
    <ng-content></ng-content>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column;position:relative}[dir=ltr] :host .close{right:0}[dir=rtl] :host .close{left:0}.close{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    accent: [{
      type: Input
    }],
    outline: [{
      type: Input
    }],
    closable: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.closable"]
    }],
    close: [{
      type: Output
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    primaryAccent: [{
      type: HostBinding,
      args: ["class.accent-primary"]
    }],
    successAccent: [{
      type: HostBinding,
      args: ["class.accent-success"]
    }],
    infoAccent: [{
      type: HostBinding,
      args: ["class.accent-info"]
    }],
    warningAccent: [{
      type: HostBinding,
      args: ["class.accent-warning"]
    }],
    dangerAccent: [{
      type: HostBinding,
      args: ["class.accent-danger"]
    }],
    basicAccent: [{
      type: HostBinding,
      args: ["class.accent-basic"]
    }],
    controlAccent: [{
      type: HostBinding,
      args: ["class.accent-control"]
    }],
    primaryOutline: [{
      type: HostBinding,
      args: ["class.outline-primary"]
    }],
    successOutline: [{
      type: HostBinding,
      args: ["class.outline-success"]
    }],
    infoOutline: [{
      type: HostBinding,
      args: ["class.outline-info"]
    }],
    warningOutline: [{
      type: HostBinding,
      args: ["class.outline-warning"]
    }],
    dangerOutline: [{
      type: HostBinding,
      args: ["class.outline-danger"]
    }],
    basicOutline: [{
      type: HostBinding,
      args: ["class.outline-basic"]
    }],
    controlOutline: [{
      type: HostBinding,
      args: ["class.outline-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbAlertModule = class _NbAlertModule {
};
_NbAlertModule.ɵfac = function NbAlertModule_Factory(t) {
  return new (t || _NbAlertModule)();
};
_NbAlertModule.ɵmod = ɵɵdefineNgModule({
  type: _NbAlertModule,
  declarations: [NbAlertComponent],
  imports: [NbSharedModule],
  exports: [NbAlertComponent]
});
_NbAlertModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbAlertModule = _NbAlertModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAlertModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [NbAlertComponent],
      exports: [NbAlertComponent]
    }]
  }], null, null);
})();
var _NbFormFieldControl = class _NbFormFieldControl {
};
_NbFormFieldControl.ɵfac = function NbFormFieldControl_Factory(t) {
  return new (t || _NbFormFieldControl)();
};
_NbFormFieldControl.ɵprov = ɵɵdefineInjectable({
  token: _NbFormFieldControl,
  factory: _NbFormFieldControl.ɵfac
});
var NbFormFieldControl = _NbFormFieldControl;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldControl, [{
    type: Injectable
  }], null, null);
})();
var _NbFormFieldControlConfig = class _NbFormFieldControlConfig {
  constructor() {
    this.supportsPrefix = true;
    this.supportsSuffix = true;
  }
};
_NbFormFieldControlConfig.ɵfac = function NbFormFieldControlConfig_Factory(t) {
  return new (t || _NbFormFieldControlConfig)();
};
_NbFormFieldControlConfig.ɵprov = ɵɵdefineInjectable({
  token: _NbFormFieldControlConfig,
  factory: _NbFormFieldControlConfig.ɵfac
});
var NbFormFieldControlConfig = _NbFormFieldControlConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldControlConfig, [{
    type: Injectable
  }], null, null);
})();
var _NbInputDirective = class _NbInputDirective {
  /**
   * If set element will fill container. `false` by default.
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(elementRef, focusMonitor, renderer, zone, statusService) {
    this.elementRef = elementRef;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.destroy$ = new Subject();
    this.fieldSize = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this._fullWidth = false;
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.fieldSize);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(false);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
  }
  ngDoCheck() {
    const isDisabled = this.elementRef.nativeElement.disabled;
    if (isDisabled !== this.disabled$.value) {
      this.disabled$.next(isDisabled);
    }
  }
  ngOnChanges({
    status,
    fieldSize,
    fullWidth
  }) {
    if (status) {
      this.status$.next(this.status);
    }
    if (fieldSize) {
      this.size$.next(this.fieldSize);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngOnInit() {
    this.focusMonitor.monitor(this.elementRef).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.elementRef)), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  get tiny() {
    return this.fieldSize === "tiny";
  }
  get small() {
    return this.fieldSize === "small";
  }
  get medium() {
    return this.fieldSize === "medium";
  }
  get large() {
    return this.fieldSize === "large";
  }
  get giant() {
    return this.fieldSize === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get round() {
    return this.shape === "round";
  }
};
_NbInputDirective.ɵfac = function NbInputDirective_Factory(t) {
  return new (t || _NbInputDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbInputDirective.ɵdir = ɵɵdefineDirective({
  type: _NbInputDirective,
  selectors: [["input", "nbInput", ""], ["textarea", "nbInput", ""]],
  hostVars: 34,
  hostBindings: function NbInputDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("input-full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
    }
  },
  inputs: {
    fieldSize: "fieldSize",
    status: "status",
    shape: "shape",
    fullWidth: "fullWidth"
  },
  features: [ɵɵProvidersFeature([{
    provide: NbFormFieldControl,
    useExisting: _NbInputDirective
  }]), ɵɵNgOnChangesFeature]
});
var NbInputDirective = _NbInputDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInputDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbInput],textarea[nbInput]",
      providers: [{
        provide: NbFormFieldControl,
        useExisting: NbInputDirective
      }]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    fieldSize: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.input-full-width"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }]
  });
})();
var _NbChatFormComponent = class _NbChatFormComponent {
  constructor(cd, domSanitizer) {
    this.cd = cd;
    this.domSanitizer = domSanitizer;
    this.status = "basic";
    this.inputFocus = false;
    this.inputHover = false;
    this.droppedFiles = [];
    this.imgDropTypes = ["image/png", "image/jpeg", "image/gif"];
    this.message = "";
    this.messagePlaceholder = "Type a message";
    this.buttonTitle = "";
    this.buttonIcon = "paper-plane-outline";
    this.showButton = true;
    this.dropFiles = false;
    this.dropFilePlaceholder = "Drop file to send";
    this.send = new EventEmitter();
    this.onInputChange = new EventEmitter();
    this.fileOver = false;
  }
  onDrop(event) {
    if (this.dropFiles) {
      event.preventDefault();
      event.stopPropagation();
      this.fileOver = false;
      if (event.dataTransfer && event.dataTransfer.files) {
        for (const file of event.dataTransfer.files) {
          const res = file;
          if (this.imgDropTypes.includes(file.type)) {
            const fr = new FileReader();
            fr.onload = (e) => {
              res.src = e.target.result;
              res.urlStyle = this.domSanitizer.bypassSecurityTrustStyle(`url(${res.src})`);
              this.cd.detectChanges();
            };
            fr.readAsDataURL(file);
          }
          this.droppedFiles.push(res);
        }
      }
    }
  }
  removeFile(file) {
    const index = this.droppedFiles.indexOf(file);
    if (index >= 0) {
      this.droppedFiles.splice(index, 1);
    }
  }
  onDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.dropFiles) {
      this.fileOver = true;
    }
  }
  onDragLeave(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.dropFiles) {
      this.fileOver = false;
    }
  }
  sendMessage() {
    if (this.droppedFiles.length || String(this.message).trim().length) {
      this.send.emit({
        message: this.message,
        files: this.droppedFiles
      });
      this.message = "";
      this.droppedFiles = [];
    }
  }
  setStatus(status) {
    if (this.status !== status) {
      this.status = status;
      this.cd.detectChanges();
    }
  }
  getInputStatus() {
    if (this.fileOver) {
      return this.getHighlightStatus();
    }
    if (this.inputFocus || this.inputHover) {
      return this.status;
    }
    return "basic";
  }
  getButtonStatus() {
    return this.getHighlightStatus();
  }
  getHighlightStatus() {
    if (this.status === "basic" || this.status === "control") {
      return "primary";
    }
    return this.status;
  }
  onModelChange(value) {
    this.onInputChange.emit(value);
  }
};
_NbChatFormComponent.ɵfac = function NbChatFormComponent_Factory(t) {
  return new (t || _NbChatFormComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DomSanitizer));
};
_NbChatFormComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatFormComponent,
  selectors: [["nb-chat-form"]],
  hostVars: 2,
  hostBindings: function NbChatFormComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("drop", function NbChatFormComponent_drop_HostBindingHandler($event) {
        return ctx.onDrop($event);
      })("dragover", function NbChatFormComponent_dragover_HostBindingHandler($event) {
        return ctx.onDragOver($event);
      })("dragleave", function NbChatFormComponent_dragleave_HostBindingHandler($event) {
        return ctx.onDragLeave($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("file-over", ctx.fileOver);
    }
  },
  inputs: {
    message: "message",
    messagePlaceholder: "messagePlaceholder",
    buttonTitle: "buttonTitle",
    buttonIcon: "buttonIcon",
    showButton: "showButton",
    dropFiles: "dropFiles",
    dropFilePlaceholder: "dropFilePlaceholder"
  },
  outputs: {
    send: "send",
    onInputChange: "onInputChange"
  },
  decls: 4,
  vars: 7,
  consts: [["title", ""], ["class", "dropped-files", 4, "ngIf"], [1, "message-row"], ["nbInput", "", "fullWidth", "", "type", "text", 3, "focus", "blur", "mouseenter", "mouseleave", "ngModelChange", "keyup.enter", "status", "ngModel", "placeholder"], ["nbButton", "", "class", "send-button", 3, "status", "with-icon", "click", 4, "ngIf"], [1, "dropped-files"], [4, "ngFor", "ngForOf"], [3, "background-image", 4, "ngIf"], [4, "ngIf"], [1, "remove", 3, "click"], ["icon", "file-text-outline", "pack", "nebular-essentials"], ["nbButton", "", 1, "send-button", 3, "click", "status"], ["pack", "nebular-essentials", 3, "icon", 4, "ngIf", "ngIfElse"], ["pack", "nebular-essentials", 3, "icon"]],
  template: function NbChatFormComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbChatFormComponent_div_0_Template, 2, 1, "div", 1);
      ɵɵelementStart(1, "div", 2)(2, "input", 3);
      ɵɵlistener("focus", function NbChatFormComponent_Template_input_focus_2_listener() {
        return ctx.inputFocus = true;
      })("blur", function NbChatFormComponent_Template_input_blur_2_listener() {
        return ctx.inputFocus = false;
      })("mouseenter", function NbChatFormComponent_Template_input_mouseenter_2_listener() {
        return ctx.inputHover = true;
      })("mouseleave", function NbChatFormComponent_Template_input_mouseleave_2_listener() {
        return ctx.inputHover = false;
      });
      ɵɵtwoWayListener("ngModelChange", function NbChatFormComponent_Template_input_ngModelChange_2_listener($event) {
        ɵɵtwoWayBindingSet(ctx.message, $event) || (ctx.message = $event);
        return $event;
      });
      ɵɵlistener("ngModelChange", function NbChatFormComponent_Template_input_ngModelChange_2_listener($event) {
        return ctx.onModelChange($event);
      })("keyup.enter", function NbChatFormComponent_Template_input_keyup_enter_2_listener() {
        return ctx.sendMessage();
      });
      ɵɵelementEnd();
      ɵɵtemplate(3, NbChatFormComponent_button_3_Template, 4, 5, "button", 4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.droppedFiles == null ? null : ctx.droppedFiles.length);
      ɵɵadvance(2);
      ɵɵclassProp("with-button", ctx.showButton);
      ɵɵpropertyInterpolate("placeholder", ctx.fileOver ? ctx.dropFilePlaceholder : ctx.messagePlaceholder);
      ɵɵproperty("status", ctx.getInputStatus());
      ɵɵtwoWayProperty("ngModel", ctx.message);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showButton);
    }
  },
  dependencies: [NgForOf, NgIf, DefaultValueAccessor, NgControlStatus, NgModel, NbIconComponent, NbInputDirective, NbButtonComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatFormComponent = _NbChatFormComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatFormComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-form",
      template: `
    <div class="dropped-files" *ngIf="droppedFiles?.length">
      <ng-container *ngFor="let file of droppedFiles">
        <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle">
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>

        <div *ngIf="!file.urlStyle">
          <nb-icon icon="file-text-outline" pack="nebular-essentials"></nb-icon>
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>
      </ng-container>
    </div>
    <div class="message-row">
      <input
        nbInput
        fullWidth
        [status]="getInputStatus()"
        (focus)="inputFocus = true"
        (blur)="inputFocus = false"
        (mouseenter)="inputHover = true"
        (mouseleave)="inputHover = false"
        [(ngModel)]="message"
        (ngModelChange)="onModelChange($event)"
        [class.with-button]="showButton"
        type="text"
        placeholder="{{ fileOver ? dropFilePlaceholder : messagePlaceholder }}"
        (keyup.enter)="sendMessage()"
      />
      <button
        nbButton
        [status]="getButtonStatus()"
        *ngIf="showButton"
        [class.with-icon]="!buttonTitle"
        (click)="sendMessage()"
        class="send-button"
      >
        <nb-icon *ngIf="!buttonTitle; else title" [icon]="buttonIcon" pack="nebular-essentials"></nb-icon>
        <ng-template #title>{{ buttonTitle }}</ng-template>
      </button>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: DomSanitizer
  }], {
    message: [{
      type: Input
    }],
    messagePlaceholder: [{
      type: Input
    }],
    buttonTitle: [{
      type: Input
    }],
    buttonIcon: [{
      type: Input
    }],
    showButton: [{
      type: Input
    }],
    dropFiles: [{
      type: Input
    }],
    dropFilePlaceholder: [{
      type: Input
    }],
    send: [{
      type: Output
    }],
    onInputChange: [{
      type: Output
    }],
    fileOver: [{
      type: HostBinding,
      args: ["class.file-over"]
    }],
    onDrop: [{
      type: HostListener,
      args: ["drop", ["$event"]]
    }],
    onDragOver: [{
      type: HostListener,
      args: ["dragover", ["$event"]]
    }],
    onDragLeave: [{
      type: HostListener,
      args: ["dragleave", ["$event"]]
    }]
  });
})();
var _NbChatCustomMessageService = class _NbChatCustomMessageService {
  constructor() {
    this.customMessages = /* @__PURE__ */ new Map();
  }
  register(type, instance) {
    this.customMessages.set(type, instance);
  }
  unregister(type) {
    return this.customMessages.delete(type);
  }
  getInstance(type) {
    return this.customMessages.get(type);
  }
};
_NbChatCustomMessageService.ɵfac = function NbChatCustomMessageService_Factory(t) {
  return new (t || _NbChatCustomMessageService)();
};
_NbChatCustomMessageService.ɵprov = ɵɵdefineInjectable({
  token: _NbChatCustomMessageService,
  factory: _NbChatCustomMessageService.ɵfac
});
var NbChatCustomMessageService = _NbChatCustomMessageService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatCustomMessageService, [{
    type: Injectable
  }], null, null);
})();
var _NbChatMessageTextComponent = class _NbChatMessageTextComponent {
  constructor() {
    this.dateFormat = "shortTime";
  }
};
_NbChatMessageTextComponent.ɵfac = function NbChatMessageTextComponent_Factory(t) {
  return new (t || _NbChatMessageTextComponent)();
};
_NbChatMessageTextComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatMessageTextComponent,
  selectors: [["nb-chat-message-text"]],
  inputs: {
    sender: "sender",
    message: "message",
    date: "date",
    dateFormat: "dateFormat"
  },
  decls: 2,
  vars: 2,
  consts: [["class", "sender", 4, "ngIf"], ["class", "text", 4, "ngIf"], [1, "sender"], [1, "text"]],
  template: function NbChatMessageTextComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbChatMessageTextComponent_p_0_Template, 5, 5, "p", 0)(1, NbChatMessageTextComponent_p_1_Template, 2, 1, "p", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.sender || ctx.date);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.message);
    }
  },
  dependencies: [NgIf, DatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageTextComponent = _NbChatMessageTextComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageTextComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-text",
      template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date  | date: dateFormat }}</time></p>
    <p class="text" *ngIf="message">{{ message }}</p>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    sender: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }]
  });
})();
var _NbChatMessageFileComponent = class _NbChatMessageFileComponent {
  /**
   * Message file path
   * @type {Date}
   */
  set files(files) {
    this.readyFiles = (files || []).map((file) => {
      const isImage = this.isImage(file);
      return __spreadProps(__spreadValues({}, file), {
        urlStyle: isImage && this.domSanitizer.bypassSecurityTrustStyle(`url(${file.url})`),
        isImage
      });
    });
    this.cd.detectChanges();
  }
  constructor(cd, domSanitizer) {
    this.cd = cd;
    this.domSanitizer = domSanitizer;
    this.dateFormat = "shortTime";
  }
  isImage(file) {
    const type = file.type;
    if (type) {
      return ["image/png", "image/jpeg", "image/gif"].includes(type);
    }
    return false;
  }
};
_NbChatMessageFileComponent.ɵfac = function NbChatMessageFileComponent_Factory(t) {
  return new (t || _NbChatMessageFileComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DomSanitizer));
};
_NbChatMessageFileComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatMessageFileComponent,
  selectors: [["nb-chat-message-file"]],
  inputs: {
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    files: "files"
  },
  decls: 4,
  vars: 7,
  consts: [[3, "sender", "date", "dateFormat", "message"], [4, "ngIf"], [1, "message-content-group"], ["target", "_blank", 3, "href", 4, "ngFor", "ngForOf"], ["target", "_blank", 3, "href"], [3, "icon", 4, "ngIf"], [3, "background-image", 4, "ngIf"], [3, "icon"]],
  template: function NbChatMessageFileComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-chat-message-text", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_Template, 3, 1, "ng-container", 1)(3, NbChatMessageFileComponent_ng_container_3_Template, 4, 3, "ng-container", 1);
    }
    if (rf & 2) {
      ɵɵproperty("sender", ctx.sender)("date", ctx.date)("dateFormat", ctx.dateFormat)("message", ctx.message);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.message, " ");
      ɵɵadvance();
      ɵɵproperty("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) > 1);
      ɵɵadvance();
      ɵɵproperty("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) === 1);
    }
  },
  dependencies: [NgForOf, NgIf, NbIconComponent, NbChatMessageTextComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageFileComponent = _NbChatMessageFileComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageFileComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-file",
      template: `
    <nb-chat-message-text [sender]="sender" [date]="date" [dateFormat]="dateFormat" [message]="message">
      {{ message }}
    </nb-chat-message-text>

    <ng-container *ngIf="readyFiles?.length > 1">
      <div class="message-content-group">
        <a *ngFor="let file of readyFiles" [href]="file.url" target="_blank">
          <nb-icon [icon]="file.icon" *ngIf="!file.urlStyle && file.icon"></nb-icon>
          <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle"></div>
        </a>
      </div>
    </ng-container>

    <ng-container *ngIf="readyFiles?.length === 1">
      <a [href]="readyFiles[0].url" target="_blank">
        <nb-icon [icon]="readyFiles[0].icon" *ngIf="!readyFiles[0].urlStyle && readyFiles[0].icon"></nb-icon>
        <div *ngIf="readyFiles[0].urlStyle" [style.background-image]="readyFiles[0].urlStyle"></div>
      </a>
    </ng-container>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: DomSanitizer
  }], {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    files: [{
      type: Input
    }]
  });
})();
var _NbChatMessageQuoteComponent = class _NbChatMessageQuoteComponent {
  constructor() {
    this.dateFormat = "shortTime";
  }
};
_NbChatMessageQuoteComponent.ɵfac = function NbChatMessageQuoteComponent_Factory(t) {
  return new (t || _NbChatMessageQuoteComponent)();
};
_NbChatMessageQuoteComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatMessageQuoteComponent,
  selectors: [["nb-chat-message-quote"]],
  inputs: {
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    quote: "quote"
  },
  decls: 5,
  vars: 4,
  consts: [["class", "sender", 4, "ngIf"], [1, "quote"], [3, "message"], [1, "sender"]],
  template: function NbChatMessageQuoteComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbChatMessageQuoteComponent_p_0_Template, 5, 5, "p", 0);
      ɵɵelementStart(1, "p", 1);
      ɵɵtext(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "nb-chat-message-text", 2);
      ɵɵtext(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.sender || ctx.date);
      ɵɵadvance(2);
      ɵɵtextInterpolate1(" ", ctx.quote, " ");
      ɵɵadvance();
      ɵɵproperty("message", ctx.message);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.message, " ");
    }
  },
  dependencies: [NgIf, NbChatMessageTextComponent, DatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageQuoteComponent = _NbChatMessageQuoteComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageQuoteComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-quote",
      template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date | date: dateFormat }}</time></p>
    <p class="quote">
      {{ quote }}
    </p>
    <nb-chat-message-text [message]="message">
      {{ message }}
    </nb-chat-message-text>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    quote: [{
      type: Input
    }]
  });
})();
var NbChatOptions = class {
};
var _NbChatMessageMapComponent = class _NbChatMessageMapComponent {
  get file() {
    return {
      // eslint-disable-next-line max-len
      url: `https://maps.googleapis.com/maps/api/staticmap?center=${this.latitude},${this.longitude}&zoom=12&size=400x400&key=${this.mapKey}`,
      type: "image/png",
      icon: "location"
    };
  }
  constructor(options) {
    this.dateFormat = "shortTime";
    this.mapKey = options.messageGoogleMapKey;
  }
};
_NbChatMessageMapComponent.ɵfac = function NbChatMessageMapComponent_Factory(t) {
  return new (t || _NbChatMessageMapComponent)(ɵɵdirectiveInject(NbChatOptions));
};
_NbChatMessageMapComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatMessageMapComponent,
  selectors: [["nb-chat-message-map"]],
  inputs: {
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    latitude: "latitude",
    longitude: "longitude"
  },
  decls: 1,
  vars: 7,
  consts: [[3, "files", "message", "sender", "date", "dateFormat"]],
  template: function NbChatMessageMapComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "nb-chat-message-file", 0);
    }
    if (rf & 2) {
      ɵɵproperty("files", ɵɵpureFunction1(5, _c26, ctx.file))("message", ctx.message)("sender", ctx.sender)("date", ctx.date)("dateFormat", ctx.dateFormat);
    }
  },
  dependencies: [NbChatMessageFileComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageMapComponent = _NbChatMessageMapComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageMapComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-map",
      template: `
    <nb-chat-message-file [files]="[file]" [message]="message" [sender]="sender" [date]="date"
     [dateFormat]="dateFormat"></nb-chat-message-file>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbChatOptions
  }], {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    latitude: [{
      type: Input
    }],
    longitude: [{
      type: Input
    }]
  });
})();
var _NbChatAvatarComponent = class _NbChatAvatarComponent {
  constructor() {
    this.avatarClass = true;
  }
};
_NbChatAvatarComponent.ɵfac = function NbChatAvatarComponent_Factory(t) {
  return new (t || _NbChatAvatarComponent)();
};
_NbChatAvatarComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatAvatarComponent,
  selectors: [["nb-chat-avatar"]],
  hostVars: 4,
  hostBindings: function NbChatAvatarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("background-image", ctx.avatarStyle);
      ɵɵclassProp("avatar", ctx.avatarClass);
    }
  },
  inputs: {
    initials: "initials",
    avatarStyle: "avatarStyle"
  },
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"]],
  template: function NbChatAvatarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbChatAvatarComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.avatarStyle);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatAvatarComponent = _NbChatAvatarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatAvatarComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-avatar",
      template: `
    <ng-container *ngIf="!avatarStyle">
      {{ initials }}
    </ng-container>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    initials: [{
      type: Input
    }],
    avatarStyle: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.background-image"]
    }],
    avatarClass: [{
      type: HostBinding,
      args: ["class.avatar"]
    }]
  });
})();
var _NbChatMessageComponent = class _NbChatMessageComponent {
  get _addReplyClass() {
    return this._areDefaultStylesEnabled() && this.reply;
  }
  get _addNotReplyClass() {
    return this._areDefaultStylesEnabled() && this.notReply;
  }
  get _addNoSpaceClass() {
    return this._areDefaultStylesEnabled() && !this.message;
  }
  get flyInOut() {
    return true;
  }
  get notReply() {
    return !this.reply;
  }
  /**
   * Determines if a message is a reply
   */
  get reply() {
    return this._reply;
  }
  set reply(value) {
    this._reply = convertToBoolProperty(value);
  }
  /**
   * Message send avatar
   * @type {string}
   */
  set avatar(value) {
    this.avatarStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
  }
  constructor(domSanitizer, customMessageService) {
    this.domSanitizer = domSanitizer;
    this.customMessageService = customMessageService;
    this.builtInMessageTypes = ["text", "file", "map", "quote"];
    this._reply = false;
  }
  getInitials() {
    if (this.sender) {
      const names = this.sender.split(" ");
      return names.map((n) => n.charAt(0)).splice(0, 2).join("").toUpperCase();
    }
    return "";
  }
  _isBuiltInMessageType() {
    return this.type == null || this.builtInMessageTypes.includes(this.type);
  }
  _getTemplate() {
    const customMessage = this.getCustomMessage(this.type);
    return customMessage.templateRef;
  }
  _getTemplateContext() {
    return {
      $implicit: this.customMessageData,
      isReply: this.reply
    };
  }
  _areDefaultStylesEnabled() {
    const customMessageDirective = this.getCustomMessage(this.type);
    return !customMessageDirective.noStyles;
  }
  getCustomMessage(type) {
    const customMessageDirective = this.customMessageService.getInstance(type);
    if (!customMessageDirective) {
      throw new Error(`nb-chat: Can't find template for custom type '${type}'. Make sure you provide it in the chat component with *nbCustomMessage='${type}'.`);
    }
    return customMessageDirective;
  }
};
_NbChatMessageComponent.ɵfac = function NbChatMessageComponent_Factory(t) {
  return new (t || _NbChatMessageComponent)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(NbChatCustomMessageService));
};
_NbChatMessageComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatMessageComponent,
  selectors: [["nb-chat-message"]],
  hostVars: 5,
  hostBindings: function NbChatMessageComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵsyntheticHostProperty("@flyInOut", ctx.flyInOut);
      ɵɵclassProp("not-reply", ctx.notReply)("reply", ctx.reply);
    }
  },
  inputs: {
    reply: "reply",
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    files: "files",
    quote: "quote",
    latitude: "latitude",
    longitude: "longitude",
    avatar: "avatar",
    type: "type",
    customMessageData: "customMessageData"
  },
  decls: 5,
  vars: 3,
  consts: [["customTemplate", ""], [3, "initials", "avatarStyle", 4, "ngIf"], [1, "message"], [3, "ngSwitch", 4, "ngIf", "ngIfElse"], [3, "initials", "avatarStyle"], [3, "ngSwitch"], [3, "sender", "date", "dateFormat", "message", "files", 4, "ngSwitchCase"], [3, "sender", "date", "dateFormat", "message", "quote", 4, "ngSwitchCase"], [3, "sender", "date", "message", "latitude", "longitude", 4, "ngSwitchCase"], [3, "sender", "date", "dateFormat", "message", 4, "ngSwitchDefault"], [3, "sender", "date", "dateFormat", "message", "files"], [3, "sender", "date", "dateFormat", "message", "quote"], [3, "sender", "date", "message", "latitude", "longitude"], [3, "sender", "date", "dateFormat", "message"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function NbChatMessageComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbChatMessageComponent_nb_chat_avatar_0_Template, 1, 2, "nb-chat-avatar", 1);
      ɵɵelementStart(1, "div", 2);
      ɵɵtemplate(2, NbChatMessageComponent_ng_container_2_Template, 5, 4, "ng-container", 3);
      ɵɵelementEnd();
      ɵɵtemplate(3, NbChatMessageComponent_ng_template_3_Template, 3, 16, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const customTemplate_r2 = ɵɵreference(4);
      ɵɵproperty("ngIf", ctx.notReply);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx._isBuiltInMessageType())("ngIfElse", customTemplate_r2);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgSwitchDefault, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("flyInOut", [state("in", style({
      transform: "translateX(0)"
    })), transition("void => *", [style({
      transform: "translateX(-100%)"
    }), animate(80)]), transition("* => void", [animate(80, style({
      transform: "translateX(100%)"
    }))])])]
  },
  changeDetection: 0
});
var NbChatMessageComponent = _NbChatMessageComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message",
      template: `
    <nb-chat-avatar *ngIf="notReply" [initials]="getInitials()" [avatarStyle]="avatarStyle"> </nb-chat-avatar>

    <div class="message">
      <ng-container [ngSwitch]="type" *ngIf="_isBuiltInMessageType(); else customTemplate">
        <nb-chat-message-file
          *ngSwitchCase="'file'"
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
          [files]="files"
        >
        </nb-chat-message-file>

        <nb-chat-message-quote
          *ngSwitchCase="'quote'"
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
          [quote]="quote"
        >
        </nb-chat-message-quote>

        <nb-chat-message-map
          *ngSwitchCase="'map'"
          [sender]="sender"
          [date]="date"
          [message]="message"
          [latitude]="latitude"
          [longitude]="longitude"
        >
        </nb-chat-message-map>

        <nb-chat-message-text
          *ngSwitchDefault
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
        >
        </nb-chat-message-text>
      </ng-container>
    </div>

    <ng-template #customTemplate>
      <nb-chat-message-text [sender]="sender" [date]="date" [dateFormat]="dateFormat" [message]="message">
      </nb-chat-message-text>
      <div
        [class.nb-custom-message]="_areDefaultStylesEnabled()"
        [class.nb-custom-message-no-space]="_addNoSpaceClass"
        [class.nb-custom-message-reply]="_addReplyClass"
        [class.nb-custom-message-not-reply]="_addNotReplyClass"
        [class.nb-custom-message-full-width]="!_areDefaultStylesEnabled()"
      >
        <ng-container [ngTemplateOutlet]="_getTemplate()" [ngTemplateOutletContext]="_getTemplateContext()">
        </ng-container>
      </div>
    </ng-template>
  `,
      animations: [trigger("flyInOut", [state("in", style({
        transform: "translateX(0)"
      })), transition("void => *", [style({
        transform: "translateX(-100%)"
      }), animate(80)]), transition("* => void", [animate(80, style({
        transform: "translateX(100%)"
      }))])])],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: DomSanitizer
  }, {
    type: NbChatCustomMessageService
  }], {
    flyInOut: [{
      type: HostBinding,
      args: ["@flyInOut"]
    }],
    notReply: [{
      type: HostBinding,
      args: ["class.not-reply"]
    }],
    reply: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.reply"]
    }],
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    files: [{
      type: Input
    }],
    quote: [{
      type: Input
    }],
    latitude: [{
      type: Input
    }],
    longitude: [{
      type: Input
    }],
    avatar: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    customMessageData: [{
      type: Input
    }]
  });
})();
var _NbChatTitleDirective = class _NbChatTitleDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this.context = {};
  }
};
_NbChatTitleDirective.ɵfac = function NbChatTitleDirective_Factory(t) {
  return new (t || _NbChatTitleDirective)(ɵɵdirectiveInject(TemplateRef));
};
_NbChatTitleDirective.ɵdir = ɵɵdefineDirective({
  type: _NbChatTitleDirective,
  selectors: [["", "nbChatTitle", ""]],
  inputs: {
    context: "context"
  }
});
var NbChatTitleDirective = _NbChatTitleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatTitleDirective, [{
    type: Directive,
    args: [{
      selector: `[nbChatTitle]`
    }]
  }], () => [{
    type: TemplateRef
  }], {
    context: [{
      type: Input
    }]
  });
})();
var _NbChatComponent = class _NbChatComponent {
  /**
   * Scroll chat to the bottom of the list when a new message arrives
   */
  get scrollBottom() {
    return this._scrollBottom;
  }
  set scrollBottom(value) {
    this._scrollBottom = convertToBoolProperty(value);
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.status = "basic";
    this.noMessagesPlaceholder = "No messages yet.";
    this._scrollBottom = true;
  }
  ngOnChanges(changes) {
    if ("status" in changes) {
      this.updateFormStatus();
    }
  }
  ngAfterContentInit() {
    this.updateFormStatus();
  }
  ngAfterViewInit() {
    this.messages.changes.subscribe((messages) => {
      this.messages = messages;
      this.updateView();
    });
    this.updateView();
  }
  updateView() {
    if (this.scrollBottom) {
      this.scrollListBottom();
    }
  }
  scrollListBottom() {
    this.scrollable.nativeElement.scrollTop = this.scrollable.nativeElement.scrollHeight;
  }
  updateFormStatus() {
    if (this.chatForm) {
      this.chatForm.setStatus(this.status);
    }
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
};
_NbChatComponent.ɵfac = function NbChatComponent_Factory(t) {
  return new (t || _NbChatComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbChatComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatComponent,
  selectors: [["nb-chat"]],
  contentQueries: function NbChatComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbChatFormComponent, 5);
      ɵɵcontentQuery(dirIndex, NbChatTitleDirective, 5);
      ɵɵcontentQuery(dirIndex, NbChatMessageComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chatForm = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.messages = _t);
    }
  },
  viewQuery: function NbChatComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c27, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scrollable = _t.first);
    }
  },
  hostVars: 26,
  hostBindings: function NbChatComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    title: "title",
    size: "size",
    status: "status",
    noMessagesPlaceholder: "noMessagesPlaceholder",
    scrollBottom: "scrollBottom"
  },
  features: [ɵɵProvidersFeature([NbChatCustomMessageService]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c29,
  decls: 11,
  vars: 3,
  consts: [["textTitleTemplate", ""], ["scrollable", ""], [1, "header"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf", "ngIfElse"], [1, "scrollable"], [1, "messages"], ["class", "no-messages", 4, "ngIf"], [1, "form"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "no-messages"]],
  template: function NbChatComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c28);
      ɵɵelementStart(0, "div", 2);
      ɵɵtemplate(1, NbChatComponent_ng_container_1_Template, 1, 4, "ng-container", 3)(2, NbChatComponent_ng_template_2_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
      ɵɵelementStart(4, "div", 4, 1)(6, "div", 5);
      ɵɵprojection(7);
      ɵɵtemplate(8, NbChatComponent_p_8_Template, 2, 1, "p", 6);
      ɵɵelementEnd()();
      ɵɵelementStart(9, "div", 7);
      ɵɵprojection(10, 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const textTitleTemplate_r2 = ɵɵreference(3);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.titleTemplate)("ngIfElse", textTitleTemplate_r2);
      ɵɵadvance(7);
      ɵɵproperty("ngIf", !(ctx.messages == null ? null : ctx.messages.length));
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative;height:100%}"]
});
var NbChatComponent = _NbChatComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat",
      template: `
    <div class="header">
      <ng-container
        *ngIf="titleTemplate; else textTitleTemplate"
        [ngTemplateOutlet]="titleTemplate.templateRef"
        [ngTemplateOutletContext]="{ $implicit: titleTemplate.context }"
      >
      </ng-container>
      <ng-template #textTitleTemplate>
        {{ title }}
      </ng-template>
    </div>

    <div class="scrollable" #scrollable>
      <div class="messages">
        <ng-content select="nb-chat-message"></ng-content>
        <p class="no-messages" *ngIf="!messages?.length">{{ noMessagesPlaceholder }}</p>
      </div>
    </div>
    <div class="form">
      <ng-content select="nb-chat-form"></ng-content>
    </div>
  `,
      providers: [NbChatCustomMessageService],
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column;position:relative;height:100%}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    title: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    noMessagesPlaceholder: [{
      type: Input
    }],
    scrollBottom: [{
      type: Input
    }],
    scrollable: [{
      type: ViewChild,
      args: ["scrollable"]
    }],
    messages: [{
      type: ContentChildren,
      args: [NbChatMessageComponent]
    }],
    chatForm: [{
      type: ContentChild,
      args: [NbChatFormComponent]
    }],
    titleTemplate: [{
      type: ContentChild,
      args: [NbChatTitleDirective]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NB_INPUT_COMPONENTS = [NbInputDirective];
var _NbInputModule = class _NbInputModule {
};
_NbInputModule.ɵfac = function NbInputModule_Factory(t) {
  return new (t || _NbInputModule)();
};
_NbInputModule.ɵmod = ɵɵdefineNgModule({
  type: _NbInputModule,
  declarations: [NbInputDirective],
  imports: [NbSharedModule],
  exports: [NbInputDirective]
});
_NbInputModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbInputModule = _NbInputModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInputModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: NB_INPUT_COMPONENTS,
      exports: NB_INPUT_COMPONENTS
    }]
  }], null, null);
})();
function throwCustomMessageTypeIsRequired() {
  throw new Error("[nbCustomMessage]: custom message type is required.");
}
var _NbChatCustomMessageDirective = class _NbChatCustomMessageDirective {
  /**
   * Defines a message type which should rendered with the custom message template.
   * @type {string}
   */
  get nbCustomMessage() {
    return this._type;
  }
  set nbCustomMessage(value) {
    this._type = value;
  }
  get type() {
    return this._type;
  }
  /**
   * Disables generic message styles, such as round corners, text color, background, etc.,
   * so a custom message could be styled from the ground up.
   *
   * @type {boolean}
   */
  set nbCustomMessageNoStyles(value) {
    this._noStyles = convertToBoolProperty(value);
  }
  get nbCustomMessageNoStyles() {
    return this._noStyles;
  }
  get noStyles() {
    return this.nbCustomMessageNoStyles;
  }
  constructor(templateRef, customMessageService) {
    this.templateRef = templateRef;
    this.customMessageService = customMessageService;
    this._noStyles = false;
  }
  ngOnInit() {
    if (!this._type) {
      throwCustomMessageTypeIsRequired();
    }
    this.customMessageService.register(this.type, this);
  }
  ngOnDestroy() {
    this.customMessageService.unregister(this.type);
  }
};
_NbChatCustomMessageDirective.ɵfac = function NbChatCustomMessageDirective_Factory(t) {
  return new (t || _NbChatCustomMessageDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(NbChatCustomMessageService));
};
_NbChatCustomMessageDirective.ɵdir = ɵɵdefineDirective({
  type: _NbChatCustomMessageDirective,
  selectors: [["", "nbCustomMessage", ""]],
  inputs: {
    nbCustomMessage: "nbCustomMessage",
    nbCustomMessageNoStyles: "nbCustomMessageNoStyles"
  }
});
var NbChatCustomMessageDirective = _NbChatCustomMessageDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatCustomMessageDirective, [{
    type: Directive,
    args: [{
      selector: `[nbCustomMessage]`
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: NbChatCustomMessageService
  }], {
    nbCustomMessage: [{
      type: Input
    }],
    nbCustomMessageNoStyles: [{
      type: Input
    }]
  });
})();
var NB_CHAT_COMPONENTS = [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent];
var NB_CHAT_DIRECTIVES = [NbChatCustomMessageDirective, NbChatTitleDirective];
var _NbChatModule = class _NbChatModule {
  static forRoot(options) {
    return {
      ngModule: _NbChatModule,
      providers: [{
        provide: NbChatOptions,
        useValue: options || {}
      }]
    };
  }
  static forChild(options) {
    return {
      ngModule: _NbChatModule,
      providers: [{
        provide: NbChatOptions,
        useValue: options || {}
      }]
    };
  }
};
_NbChatModule.ɵfac = function NbChatModule_Factory(t) {
  return new (t || _NbChatModule)();
};
_NbChatModule.ɵmod = ɵɵdefineNgModule({
  type: _NbChatModule,
  declarations: [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent, NbChatCustomMessageDirective, NbChatTitleDirective],
  imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule],
  exports: [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent, NbChatCustomMessageDirective, NbChatTitleDirective]
});
_NbChatModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule]
});
var NbChatModule = _NbChatModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule],
      declarations: [...NB_CHAT_COMPONENTS, ...NB_CHAT_DIRECTIVES],
      exports: [...NB_CHAT_COMPONENTS, ...NB_CHAT_DIRECTIVES]
    }]
  }], null, null);
})();
var _NbSpinnerComponent = class _NbSpinnerComponent {
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.message = "Loading...";
    this.size = "medium";
    this.status = "basic";
  }
};
_NbSpinnerComponent.ɵfac = function NbSpinnerComponent_Factory(t) {
  return new (t || _NbSpinnerComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbSpinnerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSpinnerComponent,
  selectors: [["nb-spinner"]],
  hostVars: 26,
  hostBindings: function NbSpinnerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    message: "message",
    size: "size",
    status: "status"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "spin-circle"], ["class", "message", 4, "ngIf"], [1, "message"]],
  template: function NbSpinnerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "span", 0);
      ɵɵtemplate(1, NbSpinnerComponent_span_1_Template, 2, 1, "span", 1);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.message);
    }
  },
  dependencies: [NgIf],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{opacity:1;position:absolute;border-radius:inherit;inset:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}[_nghost-%COMP%]   .spin-circle[_ngcontent-%COMP%]{animation:spin .8s infinite linear;border-radius:50%;border-style:solid;border-width:.125em;width:1em;height:1em}[_nghost-%COMP%]   .message[_ngcontent-%COMP%]{margin-left:.5rem}"]
});
var NbSpinnerComponent = _NbSpinnerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerComponent, [{
    type: Component,
    args: [{
      selector: "nb-spinner",
      template: `
    <span class="spin-circle"></span>
    <span class="message" *ngIf="message">{{ message }}</span>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{opacity:1;position:absolute;border-radius:inherit;inset:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}:host .spin-circle{animation:spin .8s infinite linear;border-radius:50%;border-style:solid;border-width:.125em;width:1em;height:1em}:host .message{margin-left:.5rem}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    message: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbSpinnerDirective = class _NbSpinnerDirective {
  /**
   * Directive value - show or hide spinner
   * @param {boolean} val
   */
  set nbSpinner(val) {
    if (this.componentFactory) {
      if (val) {
        this.show();
      } else {
        this.hide();
      }
    } else {
      this.shouldShow = val;
    }
  }
  constructor(directiveView, componentFactoryResolver, renderer, directiveElement) {
    this.directiveView = directiveView;
    this.componentFactoryResolver = componentFactoryResolver;
    this.renderer = renderer;
    this.directiveElement = directiveElement;
    this.shouldShow = false;
    this.spinnerStatus = "basic";
    this.spinnerSize = "medium";
    this.isSpinnerExist = false;
  }
  ngOnInit() {
    this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(NbSpinnerComponent);
    if (this.shouldShow) {
      this.show();
    }
  }
  hide() {
    if (this.isSpinnerExist) {
      this.directiveView.remove();
      this.isSpinnerExist = false;
    }
  }
  show() {
    if (!this.isSpinnerExist) {
      this.spinner = this.directiveView.createComponent(this.componentFactory);
      this.setInstanceInputs(this.spinner.instance);
      this.spinner.changeDetectorRef.detectChanges();
      this.renderer.appendChild(this.directiveElement.nativeElement, this.spinner.location.nativeElement);
      this.isSpinnerExist = true;
    }
  }
  setInstanceInputs(instance) {
    instance.message = this.spinnerMessage;
    typeof this.spinnerStatus !== "undefined" && (instance.status = this.spinnerStatus);
    typeof this.spinnerSize !== "undefined" && (instance.size = this.spinnerSize);
  }
};
_NbSpinnerDirective.ɵfac = function NbSpinnerDirective_Factory(t) {
  return new (t || _NbSpinnerDirective)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
_NbSpinnerDirective.ɵdir = ɵɵdefineDirective({
  type: _NbSpinnerDirective,
  selectors: [["", "nbSpinner", ""]],
  hostVars: 2,
  hostBindings: function NbSpinnerDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("nb-spinner-container", ctx.isSpinnerExist);
    }
  },
  inputs: {
    spinnerMessage: [InputFlags.None, "nbSpinnerMessage", "spinnerMessage"],
    spinnerStatus: [InputFlags.None, "nbSpinnerStatus", "spinnerStatus"],
    spinnerSize: [InputFlags.None, "nbSpinnerSize", "spinnerSize"],
    nbSpinner: "nbSpinner"
  }
});
var NbSpinnerDirective = _NbSpinnerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSpinner]"
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    spinnerMessage: [{
      type: Input,
      args: ["nbSpinnerMessage"]
    }],
    spinnerStatus: [{
      type: Input,
      args: ["nbSpinnerStatus"]
    }],
    spinnerSize: [{
      type: Input,
      args: ["nbSpinnerSize"]
    }],
    nbSpinner: [{
      type: Input,
      args: ["nbSpinner"]
    }],
    isSpinnerExist: [{
      type: HostBinding,
      args: ["class.nb-spinner-container"]
    }]
  });
})();
var _NbSpinnerModule = class _NbSpinnerModule {
};
_NbSpinnerModule.ɵfac = function NbSpinnerModule_Factory(t) {
  return new (t || _NbSpinnerModule)();
};
_NbSpinnerModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSpinnerModule,
  declarations: [NbSpinnerComponent, NbSpinnerDirective],
  imports: [NbSharedModule],
  exports: [NbSpinnerComponent, NbSpinnerDirective]
});
_NbSpinnerModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbSpinnerModule = _NbSpinnerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      exports: [NbSpinnerComponent, NbSpinnerDirective],
      declarations: [NbSpinnerComponent, NbSpinnerDirective]
    }]
  }], null, null);
})();
var NB_STEPPER = new InjectionToken("Nebular Stepper Component");
var _NbStepComponent = class _NbStepComponent {
  /**
   * Whether step will be displayed in wizard
   *
   * @type {boolean}
   */
  get hidden() {
    return this._hidden;
  }
  set hidden(value) {
    this._hidden = convertToBoolProperty(value);
  }
  /**
   * Check that label is a TemplateRef.
   *
   * @return boolean
   * */
  get isLabelTemplate() {
    return this.label instanceof TemplateRef;
  }
  /**
   * Whether step is marked as completed.
   *
   * @type {boolean}
   */
  get completed() {
    return this._completed || this.isCompleted;
  }
  set completed(value) {
    this._completed = convertToBoolProperty(value);
  }
  get isCompleted() {
    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
  }
  constructor(stepper) {
    this._hidden = false;
    this._completed = false;
    this.interacted = false;
    this.stepper = stepper;
  }
  /**
   * Mark step as selected
   * */
  select() {
    this.stepper.selected = this;
  }
  /**
   * Reset step and stepControl state
   * */
  reset() {
    this.interacted = false;
    if (this.stepControl) {
      this.stepControl.reset();
    }
  }
};
_NbStepComponent.ɵfac = function NbStepComponent_Factory(t) {
  return new (t || _NbStepComponent)(ɵɵdirectiveInject(NB_STEPPER));
};
_NbStepComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbStepComponent,
  selectors: [["nb-step"]],
  viewQuery: function NbStepComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(TemplateRef, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
    }
  },
  inputs: {
    stepControl: "stepControl",
    label: "label",
    hidden: "hidden",
    completed: "completed"
  },
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbStepComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, NbStepComponent_ng_template_0_Template, 1, 0, "ng-template");
    }
  },
  encapsulation: 2
});
var NbStepComponent = _NbStepComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepComponent, [{
    type: Component,
    args: [{
      selector: "nb-step",
      template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_STEPPER]
    }]
  }], {
    content: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }],
    stepControl: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    completed: [{
      type: Input
    }]
  });
})();
var _NbStepperComponent = class _NbStepperComponent {
  constructor() {
    this._selectedIndex = 0;
    this._disableStepNavigation = false;
    this.orientation = "horizontal";
    this._linear = true;
    this.stepChange = new EventEmitter();
  }
  /**
   * Selected step index
   */
  get selectedIndex() {
    return this._selectedIndex;
  }
  set selectedIndex(index) {
    if (!this.steps) {
      this._selectedIndex = index;
      return;
    }
    this.markCurrentStepInteracted();
    if (this.canBeSelected(index)) {
      const previouslySelectedIndex = this._selectedIndex;
      const previouslySelectedStep = this.selected;
      this._selectedIndex = index;
      this.stepChange.emit({
        index: this.selectedIndex,
        step: this.selected,
        previouslySelectedIndex,
        previouslySelectedStep
      });
    }
  }
  /**
   * Disables navigation by clicking on steps. False by default
   * @param {boolean} value
   */
  set disableStepNavigation(value) {
    this._disableStepNavigation = convertToBoolProperty(value);
  }
  get disableStepNavigation() {
    return this._disableStepNavigation;
  }
  /**
   * Selected step component
   */
  get selected() {
    return this.steps ? this.steps.toArray()[this.selectedIndex] : void 0;
  }
  set selected(step) {
    if (!this.steps) {
      return;
    }
    this.selectedIndex = this.steps.toArray().indexOf(step);
  }
  /**
   * Allow moving forward only if the current step is complete
   * @default true
   */
  set linear(value) {
    this._linear = convertToBoolProperty(value);
  }
  get linear() {
    return this._linear;
  }
  get vertical() {
    return this.orientation === "vertical";
  }
  get horizontal() {
    return this.orientation === "horizontal";
  }
  /**
   * Navigate to next step
   * */
  next() {
    this.selectedIndex = Math.min(this.selectedIndex + 1, this.steps.length - 1);
  }
  /**
   * Navigate to previous step
   * */
  previous() {
    this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
  }
  /**
   * Select step if navigation is not disabled
   * @param { NbStepComponent } step
   */
  changeStep(step) {
    if (!this.disableStepNavigation) {
      step.select();
    }
  }
  /**
   * Reset stepper and stepControls to initial state
   * */
  reset() {
    const previouslySelectedIndex = this.selectedIndex;
    const previouslySelectedStep = this.selected;
    this._selectedIndex = 0;
    this.steps.forEach((step) => step.reset());
    this.stepChange.emit({
      index: this.selectedIndex,
      step: this.selected,
      previouslySelectedIndex,
      previouslySelectedStep
    });
  }
  isStepSelected(step) {
    return this.selected === step;
  }
  /*
   * @docs-private
   **/
  getStepTemplate(step) {
    if (step.isLabelTemplate) {
      return step.label;
    }
    return null;
  }
  isStepValid(index) {
    return this.steps.toArray()[index].completed;
  }
  canBeSelected(indexToCheck) {
    const noSteps = !this.steps || this.steps.length === 0;
    if (noSteps || indexToCheck < 0 || indexToCheck >= this.steps.length || indexToCheck === this.selectedIndex) {
      return false;
    }
    if (indexToCheck <= this.selectedIndex || !this.linear) {
      return true;
    }
    let isAllStepsValid = true;
    for (let i = this.selectedIndex; i < indexToCheck; i++) {
      if (!this.isStepValid(i)) {
        isAllStepsValid = false;
        break;
      }
    }
    return isAllStepsValid;
  }
  markCurrentStepInteracted() {
    if (this.selected) {
      this.selected.interacted = true;
    }
  }
};
_NbStepperComponent.ɵfac = function NbStepperComponent_Factory(t) {
  return new (t || _NbStepperComponent)();
};
_NbStepperComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbStepperComponent,
  selectors: [["nb-stepper"]],
  contentQueries: function NbStepperComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbStepComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.steps = _t);
    }
  },
  hostVars: 4,
  hostBindings: function NbStepperComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("vertical", ctx.vertical)("horizontal", ctx.horizontal);
    }
  },
  inputs: {
    selectedIndex: "selectedIndex",
    disableStepNavigation: "disableStepNavigation",
    selected: "selected",
    orientation: "orientation",
    linear: "linear"
  },
  outputs: {
    stepChange: "stepChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NB_STEPPER,
    useExisting: _NbStepperComponent
  }])],
  ngContentSelectors: _c32,
  decls: 5,
  vars: 2,
  consts: [[1, "header"], [4, "ngFor", "ngForOf"], [1, "step-content"], [3, "ngTemplateOutlet"], ["class", "connector", 3, "connector-past", 4, "ngIf"], ["class", "step", 3, "selected", "completed", "noninteractive", "click", 4, "ngIf"], [1, "connector"], [1, "step", 3, "click"], [1, "label-index"], [4, "ngIf"], ["icon", "checkmark-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "label"], ["icon", "checkmark-outline", "pack", "nebular-essentials"], [4, "ngTemplateOutlet"]],
  template: function NbStepperComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c31);
      ɵɵtemplate(0, NbStepperComponent_ng_template_0_Template, 1, 0, "ng-template");
      ɵɵelementStart(1, "div", 0);
      ɵɵtemplate(2, NbStepperComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 2);
      ɵɵelementContainer(4, 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.steps);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.selected == null ? null : ctx.selected.content);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, NbIconComponent],
  styles: [".horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{flex-direction:column}.horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{height:2px}.horizontal[_nghost-%COMP%]   .label-index[_ngcontent-%COMP%]{margin-bottom:10px}.vertical[_nghost-%COMP%]{display:flex;height:100%}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]{flex-direction:column}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{margin:0 10px}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{width:2px}.header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{flex:auto}.header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{display:flex;align-items:center;cursor:pointer}.header[_ngcontent-%COMP%]   .step.noninteractive[_ngcontent-%COMP%]{cursor:default}.header[_ngcontent-%COMP%]   .label-index[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center}.header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{width:max-content}"]
});
var NbStepperComponent = _NbStepperComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperComponent, [{
    type: Component,
    args: [{
      selector: "nb-stepper",
      providers: [{
        provide: NB_STEPPER,
        useExisting: NbStepperComponent
      }],
      template: '<ng-template><ng-content select="nb-step"></ng-content></ng-template>\n<div class="header">\n  <ng-container *ngFor="let step of steps; let index = index; let first = first">\n\n    <div *ngIf="!first && !step.hidden"\n         [class.connector-past]="index <= selectedIndex"\n         class="connector"></div>\n\n    <div *ngIf="!step.hidden" class="step"\n         [class.selected]="isStepSelected(step)"\n         [class.completed]="!isStepSelected(step) && step.completed"\n         [class.noninteractive]="disableStepNavigation"\n         (click)="changeStep(step)">\n      <div class="label-index">\n        <span *ngIf="!step.completed || isStepSelected(step)">{{ index + 1 }}</span>\n        <nb-icon *ngIf="!isStepSelected(step) && step.completed" icon="checkmark-outline" pack="nebular-essentials">\n        </nb-icon>\n      </div>\n      <div class="label">\n        <ng-container *ngIf="step.isLabelTemplate">\n          <ng-container *ngTemplateOutlet="getStepTemplate(step)"></ng-container>\n        </ng-container>\n        <span *ngIf="!step.isLabelTemplate">{{ step.label }}</span>\n      </div>\n    </div>\n  </ng-container>\n</div>\n<div class="step-content">\n  <ng-container [ngTemplateOutlet]="selected?.content"></ng-container>\n</div>\n',
      styles: [":host(.horizontal) .header .step{flex-direction:column}:host(.horizontal) .header .connector{height:2px}:host(.horizontal) .label-index{margin-bottom:10px}:host(.vertical){display:flex;height:100%}:host(.vertical) .header{flex-direction:column}:host(.vertical) .header .label{margin:0 10px}:host(.vertical) .header .connector{width:2px}.header{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header .connector{flex:auto}.header .step{display:flex;align-items:center;cursor:pointer}.header .step.noninteractive{cursor:default}.header .label-index{display:flex;justify-content:center;align-items:center}.header .label{width:max-content}\n"]
    }]
  }], null, {
    selectedIndex: [{
      type: Input
    }],
    disableStepNavigation: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    linear: [{
      type: Input
    }],
    stepChange: [{
      type: Output
    }],
    vertical: [{
      type: HostBinding,
      args: ["class.vertical"]
    }],
    horizontal: [{
      type: HostBinding,
      args: ["class.horizontal"]
    }],
    steps: [{
      type: ContentChildren,
      args: [NbStepComponent]
    }]
  });
})();
var _NbStepperNextDirective = class _NbStepperNextDirective {
  constructor(stepper) {
    this.stepper = stepper;
    this.type = "submit";
  }
  onClick() {
    this.stepper.next();
  }
};
_NbStepperNextDirective.ɵfac = function NbStepperNextDirective_Factory(t) {
  return new (t || _NbStepperNextDirective)(ɵɵdirectiveInject(NbStepperComponent));
};
_NbStepperNextDirective.ɵdir = ɵɵdefineDirective({
  type: _NbStepperNextDirective,
  selectors: [["button", "nbStepperNext", ""]],
  hostVars: 1,
  hostBindings: function NbStepperNextDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbStepperNextDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("type", ctx.type);
    }
  },
  inputs: {
    type: "type"
  }
});
var NbStepperNextDirective = _NbStepperNextDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperNextDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbStepperNext]"
    }]
  }], () => [{
    type: NbStepperComponent
  }], {
    type: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.type"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbStepperPreviousDirective = class _NbStepperPreviousDirective {
  constructor(stepper) {
    this.stepper = stepper;
    this.type = "button";
  }
  onClick() {
    this.stepper.previous();
  }
};
_NbStepperPreviousDirective.ɵfac = function NbStepperPreviousDirective_Factory(t) {
  return new (t || _NbStepperPreviousDirective)(ɵɵdirectiveInject(NbStepperComponent));
};
_NbStepperPreviousDirective.ɵdir = ɵɵdefineDirective({
  type: _NbStepperPreviousDirective,
  selectors: [["button", "nbStepperPrevious", ""]],
  hostVars: 1,
  hostBindings: function NbStepperPreviousDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbStepperPreviousDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("type", ctx.type);
    }
  },
  inputs: {
    type: "type"
  }
});
var NbStepperPreviousDirective = _NbStepperPreviousDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperPreviousDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbStepperPrevious]"
    }]
  }], () => [{
    type: NbStepperComponent
  }], {
    type: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.type"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbStepperModule = class _NbStepperModule {
};
_NbStepperModule.ɵfac = function NbStepperModule_Factory(t) {
  return new (t || _NbStepperModule)();
};
_NbStepperModule.ɵmod = ɵɵdefineNgModule({
  type: _NbStepperModule,
  declarations: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective]
});
_NbStepperModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbStepperModule = _NbStepperModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective],
      exports: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective]
    }]
  }], null, null);
})();
var _NbAccordionComponent = class _NbAccordionComponent {
  constructor() {
    this.openCloseItems = new Subject();
    this.multiValue = false;
  }
  /**
   *  Allow multiple items to be expanded at the same time.
   * @type {boolean}
   */
  get multi() {
    return this.multiValue;
  }
  set multi(val) {
    this.multiValue = convertToBoolProperty(val);
  }
  /**
   * Opens all enabled accordion items.
   */
  openAll() {
    if (this.multi) {
      this.openCloseItems.next(false);
    }
  }
  /**
   * Closes all enabled accordion items.
   */
  closeAll() {
    this.openCloseItems.next(true);
  }
};
_NbAccordionComponent.ɵfac = function NbAccordionComponent_Factory(t) {
  return new (t || _NbAccordionComponent)();
};
_NbAccordionComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAccordionComponent,
  selectors: [["nb-accordion"]],
  inputs: {
    multi: "multi"
  },
  ngContentSelectors: _c34,
  decls: 1,
  vars: 0,
  template: function NbAccordionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c33);
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbAccordionComponent = _NbAccordionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion",
      template: `
    <ng-content select="nb-accordion-item"></ng-content>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    multi: [{
      type: Input,
      args: ["multi"]
    }]
  });
})();
var _NbAccordionItemComponent = class _NbAccordionItemComponent {
  /**
   * Item is collapse (`true` by default)
   * @type {boolean}
   */
  get collapsed() {
    return this.collapsedValue;
  }
  set collapsed(val) {
    this.collapsedValue = convertToBoolProperty(val);
    this.collapsedChange.emit(this.collapsedValue);
    this.invalidate();
  }
  /**
   * Item is expanded (`false` by default)
   * @type {boolean}
   */
  get expanded() {
    return !this.collapsed;
  }
  set expanded(val) {
    this.collapsedValue = !convertToBoolProperty(val);
  }
  /**
   * Item is disabled and cannot be opened.
   * @type {boolean}
   */
  get disabled() {
    return this.disabledValue;
  }
  set disabled(val) {
    this.disabledValue = convertToBoolProperty(val);
    this.invalidate();
  }
  constructor(accordion, cd) {
    this.accordion = accordion;
    this.cd = cd;
    this.collapsedChange = new EventEmitter();
    this.accordionItemInvalidate = new Subject();
    this.collapsedValue = true;
    this.disabledValue = false;
    this.destroy$ = new Subject();
  }
  /**
   * Open/close the item
   */
  toggle() {
    if (!this.disabled) {
      const willSet = !this.collapsed;
      if (!this.accordion.multi) {
        this.accordion.openCloseItems.next(true);
      }
      this.collapsed = willSet;
    }
  }
  /**
   * Open the item.
   */
  open() {
    !this.disabled && (this.collapsed = false);
  }
  /**
   * Collapse the item.
   */
  close() {
    !this.disabled && (this.collapsed = true);
  }
  ngOnInit() {
    this.accordion.openCloseItems.pipe(takeUntil(this.destroy$)).subscribe((collapsed) => {
      !this.disabled && (this.collapsed = collapsed);
    });
  }
  ngOnChanges(changes) {
    this.accordionItemInvalidate.next(true);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.accordionItemInvalidate.complete();
  }
  invalidate() {
    this.accordionItemInvalidate.next(true);
    this.cd.markForCheck();
  }
};
_NbAccordionItemComponent.ɵfac = function NbAccordionItemComponent_Factory(t) {
  return new (t || _NbAccordionItemComponent)(ɵɵdirectiveInject(NbAccordionComponent, 1), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbAccordionItemComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAccordionItemComponent,
  selectors: [["nb-accordion-item"]],
  hostVars: 6,
  hostBindings: function NbAccordionItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("collapsed", ctx.collapsed)("expanded", ctx.expanded)("disabled", ctx.disabled);
    }
  },
  inputs: {
    collapsed: "collapsed",
    expanded: "expanded",
    disabled: "disabled"
  },
  outputs: {
    collapsedChange: "collapsedChange"
  },
  features: [ɵɵNgOnChangesFeature],
  ngContentSelectors: _c36,
  decls: 2,
  vars: 0,
  template: function NbAccordionItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c35);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
    }
  },
  styles: [_c8],
  changeDetection: 0
});
var NbAccordionItemComponent = _NbAccordionItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item",
      template: `
    <ng-content select="nb-accordion-item-header"></ng-content>
    <ng-content select="nb-accordion-item-body"></ng-content>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column}\n"]
    }]
  }], () => [{
    type: NbAccordionComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    collapsed: [{
      type: Input,
      args: ["collapsed"]
    }, {
      type: HostBinding,
      args: ["class.collapsed"]
    }],
    expanded: [{
      type: Input,
      args: ["expanded"]
    }, {
      type: HostBinding,
      args: ["class.expanded"]
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    collapsedChange: [{
      type: Output
    }]
  });
})();
var accordionItemBodyTrigger = trigger("accordionItemBody", [state("collapsed", style({
  overflow: "hidden",
  visibility: "hidden",
  height: 0
})), state("expanded", style({
  overflow: "hidden",
  visibility: "visible"
})), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))]);
var _NbAccordionItemBodyComponent = class _NbAccordionItemBodyComponent {
  constructor(accordionItem, cd) {
    this.accordionItem = accordionItem;
    this.cd = cd;
    this.destroy$ = new Subject();
  }
  get state() {
    return this.accordionItem.collapsed ? "collapsed" : "expanded";
  }
  ngOnInit() {
    this.accordionItem.accordionItemInvalidate.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbAccordionItemBodyComponent.ɵfac = function NbAccordionItemBodyComponent_Factory(t) {
  return new (t || _NbAccordionItemBodyComponent)(ɵɵdirectiveInject(NbAccordionItemComponent, 1), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbAccordionItemBodyComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAccordionItemBodyComponent,
  selectors: [["nb-accordion-item-body"]],
  ngContentSelectors: _c03,
  decls: 3,
  vars: 3,
  consts: [[1, "item-body"]],
  template: function NbAccordionItemBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div")(1, "div", 0);
      ɵɵprojection(2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("@accordionItemBody", ɵɵpureFunction1(1, _c37, ctx.state));
    }
  },
  encapsulation: 2,
  data: {
    animation: [accordionItemBodyTrigger]
  },
  changeDetection: 0
});
var NbAccordionItemBodyComponent = _NbAccordionItemBodyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemBodyComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item-body",
      template: `
    <div [@accordionItemBody]="{ value: state }">
      <div class="item-body">
        <ng-content></ng-content>
      </div>
    </div>
  `,
      animations: [accordionItemBodyTrigger],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbAccordionItemComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var _NbAccordionItemHeaderComponent = class _NbAccordionItemHeaderComponent {
  get isCollapsed() {
    return this.accordionItem.collapsed;
  }
  get expanded() {
    return !this.accordionItem.collapsed;
  }
  // issue #794
  get tabbable() {
    return this.accordionItem.disabled ? "-1" : "0";
  }
  get disabled() {
    return this.accordionItem.disabled;
  }
  toggle() {
    this.accordionItem.toggle();
  }
  get state() {
    if (this.isCollapsed) {
      return "collapsed";
    }
    return "expanded";
  }
  constructor(accordionItem, cd) {
    this.accordionItem = accordionItem;
    this.cd = cd;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.accordionItem.accordionItemInvalidate.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbAccordionItemHeaderComponent.ɵfac = function NbAccordionItemHeaderComponent_Factory(t) {
  return new (t || _NbAccordionItemHeaderComponent)(ɵɵdirectiveInject(NbAccordionItemComponent, 1), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbAccordionItemHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAccordionItemHeaderComponent,
  selectors: [["nb-accordion-item-header"]],
  hostVars: 7,
  hostBindings: function NbAccordionItemHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbAccordionItemHeaderComponent_click_HostBindingHandler() {
        return ctx.toggle();
      })("keydown.space", function NbAccordionItemHeaderComponent_keydown_space_HostBindingHandler() {
        return ctx.toggle();
      })("keydown.enter", function NbAccordionItemHeaderComponent_keydown_enter_HostBindingHandler() {
        return ctx.toggle();
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-expanded", ctx.expanded)("tabindex", ctx.tabbable)("aria-disabled", ctx.disabled);
      ɵɵclassProp("accordion-item-header-collapsed", ctx.isCollapsed)("accordion-item-header-expanded", ctx.expanded);
    }
  },
  ngContentSelectors: _c39,
  decls: 4,
  vars: 1,
  consts: [["icon", "chevron-down-outline", "pack", "nebular-essentials", "class", "expansion-indicator", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", 1, "expansion-indicator"]],
  template: function NbAccordionItemHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c38);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
      ɵɵprojection(2, 2);
      ɵɵtemplate(3, NbAccordionItemHeaderComponent_nb_icon_3_Template, 1, 1, "nb-icon", 0);
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("ngIf", !ctx.disabled);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;align-items:center;cursor:pointer}[_nghost-%COMP%]:focus{outline:0}"],
  data: {
    animation: [trigger("expansionIndicator", [state("expanded", style({
      transform: "rotate(180deg)"
    })), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))])]
  },
  changeDetection: 0
});
var NbAccordionItemHeaderComponent = _NbAccordionItemHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item-header",
      template: `
    <ng-content select="nb-accordion-item-title"></ng-content>
    <ng-content select="nb-accordion-item-description"></ng-content>
    <ng-content></ng-content>
    <nb-icon icon="chevron-down-outline"
             pack="nebular-essentials"
             [@expansionIndicator]="state"
             *ngIf="!disabled"
             class="expansion-indicator">
    </nb-icon>
  `,
      animations: [trigger("expansionIndicator", [state("expanded", style({
        transform: "rotate(180deg)"
      })), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))])],
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;align-items:center;cursor:pointer}:host:focus{outline:0}\n"]
    }]
  }], () => [{
    type: NbAccordionItemComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    isCollapsed: [{
      type: HostBinding,
      args: ["class.accordion-item-header-collapsed"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.accordion-item-header-expanded"]
    }, {
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    tabbable: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    toggle: [{
      type: HostListener,
      args: ["click"]
    }, {
      type: HostListener,
      args: ["keydown.space"]
    }, {
      type: HostListener,
      args: ["keydown.enter"]
    }]
  });
})();
var NB_ACCORDION_COMPONENTS = [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent];
var _NbAccordionModule = class _NbAccordionModule {
};
_NbAccordionModule.ɵfac = function NbAccordionModule_Factory(t) {
  return new (t || _NbAccordionModule)();
};
_NbAccordionModule.ɵmod = ɵɵdefineNgModule({
  type: _NbAccordionModule,
  declarations: [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent],
  imports: [CommonModule, NbIconModule],
  exports: [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent]
});
_NbAccordionModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbIconModule]
});
var NbAccordionModule = _NbAccordionModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      exports: [...NB_ACCORDION_COMPONENTS],
      declarations: [...NB_ACCORDION_COMPONENTS],
      providers: []
    }]
  }], null, null);
})();
var NB_BUTTON_GROUP = new InjectionToken("NB_BUTTON_GROUP");
var _NbButtonToggleDirective = class _NbButtonToggleDirective extends NbButton {
  get pressedChange$() {
    return this._pressedChange$.asObservable();
  }
  /**
   * Controls button pressed state
   **/
  get pressed() {
    return this._pressed;
  }
  set pressed(value) {
    if (this.pressed !== convertToBoolProperty(value)) {
      this._pressed = !this.pressed;
      this.pressedChange.emit(this.pressed);
      this._pressedChange$.next({
        source: this,
        pressed: this.pressed
      });
    }
  }
  get basic() {
    return !this.pressed;
  }
  get primary() {
    return this.pressed && (this.status === "basic" || this.status === "primary");
  }
  get success() {
    return this.pressed && this.status === "success";
  }
  get info() {
    return this.pressed && this.status === "info";
  }
  get warning() {
    return this.pressed && this.status === "warning";
  }
  get danger() {
    return this.pressed && this.status === "danger";
  }
  get control() {
    return this.pressed && this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  onClick() {
    if (this.buttonGroup?.multiple || !this.pressed) {
      this.pressed = !this.pressed;
    }
  }
  constructor(renderer, hostElement, cd, zone, statusService, buttonGroup) {
    super(renderer, hostElement, cd, zone, statusService);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
    this.buttonGroup = buttonGroup;
    this._pressedChange$ = new Subject();
    this.appearance = "filled";
    this._pressed = false;
    this.pressedChange = new EventEmitter();
  }
  /**
   * @docs-private
   */
  _updatePressed(value) {
    this.pressed = value;
    this.cd.markForCheck();
  }
};
_NbButtonToggleDirective.ɵfac = function NbButtonToggleDirective_Factory(t) {
  return new (t || _NbButtonToggleDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService), ɵɵdirectiveInject(NB_BUTTON_GROUP, 8));
};
_NbButtonToggleDirective.ɵdir = ɵɵdefineDirective({
  type: _NbButtonToggleDirective,
  selectors: [["button", "nbButtonToggle", ""]],
  hostVars: 17,
  hostBindings: function NbButtonToggleDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbButtonToggleDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-pressed", ctx.pressed);
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-basic", ctx.basic)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-control", ctx.control);
    }
  },
  inputs: {
    appearance: "appearance",
    value: "value",
    pressed: "pressed"
  },
  outputs: {
    pressedChange: "pressedChange"
  },
  exportAs: ["nbButtonToggle"],
  features: [ɵɵProvidersFeature([{
    provide: NbButton,
    useExisting: _NbButtonToggleDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbButtonToggleDirective = _NbButtonToggleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonToggleDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbButtonToggle]",
      providers: [{
        provide: NbButton,
        useExisting: NbButtonToggleDirective
      }],
      exportAs: "nbButtonToggle"
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_BUTTON_GROUP]
    }]
  }], {
    appearance: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    pressed: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-pressed"]
    }],
    pressedChange: [{
      type: Output
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbButtonGroupComponent = class _NbButtonGroupComponent {
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (this.disabled !== convertToBoolProperty(value)) {
      this._disabled = !this.disabled;
    }
  }
  /**
   * Allows to keep multiple button toggles pressed. Off by default.
   */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  /**
   * Sets `filled` appearance
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Sets `outline` appearance
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Sets `ghost` appearance
   */
  get ghost() {
    return this.appearance === "ghost";
  }
  set ghost(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "ghost";
    }
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(cd, statusService) {
    this.cd = cd;
    this.statusService = statusService;
    this.lastEmittedValue = [];
    this.destroy$ = new Subject();
    this.buttonsChange$ = new Subject();
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "filled";
    this._disabled = false;
    this._multiple = false;
    this.valueChange = new EventEmitter();
    this.role = "group";
  }
  ngOnChanges({
    size,
    status,
    shape,
    multiple,
    filled,
    outline,
    ghost,
    disabled
  }) {
    if (size || status || shape || multiple || filled || outline || ghost || disabled) {
      this.syncButtonsProperties(this.buttons?.toArray() || []);
    }
  }
  ngAfterContentInit() {
    this.buttonsChange$.pipe(takeUntil(this.destroy$)).subscribe((buttons) => {
      this.listenButtonPressedState(buttons);
      this.syncButtonsProperties(buttons);
    });
    this.buttons.changes.pipe(
      // `buttons.changes` emit during change detection run after projected content already was initialized.
      // So at this time, it's too late to update projected buttons properties as updating bindings after
      // initialization doesn't make sense. Changes won't be picked up and should cause an "expression changed" error.
      // Instead, we wrap the new buttons list into a promise to defer update to the following microtask and also to
      // trigger change detection one more time.
      switchMap((buttons) => from(Promise.resolve(buttons.toArray()))),
      takeUntil(this.destroy$)
    ).subscribe(this.buttonsChange$);
    this.buttonsChange$.next(this.buttons.toArray());
  }
  listenButtonPressedState(buttons) {
    const toggleButtons = buttons.filter((button) => {
      return button instanceof NbButtonToggleDirective;
    });
    if (!toggleButtons.length) {
      return;
    }
    const buttonsPressedChange$ = toggleButtons.map((button) => button.pressedChange$);
    merge(...buttonsPressedChange$).pipe(filter(({
      pressed
    }) => !this.multiple && pressed), takeUntil(merge(this.buttonsChange$, this.destroy$))).subscribe(({
      source
    }) => {
      toggleButtons.filter((button) => button !== source).forEach((button) => button._updatePressed(false));
    });
    merge(...buttonsPressedChange$).pipe(
      // Use startWith to emit if some buttons are initially pressed.
      startWith(""),
      // Use debounce to emit change once when pressed state change in multiple button toggles.
      debounceTime(0),
      takeUntil(merge(this.buttonsChange$, this.destroy$))
    ).subscribe(() => this.emitCurrentValue(toggleButtons));
  }
  syncButtonsProperties(buttons) {
    buttons.forEach((button) => {
      button.updateProperties({
        appearance: this.appearance,
        size: this.size,
        status: this.status,
        shape: this.shape,
        disabled: this.disabled
      });
    });
  }
  emitCurrentValue(toggleButtons) {
    const pressedToggleValues = toggleButtons.filter((b) => b.pressed && typeof b.value !== "undefined").map((b) => b.value);
    if (pressedToggleValues.length === 0 && this.lastEmittedValue.length === 0) {
      return;
    }
    this.valueChange.emit(pressedToggleValues);
    this.lastEmittedValue = pressedToggleValues;
  }
};
_NbButtonGroupComponent.ɵfac = function NbButtonGroupComponent_Factory(t) {
  return new (t || _NbButtonGroupComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbStatusService));
};
_NbButtonGroupComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbButtonGroupComponent,
  selectors: [["nb-button-group"]],
  contentQueries: function NbButtonGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbButton, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.buttons = _t);
    }
  },
  hostVars: 3,
  hostBindings: function NbButtonGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassMap(ctx.additionalClasses);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    disabled: "disabled",
    multiple: "multiple",
    filled: "filled",
    outline: "outline",
    ghost: "ghost"
  },
  outputs: {
    valueChange: "valueChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NB_BUTTON_GROUP,
    useExisting: _NbButtonGroupComponent
  }]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbButtonGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbButtonGroupComponent = _NbButtonGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-button-group",
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NB_BUTTON_GROUP,
        useExisting: NbButtonGroupComponent
      }]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NbStatusService
  }], {
    buttons: [{
      type: ContentChildren,
      args: [NbButton]
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    filled: [{
      type: Input
    }],
    outline: [{
      type: Input
    }],
    ghost: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbButtonGroupModule = class _NbButtonGroupModule {
};
_NbButtonGroupModule.ɵfac = function NbButtonGroupModule_Factory(t) {
  return new (t || _NbButtonGroupModule)();
};
_NbButtonGroupModule.ɵmod = ɵɵdefineNgModule({
  type: _NbButtonGroupModule,
  declarations: [NbButtonGroupComponent, NbButtonToggleDirective],
  exports: [NbButtonGroupComponent, NbButtonToggleDirective]
});
_NbButtonGroupModule.ɵinj = ɵɵdefineInjector({});
var NbButtonGroupModule = _NbButtonGroupModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonGroupModule, [{
    type: NgModule,
    args: [{
      declarations: [NbButtonGroupComponent, NbButtonToggleDirective],
      exports: [NbButtonGroupComponent, NbButtonToggleDirective]
    }]
  }], null, null);
})();
var _NbListPageTrackerDirective = class _NbListPageTrackerDirective {
  constructor() {
    this.destroy$ = new Subject();
    this.startPage = 1;
    this.pageChange = new EventEmitter();
    this.observer = new IntersectionObserver((entries) => this.checkForPageChange(entries), {
      threshold: 0.5
    });
  }
  ngAfterViewInit() {
    if (this.listItems && this.listItems.length) {
      this.observeItems();
    }
    this.listItems.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.observeItems());
  }
  ngOnDestroy() {
    this.observer.disconnect && this.observer.disconnect();
  }
  observeItems() {
    this.listItems.forEach((i) => this.observer.observe(i.nativeElement));
  }
  checkForPageChange(entries) {
    const mostVisiblePage = this.findMostVisiblePage(entries);
    if (mostVisiblePage && this.currentPage !== mostVisiblePage) {
      this.currentPage = mostVisiblePage;
      this.pageChange.emit(this.currentPage);
    }
  }
  findMostVisiblePage(entries) {
    const intersectionRatioByPage = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      if (entry.intersectionRatio < 0.5) {
        continue;
      }
      const elementIndex = this.elementIndex(entry.target);
      if (elementIndex === -1) {
        continue;
      }
      const page = this.startPage + Math.floor(elementIndex / this.pageSize);
      let ratio = entry.intersectionRatio;
      if (intersectionRatioByPage.has(page)) {
        ratio += intersectionRatioByPage.get(page);
      }
      intersectionRatioByPage.set(page, ratio);
    }
    let maxRatio = 0;
    let mostVisiblePage;
    intersectionRatioByPage.forEach((ratio, page) => {
      if (ratio > maxRatio) {
        maxRatio = ratio;
        mostVisiblePage = page;
      }
    });
    return mostVisiblePage;
  }
  elementIndex(element) {
    return element.parentElement && element.parentElement.children ? Array.from(element.parentElement.children).indexOf(element) : -1;
  }
};
_NbListPageTrackerDirective.ɵfac = function NbListPageTrackerDirective_Factory(t) {
  return new (t || _NbListPageTrackerDirective)();
};
_NbListPageTrackerDirective.ɵdir = ɵɵdefineDirective({
  type: _NbListPageTrackerDirective,
  selectors: [["", "nbListPageTracker", ""]],
  contentQueries: function NbListPageTrackerDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbListItemComponent, 4, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listItems = _t);
    }
  },
  inputs: {
    pageSize: "pageSize",
    startPage: "startPage"
  },
  outputs: {
    pageChange: "pageChange"
  }
});
var NbListPageTrackerDirective = _NbListPageTrackerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListPageTrackerDirective, [{
    type: Directive,
    args: [{
      selector: "[nbListPageTracker]"
    }]
  }], () => [], {
    pageSize: [{
      type: Input
    }],
    startPage: [{
      type: Input
    }],
    pageChange: [{
      type: Output
    }],
    listItems: [{
      type: ContentChildren,
      args: [NbListItemComponent, {
        read: ElementRef
      }]
    }]
  });
})();
var NbScrollableContainerDimensions = class {
};
var _NbInfiniteListDirective = class _NbInfiniteListDirective {
  get elementScroll() {
    return !this.windowScroll;
  }
  /**
   * Prevent subsequent bottom/topThreshold emissions for specified duration after emitting once.
   * In milliseconds.
   */
  set throttleTime(value) {
    this.throttleTime$.next(value);
  }
  get throttleTime() {
    return this.throttleTime$.value;
  }
  /**
   * By default component observes list scroll position.
   * If set to `true`, component will observe position of page scroll instead.
   */
  set listenWindowScroll(value) {
    this.windowScroll = convertToBoolProperty(value);
  }
  onElementScroll() {
    if (this.elementScroll) {
      this.elementScroll$.next();
    }
  }
  constructor(elementRef, scrollService, dimensionsService) {
    this.elementRef = elementRef;
    this.scrollService = scrollService;
    this.dimensionsService = dimensionsService;
    this.destroy$ = new Subject();
    this.windowScroll = false;
    this.elementScroll$ = new Subject();
    this.windowScroll$ = this.scrollService.onScroll().pipe(filter(() => this.windowScroll));
    this.bottomThreshold$ = new Subject();
    this.topThreshold$ = new Subject();
    this.throttleTime$ = new BehaviorSubject(0);
    this.bottomThreshold = new EventEmitter(true);
    this.topThreshold = new EventEmitter(true);
  }
  ngAfterViewInit() {
    merge(this.windowScroll$, this.elementScroll$).pipe(switchMap(() => this.getContainerDimensions()), takeUntil(this.destroy$)).subscribe((dimensions) => this.checkPosition(dimensions));
    this.throttleTime$.pipe(switchMap(() => this.topThreshold$.pipe(throttle(() => interval(this.throttleTime)))), takeUntil(this.destroy$)).subscribe(() => {
      this.topThreshold.emit();
    });
    this.throttleTime$.pipe(switchMap(() => this.bottomThreshold$.pipe(throttle(() => interval(this.throttleTime)))), takeUntil(this.destroy$)).subscribe(() => {
      this.bottomThreshold.emit();
    });
    this.listItems.changes.pipe(
      // For some reason, changes are emitted before list item removed from dom,
      // so dimensions will be incorrect.
      // Check every 50ms for a second if dom and query are in sync.
      // Once they synchronized, we can get proper dimensions.
      switchMap(() => interval(50).pipe(filter(() => this.inSyncWithDom()), take(1), takeUntil(timer(1e3)))),
      switchMap(() => this.getContainerDimensions()),
      takeUntil(this.destroy$)
    ).subscribe((dimensions) => this.checkPosition(dimensions));
    this.getContainerDimensions().subscribe((dimensions) => this.checkPosition(dimensions));
  }
  ngOnDestroy() {
    this.topThreshold$.complete();
    this.bottomThreshold$.complete();
    this.elementScroll$.complete();
    this.destroy$.next();
    this.destroy$.complete();
  }
  checkPosition({
    scrollHeight,
    scrollTop,
    clientHeight
  }) {
    const initialCheck = this.lastScrollPosition == null;
    const manualCheck = this.lastScrollPosition === scrollTop;
    const scrollUp = scrollTop < this.lastScrollPosition;
    const scrollDown = scrollTop > this.lastScrollPosition;
    const distanceToBottom = scrollHeight - scrollTop - clientHeight;
    if ((initialCheck || manualCheck || scrollDown) && distanceToBottom <= this.threshold) {
      this.bottomThreshold$.next();
    }
    if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {
      this.topThreshold$.next();
    }
    this.lastScrollPosition = scrollTop;
  }
  getContainerDimensions() {
    if (this.elementScroll) {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = this.elementRef.nativeElement;
      return of({
        scrollTop,
        scrollHeight,
        clientHeight
      });
    }
    return forkJoin([this.scrollService.getPosition(), this.dimensionsService.getDimensions()]).pipe(map(([scrollPosition, dimensions]) => ({
      scrollTop: scrollPosition.y,
      scrollHeight: dimensions.scrollHeight,
      clientHeight: dimensions.clientHeight
    })));
  }
  inSyncWithDom() {
    return this.elementRef.nativeElement.children.length === this.listItems.length;
  }
};
_NbInfiniteListDirective.ɵfac = function NbInfiniteListDirective_Factory(t) {
  return new (t || _NbInfiniteListDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbLayoutScrollService), ɵɵdirectiveInject(NbLayoutRulerService));
};
_NbInfiniteListDirective.ɵdir = ɵɵdefineDirective({
  type: _NbInfiniteListDirective,
  selectors: [["", "nbInfiniteList", ""]],
  contentQueries: function NbInfiniteListDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbListItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listItems = _t);
    }
  },
  hostBindings: function NbInfiniteListDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("scroll", function NbInfiniteListDirective_scroll_HostBindingHandler() {
        return ctx.onElementScroll();
      });
    }
  },
  inputs: {
    threshold: "threshold",
    throttleTime: "throttleTime",
    listenWindowScroll: "listenWindowScroll"
  },
  outputs: {
    bottomThreshold: "bottomThreshold",
    topThreshold: "topThreshold"
  }
});
var NbInfiniteListDirective = _NbInfiniteListDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInfiniteListDirective, [{
    type: Directive,
    args: [{
      selector: "[nbInfiniteList]"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbLayoutScrollService
  }, {
    type: NbLayoutRulerService
  }], {
    threshold: [{
      type: Input
    }],
    throttleTime: [{
      type: Input
    }],
    listenWindowScroll: [{
      type: Input
    }],
    bottomThreshold: [{
      type: Output
    }],
    topThreshold: [{
      type: Output
    }],
    onElementScroll: [{
      type: HostListener,
      args: ["scroll"]
    }],
    listItems: [{
      type: ContentChildren,
      args: [NbListItemComponent]
    }]
  });
})();
var components = [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective];
var _NbListModule = class _NbListModule {
};
_NbListModule.ɵfac = function NbListModule_Factory(t) {
  return new (t || _NbListModule)();
};
_NbListModule.ɵmod = ɵɵdefineNgModule({
  type: _NbListModule,
  declarations: [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective],
  exports: [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective]
});
_NbListModule.ɵinj = ɵɵdefineInjector({});
var NbListModule = _NbListModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListModule, [{
    type: NgModule,
    args: [{
      declarations: components,
      exports: components
    }]
  }], null, null);
})();
var _NbDirectionality = class _NbDirectionality extends Directionality {
};
_NbDirectionality.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbDirectionality_BaseFactory;
  return function NbDirectionality_Factory(t) {
    return (ɵNbDirectionality_BaseFactory || (ɵNbDirectionality_BaseFactory = ɵɵgetInheritedFactory(_NbDirectionality)))(t || _NbDirectionality);
  };
})();
_NbDirectionality.ɵprov = ɵɵdefineInjectable({
  token: _NbDirectionality,
  factory: _NbDirectionality.ɵfac
});
var NbDirectionality = _NbDirectionality;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDirectionality, [{
    type: Injectable
  }], null, null);
})();
var _NbBidiModule = class _NbBidiModule extends BidiModule {
};
_NbBidiModule.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbBidiModule_BaseFactory;
  return function NbBidiModule_Factory(t) {
    return (ɵNbBidiModule_BaseFactory || (ɵNbBidiModule_BaseFactory = ɵɵgetInheritedFactory(_NbBidiModule)))(t || _NbBidiModule);
  };
})();
_NbBidiModule.ɵmod = ɵɵdefineNgModule({
  type: _NbBidiModule
});
_NbBidiModule.ɵinj = ɵɵdefineInjector({
  providers: [{
    provide: NbDirectionality,
    useExisting: Directionality
  }]
});
var NbBidiModule = _NbBidiModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBidiModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: NbDirectionality,
        useExisting: Directionality
      }]
    }]
  }], null, null);
})();
var _NbCellDefDirective = class _NbCellDefDirective extends CdkCellDef {
};
_NbCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbCellDefDirective_BaseFactory;
  return function NbCellDefDirective_Factory(t) {
    return (ɵNbCellDefDirective_BaseFactory || (ɵNbCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbCellDefDirective)))(t || _NbCellDefDirective);
  };
})();
_NbCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbCellDefDirective,
  selectors: [["", "nbCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: CdkCellDef,
    useExisting: _NbCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbCellDefDirective = _NbCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbCellDef]",
      providers: [{
        provide: CdkCellDef,
        useExisting: NbCellDefDirective
      }]
    }]
  }], null, null);
})();
var _NbHeaderCellDefDirective = class _NbHeaderCellDefDirective extends CdkHeaderCellDef {
};
_NbHeaderCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbHeaderCellDefDirective_BaseFactory;
  return function NbHeaderCellDefDirective_Factory(t) {
    return (ɵNbHeaderCellDefDirective_BaseFactory || (ɵNbHeaderCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderCellDefDirective)))(t || _NbHeaderCellDefDirective);
  };
})();
_NbHeaderCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbHeaderCellDefDirective,
  selectors: [["", "nbHeaderCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: CdkHeaderCellDef,
    useExisting: _NbHeaderCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbHeaderCellDefDirective = _NbHeaderCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderCellDef]",
      providers: [{
        provide: CdkHeaderCellDef,
        useExisting: NbHeaderCellDefDirective
      }]
    }]
  }], null, null);
})();
var _NbFooterCellDefDirective = class _NbFooterCellDefDirective extends CdkFooterCellDef {
};
_NbFooterCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFooterCellDefDirective_BaseFactory;
  return function NbFooterCellDefDirective_Factory(t) {
    return (ɵNbFooterCellDefDirective_BaseFactory || (ɵNbFooterCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFooterCellDefDirective)))(t || _NbFooterCellDefDirective);
  };
})();
_NbFooterCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFooterCellDefDirective,
  selectors: [["", "nbFooterCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: CdkFooterCellDef,
    useExisting: _NbFooterCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbFooterCellDefDirective = _NbFooterCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterCellDef]",
      providers: [{
        provide: CdkFooterCellDef,
        useExisting: NbFooterCellDefDirective
      }]
    }]
  }], null, null);
})();
var NB_SORT_HEADER_COLUMN_DEF = new InjectionToken("NB_SORT_HEADER_COLUMN_DEF");
var _NbColumnDefDirective = class _NbColumnDefDirective extends CdkColumnDef {
  /** Unique name for this column. */
  get name() {
    return this._name;
  }
  set name(value) {
    this._setNameInput(value);
  }
  /** Whether this column should be sticky positioned on the end of the row */
  get stickyEnd() {
    return this._stickyEnd;
  }
  set stickyEnd(value) {
    const prevValue = this._stickyEnd;
    this._stickyEnd = coerceBooleanProperty(value);
    this._hasStickyChanged = prevValue !== this._stickyEnd;
  }
};
_NbColumnDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbColumnDefDirective_BaseFactory;
  return function NbColumnDefDirective_Factory(t) {
    return (ɵNbColumnDefDirective_BaseFactory || (ɵNbColumnDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbColumnDefDirective)))(t || _NbColumnDefDirective);
  };
})();
_NbColumnDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbColumnDefDirective,
  selectors: [["", "nbColumnDef", ""]],
  inputs: {
    name: [InputFlags.None, "nbColumnDef", "name"],
    sticky: "sticky",
    stickyEnd: "stickyEnd"
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkColumnDef,
    useExisting: _NbColumnDefDirective
  }, {
    provide: NB_SORT_HEADER_COLUMN_DEF,
    useExisting: _NbColumnDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbColumnDefDirective = _NbColumnDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbColumnDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbColumnDef]",
      providers: [{
        provide: CdkColumnDef,
        useExisting: NbColumnDefDirective
      }, {
        provide: NB_SORT_HEADER_COLUMN_DEF,
        useExisting: NbColumnDefDirective
      }]
    }]
  }], null, {
    name: [{
      type: Input,
      args: ["nbColumnDef"]
    }],
    sticky: [{
      type: Input
    }],
    stickyEnd: [{
      type: Input
    }]
  });
})();
var _NbHeaderCellDirective = class _NbHeaderCellDirective extends CdkHeaderCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
};
_NbHeaderCellDirective.ɵfac = function NbHeaderCellDirective_Factory(t) {
  return new (t || _NbHeaderCellDirective)(ɵɵdirectiveInject(NbColumnDefDirective), ɵɵdirectiveInject(ElementRef));
};
_NbHeaderCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbHeaderCellDirective,
  selectors: [["nb-header-cell"], ["th", "nbHeaderCell", ""]],
  hostAttrs: ["role", "columnheader", 1, "nb-header-cell"],
  features: [ɵɵInheritDefinitionFeature]
});
var NbHeaderCellDirective = _NbHeaderCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-header-cell, th[nbHeaderCell]",
      host: {
        "class": "nb-header-cell",
        "role": "columnheader"
      }
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var _NbFooterCellDirective = class _NbFooterCellDirective extends CdkFooterCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
};
_NbFooterCellDirective.ɵfac = function NbFooterCellDirective_Factory(t) {
  return new (t || _NbFooterCellDirective)(ɵɵdirectiveInject(NbColumnDefDirective), ɵɵdirectiveInject(ElementRef));
};
_NbFooterCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFooterCellDirective,
  selectors: [["nb-footer-cell"], ["td", "nbFooterCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-footer-cell"],
  features: [ɵɵInheritDefinitionFeature]
});
var NbFooterCellDirective = _NbFooterCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-footer-cell, td[nbFooterCell]",
      host: {
        "class": "nb-footer-cell",
        "role": "gridcell"
      }
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var _NbCellDirective = class _NbCellDirective extends CdkCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
};
_NbCellDirective.ɵfac = function NbCellDirective_Factory(t) {
  return new (t || _NbCellDirective)(ɵɵdirectiveInject(NbColumnDefDirective), ɵɵdirectiveInject(ElementRef));
};
_NbCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbCellDirective,
  selectors: [["nb-cell"], ["td", "nbCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-cell"],
  features: [ɵɵInheritDefinitionFeature]
});
var NbCellDirective = _NbCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-cell, td[nbCell]",
      host: {
        "class": "nb-cell",
        "role": "gridcell"
      }
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var NbDataSource = class extends DataSource {
};
var _NbDataRowOutletDirective = class _NbDataRowOutletDirective extends DataRowOutlet {
};
_NbDataRowOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbDataRowOutletDirective_BaseFactory;
  return function NbDataRowOutletDirective_Factory(t) {
    return (ɵNbDataRowOutletDirective_BaseFactory || (ɵNbDataRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbDataRowOutletDirective)))(t || _NbDataRowOutletDirective);
  };
})();
_NbDataRowOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbDataRowOutletDirective,
  selectors: [["", "nbRowOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: DataRowOutlet,
    useExisting: _NbDataRowOutletDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbDataRowOutletDirective = _NbDataRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDataRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRowOutlet]",
      providers: [{
        provide: DataRowOutlet,
        useExisting: NbDataRowOutletDirective
      }]
    }]
  }], null, null);
})();
var _NbHeaderRowOutletDirective = class _NbHeaderRowOutletDirective extends HeaderRowOutlet {
};
_NbHeaderRowOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbHeaderRowOutletDirective_BaseFactory;
  return function NbHeaderRowOutletDirective_Factory(t) {
    return (ɵNbHeaderRowOutletDirective_BaseFactory || (ɵNbHeaderRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderRowOutletDirective)))(t || _NbHeaderRowOutletDirective);
  };
})();
_NbHeaderRowOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbHeaderRowOutletDirective,
  selectors: [["", "nbHeaderRowOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: HeaderRowOutlet,
    useExisting: _NbHeaderRowOutletDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbHeaderRowOutletDirective = _NbHeaderRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderRowOutlet]",
      providers: [{
        provide: HeaderRowOutlet,
        useExisting: NbHeaderRowOutletDirective
      }]
    }]
  }], null, null);
})();
var _NbFooterRowOutletDirective = class _NbFooterRowOutletDirective extends FooterRowOutlet {
};
_NbFooterRowOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFooterRowOutletDirective_BaseFactory;
  return function NbFooterRowOutletDirective_Factory(t) {
    return (ɵNbFooterRowOutletDirective_BaseFactory || (ɵNbFooterRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFooterRowOutletDirective)))(t || _NbFooterRowOutletDirective);
  };
})();
_NbFooterRowOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFooterRowOutletDirective,
  selectors: [["", "nbFooterRowOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: FooterRowOutlet,
    useExisting: _NbFooterRowOutletDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbFooterRowOutletDirective = _NbFooterRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterRowOutlet]",
      providers: [{
        provide: FooterRowOutlet,
        useExisting: NbFooterRowOutletDirective
      }]
    }]
  }], null, null);
})();
var _NbNoDataRowOutletDirective = class _NbNoDataRowOutletDirective extends NoDataRowOutlet {
};
_NbNoDataRowOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbNoDataRowOutletDirective_BaseFactory;
  return function NbNoDataRowOutletDirective_Factory(t) {
    return (ɵNbNoDataRowOutletDirective_BaseFactory || (ɵNbNoDataRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbNoDataRowOutletDirective)))(t || _NbNoDataRowOutletDirective);
  };
})();
_NbNoDataRowOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbNoDataRowOutletDirective,
  selectors: [["", "nbNoDataRowOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: NoDataRowOutlet,
    useExisting: _NbNoDataRowOutletDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbNoDataRowOutletDirective = _NbNoDataRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbNoDataRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbNoDataRowOutlet]",
      providers: [{
        provide: NoDataRowOutlet,
        useExisting: NbNoDataRowOutletDirective
      }]
    }]
  }], null, null);
})();
var _NbCellOutletDirective = class _NbCellOutletDirective extends CdkCellOutlet {
};
_NbCellOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbCellOutletDirective_BaseFactory;
  return function NbCellOutletDirective_Factory(t) {
    return (ɵNbCellOutletDirective_BaseFactory || (ɵNbCellOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbCellOutletDirective)))(t || _NbCellOutletDirective);
  };
})();
_NbCellOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbCellOutletDirective,
  selectors: [["", "nbCellOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: CdkCellOutlet,
    useExisting: _NbCellOutletDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbCellOutletDirective = _NbCellOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbCellOutlet]",
      providers: [{
        provide: CdkCellOutlet,
        useExisting: NbCellOutletDirective
      }]
    }]
  }], null, null);
})();
var _NbHeaderRowDefDirective = class _NbHeaderRowDefDirective extends CdkHeaderRowDef {
};
_NbHeaderRowDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbHeaderRowDefDirective_BaseFactory;
  return function NbHeaderRowDefDirective_Factory(t) {
    return (ɵNbHeaderRowDefDirective_BaseFactory || (ɵNbHeaderRowDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderRowDefDirective)))(t || _NbHeaderRowDefDirective);
  };
})();
_NbHeaderRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbHeaderRowDefDirective,
  selectors: [["", "nbHeaderRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbHeaderRowDef", "columns"],
    sticky: [InputFlags.None, "nbHeaderRowDefSticky", "sticky"]
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkHeaderRowDef,
    useExisting: _NbHeaderRowDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbHeaderRowDefDirective = _NbHeaderRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderRowDef]",
      providers: [{
        provide: CdkHeaderRowDef,
        useExisting: NbHeaderRowDefDirective
      }]
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbHeaderRowDef"]
    }],
    sticky: [{
      type: Input,
      args: ["nbHeaderRowDefSticky"]
    }]
  });
})();
var _NbFooterRowDefDirective = class _NbFooterRowDefDirective extends CdkFooterRowDef {
};
_NbFooterRowDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFooterRowDefDirective_BaseFactory;
  return function NbFooterRowDefDirective_Factory(t) {
    return (ɵNbFooterRowDefDirective_BaseFactory || (ɵNbFooterRowDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFooterRowDefDirective)))(t || _NbFooterRowDefDirective);
  };
})();
_NbFooterRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFooterRowDefDirective,
  selectors: [["", "nbFooterRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbFooterRowDef", "columns"],
    sticky: [InputFlags.None, "nbFooterRowDefSticky", "sticky"]
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkFooterRowDef,
    useExisting: _NbFooterRowDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbFooterRowDefDirective = _NbFooterRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterRowDef]",
      providers: [{
        provide: CdkFooterRowDef,
        useExisting: NbFooterRowDefDirective
      }]
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbFooterRowDef"]
    }],
    sticky: [{
      type: Input,
      args: ["nbFooterRowDefSticky"]
    }]
  });
})();
var _NbRowDefDirective = class _NbRowDefDirective extends CdkRowDef {
};
_NbRowDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbRowDefDirective_BaseFactory;
  return function NbRowDefDirective_Factory(t) {
    return (ɵNbRowDefDirective_BaseFactory || (ɵNbRowDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbRowDefDirective)))(t || _NbRowDefDirective);
  };
})();
_NbRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbRowDefDirective,
  selectors: [["", "nbRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbRowDefColumns", "columns"],
    when: [InputFlags.None, "nbRowDefWhen", "when"]
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkRowDef,
    useExisting: _NbRowDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbRowDefDirective = _NbRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRowDef]",
      providers: [{
        provide: CdkRowDef,
        useExisting: NbRowDefDirective
      }]
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbRowDefColumns"]
    }],
    when: [{
      type: Input,
      args: ["nbRowDefWhen"]
    }]
  });
})();
var _NbHeaderRowComponent = class _NbHeaderRowComponent extends CdkHeaderRow {
};
_NbHeaderRowComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbHeaderRowComponent_BaseFactory;
  return function NbHeaderRowComponent_Factory(t) {
    return (ɵNbHeaderRowComponent_BaseFactory || (ɵNbHeaderRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderRowComponent)))(t || _NbHeaderRowComponent);
  };
})();
_NbHeaderRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbHeaderRowComponent,
  selectors: [["nb-header-row"], ["tr", "nbHeaderRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-header-row"],
  features: [ɵɵProvidersFeature([{
    provide: CdkHeaderRow,
    useExisting: _NbHeaderRowComponent
  }]), ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbHeaderRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbHeaderRowComponent = _NbHeaderRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-header-row, tr[nbHeaderRow]",
      template: `
    <ng-container nbCellOutlet></ng-container>`,
      host: {
        "class": "nb-header-row",
        "role": "row"
      },
      providers: [{
        provide: CdkHeaderRow,
        useExisting: NbHeaderRowComponent
      }]
    }]
  }], null, null);
})();
var _NbFooterRowComponent = class _NbFooterRowComponent extends CdkFooterRow {
};
_NbFooterRowComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFooterRowComponent_BaseFactory;
  return function NbFooterRowComponent_Factory(t) {
    return (ɵNbFooterRowComponent_BaseFactory || (ɵNbFooterRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbFooterRowComponent)))(t || _NbFooterRowComponent);
  };
})();
_NbFooterRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbFooterRowComponent,
  selectors: [["nb-footer-row"], ["tr", "nbFooterRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-footer-row"],
  features: [ɵɵProvidersFeature([{
    provide: CdkFooterRow,
    useExisting: _NbFooterRowComponent
  }]), ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbFooterRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbFooterRowComponent = _NbFooterRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-footer-row, tr[nbFooterRow]",
      template: `
    <ng-container nbCellOutlet></ng-container>`,
      host: {
        "class": "nb-footer-row",
        "role": "row"
      },
      providers: [{
        provide: CdkFooterRow,
        useExisting: NbFooterRowComponent
      }]
    }]
  }], null, null);
})();
var _NbRowComponent = class _NbRowComponent extends CdkRow {
};
_NbRowComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbRowComponent_BaseFactory;
  return function NbRowComponent_Factory(t) {
    return (ɵNbRowComponent_BaseFactory || (ɵNbRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbRowComponent)))(t || _NbRowComponent);
  };
})();
_NbRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRowComponent,
  selectors: [["nb-row"], ["tr", "nbRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-row"],
  features: [ɵɵProvidersFeature([{
    provide: CdkRow,
    useExisting: _NbRowComponent
  }]), ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbRowComponent = _NbRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-row, tr[nbRow]",
      template: `
    <ng-container nbCellOutlet></ng-container>`,
      host: {
        "class": "nb-row",
        "role": "row"
      },
      providers: [{
        provide: CdkRow,
        useExisting: NbRowComponent
      }]
    }]
  }], null, null);
})();
var NbCdkRowDef = CdkRowDef;
var NbCdkRow = CdkRow;
var NbCdkCellDef = CdkCellDef;
var NbCdkHeaderRowDef = CdkHeaderRowDef;
var NbCdkHeaderRow = CdkHeaderRow;
var NbCdkHeaderCellDef = CdkHeaderCellDef;
var NbCdkFooterRowDef = CdkFooterRowDef;
var NbCdkFooterRow = CdkFooterRow;
var NbCdkFooterCellDef = CdkFooterCellDef;
var NbCdkColumnDef = CdkColumnDef;
var NbCdkCell = CdkCell;
var NbCdkHeaderCell = CdkHeaderCell;
var NbCdkFooterCell = CdkFooterCell;
var NB_STICKY_POSITIONING_LISTENER = STICKY_POSITIONING_LISTENER;
var NB_TABLE_TEMPLATE = `
  <ng-container nbHeaderRowOutlet></ng-container>
  <ng-container nbRowOutlet></ng-container>
  <ng-container nbNoDataRowOutlet></ng-container>
  <ng-container nbFooterRowOutlet></ng-container>
`;
var NB_VIEW_REPEATER_STRATEGY = _VIEW_REPEATER_STRATEGY;
var NB_COALESCED_STYLE_SCHEDULER = _COALESCED_STYLE_SCHEDULER;
var NB_TABLE_PROVIDERS = [{
  provide: NB_VIEW_REPEATER_STRATEGY,
  useClass: _DisposeViewRepeaterStrategy
}, {
  provide: NB_COALESCED_STYLE_SCHEDULER,
  useClass: _CoalescedStyleScheduler
}];
var _NbTable = class _NbTable extends CdkTable {
  constructor(differs, changeDetectorRef, elementRef, role, dir, document2, platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener) {
    super(differs, changeDetectorRef, elementRef, role, dir, document2, platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener);
    this._viewRepeater = _viewRepeater;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._stickyPositioningListener = _stickyPositioningListener;
  }
};
_NbTable.ɵfac = function NbTable_Factory(t) {
  return new (t || _NbTable)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵinjectAttribute("role"), ɵɵdirectiveInject(NbDirectionality), ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPlatform), ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER), ɵɵdirectiveInject(NbViewportRulerAdapter), ɵɵdirectiveInject(NB_STICKY_POSITIONING_LISTENER, 12));
};
_NbTable.ɵcmp = ɵɵdefineComponent({
  type: _NbTable,
  selectors: [["nb-table-not-implemented"]],
  features: [ɵɵProvidersFeature(NB_TABLE_PROVIDERS), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbTable_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbTable = _NbTable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTable, [{
    type: Component,
    args: [{
      selector: "nb-table-not-implemented",
      template: ``,
      providers: NB_TABLE_PROVIDERS
    }]
  }], () => [{
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["role"]
    }]
  }, {
    type: NbDirectionality
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: _CoalescedStyleScheduler,
    decorators: [{
      type: Inject,
      args: [_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [NB_STICKY_POSITIONING_LISTENER]
    }]
  }], null);
})();
var COMPONENTS$2 = [
  NbTable,
  // Template defs
  NbHeaderCellDefDirective,
  NbHeaderRowDefDirective,
  NbColumnDefDirective,
  NbCellDefDirective,
  NbRowDefDirective,
  NbFooterCellDefDirective,
  NbFooterRowDefDirective,
  // Outlets
  NbDataRowOutletDirective,
  NbHeaderRowOutletDirective,
  NbFooterRowOutletDirective,
  NbNoDataRowOutletDirective,
  NbCellOutletDirective,
  // Cell directives
  NbHeaderCellDirective,
  NbCellDirective,
  NbFooterCellDirective,
  // Row directives
  NbHeaderRowComponent,
  NbRowComponent,
  NbFooterRowComponent
];
var _NbTableModule = class _NbTableModule extends CdkTableModule {
};
_NbTableModule.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTableModule_BaseFactory;
  return function NbTableModule_Factory(t) {
    return (ɵNbTableModule_BaseFactory || (ɵNbTableModule_BaseFactory = ɵɵgetInheritedFactory(_NbTableModule)))(t || _NbTableModule);
  };
})();
_NbTableModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTableModule,
  declarations: [
    NbTable,
    // Template defs
    NbHeaderCellDefDirective,
    NbHeaderRowDefDirective,
    NbColumnDefDirective,
    NbCellDefDirective,
    NbRowDefDirective,
    NbFooterCellDefDirective,
    NbFooterRowDefDirective,
    // Outlets
    NbDataRowOutletDirective,
    NbHeaderRowOutletDirective,
    NbFooterRowOutletDirective,
    NbNoDataRowOutletDirective,
    NbCellOutletDirective,
    // Cell directives
    NbHeaderCellDirective,
    NbCellDirective,
    NbFooterCellDirective,
    // Row directives
    NbHeaderRowComponent,
    NbRowComponent,
    NbFooterRowComponent
  ],
  imports: [NbBidiModule],
  exports: [
    NbTable,
    // Template defs
    NbHeaderCellDefDirective,
    NbHeaderRowDefDirective,
    NbColumnDefDirective,
    NbCellDefDirective,
    NbRowDefDirective,
    NbFooterCellDefDirective,
    NbFooterRowDefDirective,
    // Outlets
    NbDataRowOutletDirective,
    NbHeaderRowOutletDirective,
    NbFooterRowOutletDirective,
    NbNoDataRowOutletDirective,
    NbCellOutletDirective,
    // Cell directives
    NbHeaderCellDirective,
    NbCellDirective,
    NbFooterCellDirective,
    // Row directives
    NbHeaderRowComponent,
    NbRowComponent,
    NbFooterRowComponent
  ]
});
_NbTableModule.ɵinj = ɵɵdefineInjector({
  imports: [NbBidiModule]
});
var NbTableModule = _NbTableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTableModule, [{
    type: NgModule,
    args: [{
      imports: [NbBidiModule],
      declarations: [...COMPONENTS$2],
      exports: [...COMPONENTS$2]
    }]
  }], null, null);
})();
var NB_DIALOG_CONFIG = new InjectionToken("Default dialog options");
var NbDialogConfig = class {
  constructor(config) {
    this.hasBackdrop = true;
    this.backdropClass = "overlay-backdrop";
    this.dialogClass = "";
    this.closeOnBackdropClick = true;
    this.closeOnEsc = true;
    this.hasScroll = false;
    this.autoFocus = true;
    Object.assign(this, config);
  }
};
var NbDialogRef = class {
  constructor(overlayRef) {
    this.overlayRef = overlayRef;
    this.onClose$ = new Subject();
    this.onClose = this.onClose$.asObservable();
    this.onBackdropClick = this.overlayRef.backdropClick();
  }
  /**
   * Hides dialog.
   * */
  close(res) {
    this.overlayRef.detach();
    this.overlayRef.dispose();
    this.onClose$.next(res);
    this.onClose$.complete();
  }
};
var _NbDialogContainerComponent = class _NbDialogContainerComponent {
  constructor(config, elementRef, focusTrapFactory) {
    this.config = config;
    this.elementRef = elementRef;
    this.focusTrapFactory = focusTrapFactory;
  }
  ngOnInit() {
    if (this.config.autoFocus) {
      this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
      this.focusTrap.blurPreviouslyFocusedElement();
      this.focusTrap.focusInitialElement();
    }
  }
  ngOnDestroy() {
    if (this.config.autoFocus && this.focusTrap) {
      this.focusTrap.restoreFocus();
    }
  }
  attachComponentPortal(portal) {
    return this.portalOutlet.attachComponentPortal(portal);
  }
  attachTemplatePortal(portal) {
    return this.portalOutlet.attachTemplatePortal(portal);
  }
};
_NbDialogContainerComponent.ɵfac = function NbDialogContainerComponent_Factory(t) {
  return new (t || _NbDialogContainerComponent)(ɵɵdirectiveInject(NbDialogConfig), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbFocusTrapFactoryService));
};
_NbDialogContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbDialogContainerComponent,
  selectors: [["nb-dialog-container"]],
  viewQuery: function NbDialogContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalOutletDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    }
  },
  decls: 1,
  vars: 0,
  consts: [["nbPortalOutlet", ""]],
  template: function NbDialogContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbDialogContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
    }
  },
  dependencies: [NbPortalOutletDirective],
  encapsulation: 2
});
var NbDialogContainerComponent = _NbDialogContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-dialog-container",
      template: "<ng-template nbPortalOutlet></ng-template>"
    }]
  }], () => [{
    type: NbDialogConfig
  }, {
    type: ElementRef
  }, {
    type: NbFocusTrapFactoryService
  }], {
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective, {
        static: true
      }]
    }]
  });
})();
var _NbDialogService = class _NbDialogService {
  constructor(document2, globalConfig, positionBuilder, overlay, injector, cfr) {
    this.document = document2;
    this.globalConfig = globalConfig;
    this.positionBuilder = positionBuilder;
    this.overlay = overlay;
    this.injector = injector;
    this.cfr = cfr;
  }
  /**
   * Opens new instance of the dialog, may receive optional config.
   * */
  open(content, userConfig = {}) {
    const config = new NbDialogConfig(__spreadValues(__spreadValues({}, this.globalConfig), userConfig));
    const overlayRef = this.createOverlay(config);
    const dialogRef = new NbDialogRef(overlayRef);
    const container = this.createContainer(config, overlayRef);
    this.createContent(config, content, container, dialogRef);
    this.registerCloseListeners(config, overlayRef, dialogRef);
    return dialogRef;
  }
  createOverlay(config) {
    const positionStrategy = this.createPositionStrategy();
    const scrollStrategy = this.createScrollStrategy(config.hasScroll);
    return this.overlay.create({
      positionStrategy,
      scrollStrategy,
      hasBackdrop: config.hasBackdrop,
      backdropClass: config.backdropClass,
      panelClass: config.dialogClass
    });
  }
  createPositionStrategy() {
    return this.positionBuilder.global().centerVertically().centerHorizontally();
  }
  createScrollStrategy(hasScroll) {
    if (hasScroll) {
      return this.overlay.scrollStrategies.noop();
    } else {
      return this.overlay.scrollStrategies.block();
    }
  }
  createContainer(config, overlayRef) {
    const injector = new NbPortalInjector(this.createInjector(config), new WeakMap([[NbDialogConfig, config]]));
    const containerPortal = new NbComponentPortal(NbDialogContainerComponent, null, injector, this.cfr);
    const containerRef = overlayRef.attach(containerPortal);
    return containerRef.instance;
  }
  createContent(config, content, container, dialogRef) {
    if (content instanceof TemplateRef) {
      const portal = this.createTemplatePortal(config, content, dialogRef);
      container.attachTemplatePortal(portal);
    } else {
      const portal = this.createComponentPortal(config, content, dialogRef);
      dialogRef.componentRef = container.attachComponentPortal(portal);
      if (config.context) {
        Object.assign(dialogRef.componentRef.instance, __spreadValues({}, config.context));
      }
    }
  }
  createTemplatePortal(config, content, dialogRef) {
    return new NbTemplatePortal(content, null, {
      $implicit: config.context,
      dialogRef
    });
  }
  /**
   * We're creating portal with custom injector provided through config or using global injector.
   * This approach provides us capability inject `NbDialogRef` in dialog component.
   * */
  createComponentPortal(config, content, dialogRef) {
    const injector = this.createInjector(config);
    const portalInjector = new NbPortalInjector(injector, new WeakMap([[NbDialogRef, dialogRef]]));
    return new NbComponentPortal(content, config.viewContainerRef, portalInjector);
  }
  createInjector(config) {
    return config.viewContainerRef && config.viewContainerRef.injector || this.injector;
  }
  registerCloseListeners(config, overlayRef, dialogRef) {
    if (config.closeOnBackdropClick) {
      overlayRef.backdropClick().subscribe(() => dialogRef.close());
    }
    if (config.closeOnEsc) {
      fromEvent(this.document, "keyup").pipe(filter((event) => event.keyCode === 27), takeUntil(dialogRef.onClose)).subscribe(() => dialogRef.close());
    }
  }
};
_NbDialogService.ɵfac = function NbDialogService_Factory(t) {
  return new (t || _NbDialogService)(ɵɵinject(NB_DOCUMENT), ɵɵinject(NB_DIALOG_CONFIG), ɵɵinject(NbPositionBuilderService), ɵɵinject(NbOverlayService), ɵɵinject(Injector), ɵɵinject(ComponentFactoryResolver$1));
};
_NbDialogService.ɵprov = ɵɵdefineInjectable({
  token: _NbDialogService,
  factory: _NbDialogService.ɵfac
});
var NbDialogService = _NbDialogService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DIALOG_CONFIG]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: Injector
  }, {
    type: ComponentFactoryResolver$1
  }], null);
})();
var _NbDialogModule = class _NbDialogModule {
  static forRoot(dialogConfig = {}) {
    return {
      ngModule: _NbDialogModule,
      providers: [NbDialogService, {
        provide: NB_DIALOG_CONFIG,
        useValue: dialogConfig
      }]
    };
  }
  static forChild(dialogConfig = {}) {
    return {
      ngModule: _NbDialogModule,
      providers: [NbDialogService, {
        provide: NB_DIALOG_CONFIG,
        useValue: dialogConfig
      }]
    };
  }
};
_NbDialogModule.ɵfac = function NbDialogModule_Factory(t) {
  return new (t || _NbDialogModule)();
};
_NbDialogModule.ɵmod = ɵɵdefineNgModule({
  type: _NbDialogModule,
  declarations: [NbDialogContainerComponent],
  imports: [NbSharedModule, NbOverlayModule]
});
_NbDialogModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbOverlayModule]
});
var NbDialogModule = _NbDialogModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule],
      declarations: [NbDialogContainerComponent]
    }]
  }], null, null);
})();
var _NbToastComponent = class _NbToastComponent {
  get success() {
    return this.toast.config.status === "success";
  }
  get info() {
    return this.toast.config.status === "info";
  }
  get warning() {
    return this.toast.config.status === "warning";
  }
  get primary() {
    return this.toast.config.status === "primary";
  }
  get danger() {
    return this.toast.config.status === "danger";
  }
  get basic() {
    return this.toast.config.status === "basic";
  }
  get control() {
    return this.toast.config.status === "control";
  }
  get destroyByClick() {
    return this.toast.config.destroyByClick;
  }
  get hasIcon() {
    const {
      icon
    } = this.toast.config;
    if (typeof icon === "string") {
      return true;
    }
    return !!(icon && icon.icon);
  }
  get customIcon() {
    return !!this.icon;
  }
  get icon() {
    return this.toast.config.icon;
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.toast.config.status)) {
      return [this.statusService.getStatusClass(this.toast.config.status)];
    }
    return [];
  }
  onClick() {
    this.toastClick.emit();
  }
  constructor(renderer, elementRef, statusService) {
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.statusService = statusService;
    this.destroy = new EventEmitter();
    this.toastClick = new EventEmitter();
  }
  ngOnInit() {
    if (this.toast.config.toastClass) {
      this.renderer.addClass(this.elementRef.nativeElement, this.toast.config.toastClass);
    }
  }
  ngOnDestroy() {
    this.destroy.emit();
  }
};
_NbToastComponent.ɵfac = function NbToastComponent_Factory(t) {
  return new (t || _NbToastComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbStatusService));
};
_NbToastComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbToastComponent,
  selectors: [["nb-toast"]],
  hostVars: 22,
  hostBindings: function NbToastComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbToastComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-primary", ctx.primary)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("destroy-by-click", ctx.destroyByClick)("has-icon", ctx.hasIcon)("custom-icon", ctx.customIcon);
    }
  },
  inputs: {
    toast: "toast"
  },
  outputs: {
    destroy: "destroy",
    toastClick: "toastClick"
  },
  decls: 6,
  vars: 3,
  consts: [["class", "icon-container", 4, "ngIf"], [1, "content-container"], [1, "title", "subtitle"], [1, "message"], [1, "icon-container"], [3, "config"]],
  template: function NbToastComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbToastComponent_div_0_Template, 2, 1, "div", 0);
      ɵɵelementStart(1, "div", 1)(2, "span", 2);
      ɵɵtext(3);
      ɵɵelementEnd();
      ɵɵelementStart(4, "div", 3);
      ɵɵtext(5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.hasIcon && ctx.icon);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.toast.title);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.toast.message);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;align-items:center;width:25rem;margin:.5rem}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{margin-right:.25rem}.default[_nghost-%COMP%]   .content-container[_ngcontent-%COMP%], [_nghost-%COMP%]:not(.has-icon)   .content-container[_ngcontent-%COMP%]{display:flex;flex-direction:row}.destroy-by-click[_nghost-%COMP%]{cursor:pointer}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{font-size:2.5rem}[_nghost-%COMP%]   svg[_ngcontent-%COMP%]{width:2.5rem;height:2.5rem}"]
});
var NbToastComponent = _NbToastComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastComponent, [{
    type: Component,
    args: [{
      selector: "nb-toast",
      template: '<div class="icon-container" *ngIf="hasIcon && icon">\n  <nb-icon [config]="icon"></nb-icon>\n</div>\n<div class="content-container">\n  <span class="title subtitle">{{ toast.title }}</span>\n  <div class="message">{{ toast.message }}</div>\n</div>\n',
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;align-items:center;width:25rem;margin:.5rem}:host .title{margin-right:.25rem}:host.default .content-container,:host:not(.has-icon) .content-container{display:flex;flex-direction:row}:host.destroy-by-click{cursor:pointer}:host nb-icon{font-size:2.5rem}:host svg{width:2.5rem;height:2.5rem}\n"]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NbStatusService
  }], {
    toast: [{
      type: Input
    }],
    destroy: [{
      type: Output
    }],
    toastClick: [{
      type: Output
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    destroyByClick: [{
      type: HostBinding,
      args: ["class.destroy-by-click"]
    }],
    hasIcon: [{
      type: HostBinding,
      args: ["class.has-icon"]
    }],
    customIcon: [{
      type: HostBinding,
      args: ["class.custom-icon"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var voidState = style({
  transform: "translateX({{ direction }}110%)",
  height: 0,
  marginLeft: "0",
  marginRight: "0",
  marginTop: "0",
  marginBottom: "0"
});
var defaultOptions = {
  params: {
    direction: ""
  }
};
var _NbToastrContainerComponent = class _NbToastrContainerComponent {
  constructor(layoutDirection, positionHelper) {
    this.layoutDirection = layoutDirection;
    this.positionHelper = positionHelper;
    this.destroy$ = new Subject();
    this.content = [];
  }
  ngOnInit() {
    this.layoutDirection.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe(() => this.onDirectionChange());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  onDirectionChange() {
    const direction = this.positionHelper.isRightPosition(this.position) ? "" : "-";
    this.fadeIn = {
      value: "",
      params: {
        direction
      }
    };
  }
};
_NbToastrContainerComponent.ɵfac = function NbToastrContainerComponent_Factory(t) {
  return new (t || _NbToastrContainerComponent)(ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbPositionHelper));
};
_NbToastrContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbToastrContainerComponent,
  selectors: [["nb-toastr-container"]],
  viewQuery: function NbToastrContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbToastComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toasts = _t);
    }
  },
  inputs: {
    content: "content",
    context: "context",
    position: "position"
  },
  decls: 1,
  vars: 1,
  consts: [[3, "toast", 4, "ngFor", "ngForOf"], [3, "toast"]],
  template: function NbToastrContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbToastrContainerComponent_nb_toast_0_Template, 1, 2, "nb-toast", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.content);
    }
  },
  dependencies: [NgForOf, NbToastComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("fadeIn", [transition(":enter", [voidState, animate(100)], defaultOptions), transition(":leave", [animate(100, voidState)], defaultOptions)])]
  }
});
var NbToastrContainerComponent = _NbToastrContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-toastr-container",
      template: `
    <nb-toast [@fadeIn]="fadeIn" *ngFor="let toast of content" [toast]="toast"></nb-toast>`,
      animations: [trigger("fadeIn", [transition(":enter", [voidState, animate(100)], defaultOptions), transition(":leave", [animate(100, voidState)], defaultOptions)])]
    }]
  }], () => [{
    type: NbLayoutDirectionService
  }, {
    type: NbPositionHelper
  }], {
    content: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    toasts: [{
      type: ViewChildren,
      args: [NbToastComponent]
    }]
  });
})();
var NB_TOASTR_CONFIG = new InjectionToken("Default toastr options");
var NbToastrConfig = class {
  constructor(config) {
    this.position = NbGlobalLogicalPosition.TOP_END;
    this.status = "basic";
    this.duration = 3e3;
    this.destroyByClick = true;
    this.preventDuplicates = false;
    this.duplicatesBehaviour = "previous";
    this.limit = null;
    this.toastClass = "";
    this.hasIcon = true;
    this.icon = "email";
    this.icons = {
      danger: "flash-outline",
      success: "checkmark-outline",
      info: "question-mark-outline",
      warning: "alert-triangle-outline",
      primary: "email-outline",
      control: "email-outline",
      basic: "email-outline"
    };
    this.patchIcon(config);
    Object.assign(this, config);
  }
  patchIcon(config) {
    if (!("icon" in config)) {
      config.icon = {
        icon: this.icons[config.status] || this.icons.basic,
        pack: "nebular-essentials"
      };
    }
  }
};
var NbToastRef = class {
  constructor(toastContainer, toast) {
    this.toastContainer = toastContainer;
    this.toast = toast;
  }
  close() {
    this.toastContainer.destroy(this.toast);
  }
  onClose() {
    return this.toastInstance.destroy.asObservable();
  }
  onClick() {
    return this.toastInstance.toastClick.asObservable();
  }
};
var NbToastContainer = class {
  get nativeElement() {
    return this.containerRef.location.nativeElement;
  }
  constructor(position, containerRef, positionHelper) {
    this.position = position;
    this.containerRef = containerRef;
    this.positionHelper = positionHelper;
    this.toasts = [];
    this.toastDuplicateCompareFunc = (t1, t2) => {
      return t1.message === t2.message && t1.title === t2.title && t1.config.status === t2.config.status;
    };
  }
  attach(toast) {
    if (toast.config.preventDuplicates && this.isDuplicate(toast)) {
      return void 0;
    }
    this.removeToastIfLimitReached(toast);
    const toastComponent = this.attachToast(toast);
    if (toast.config.destroyByClick) {
      this.subscribeOnClick(toastComponent, toast);
    }
    if (toast.config.duration) {
      this.setDestroyTimeout(toast);
    }
    this.prevToast = toast;
    const toastRef = new NbToastRef(this, toast);
    toastRef.toastInstance = toastComponent;
    return toastRef;
  }
  destroy(toast) {
    if (this.prevToast === toast) {
      this.prevToast = null;
    }
    this.toasts = this.toasts.filter((t) => t !== toast);
    this.updateContainer();
  }
  isDuplicate(toast) {
    return toast.config.duplicatesBehaviour === "previous" ? this.isDuplicatePrevious(toast) : this.isDuplicateAmongAll(toast);
  }
  isDuplicatePrevious(toast) {
    return this.prevToast && this.toastDuplicateCompareFunc(this.prevToast, toast);
  }
  isDuplicateAmongAll(toast) {
    return this.toasts.some((t) => this.toastDuplicateCompareFunc(t, toast));
  }
  removeToastIfLimitReached(toast) {
    if (!toast.config.limit || this.toasts.length < toast.config.limit) {
      return;
    }
    if (this.positionHelper.isTopPosition(toast.config.position)) {
      this.toasts.pop();
    } else {
      this.toasts.shift();
    }
  }
  attachToast(toast) {
    if (this.positionHelper.isTopPosition(toast.config.position)) {
      return this.attachToTop(toast);
    } else {
      return this.attachToBottom(toast);
    }
  }
  attachToTop(toast) {
    this.toasts.unshift(toast);
    this.updateContainer();
    return this.containerRef.instance.toasts.first;
  }
  attachToBottom(toast) {
    this.toasts.push(toast);
    this.updateContainer();
    return this.containerRef.instance.toasts.last;
  }
  setDestroyTimeout(toast) {
    setTimeout(() => this.destroy(toast), toast.config.duration);
  }
  subscribeOnClick(toastComponent, toast) {
    toastComponent.toastClick.pipe(filter(() => toast.config.destroyByClick), takeUntil(toastComponent.destroy)).subscribe(() => this.destroy(toast));
  }
  updateContainer() {
    patch(this.containerRef, {
      content: this.toasts,
      position: this.position
    });
  }
};
var _NbToastrContainerRegistry = class _NbToastrContainerRegistry {
  constructor(overlay, positionBuilder, positionHelper, cfr, document2) {
    this.overlay = overlay;
    this.positionBuilder = positionBuilder;
    this.positionHelper = positionHelper;
    this.cfr = cfr;
    this.document = document2;
    this.overlays = /* @__PURE__ */ new Map();
  }
  get(position) {
    const logicalPosition = this.positionHelper.toLogicalPosition(position);
    const overlayWithContainer = this.overlays.get(logicalPosition);
    if (!overlayWithContainer || !this.existsInDom(overlayWithContainer.toastrContainer)) {
      if (overlayWithContainer) {
        overlayWithContainer.overlayRef.dispose();
      }
      this.instantiateContainer(logicalPosition);
    }
    return this.overlays.get(logicalPosition).toastrContainer;
  }
  instantiateContainer(position) {
    const toastrOverlayWithContainer = this.createContainer(position);
    this.overlays.set(position, toastrOverlayWithContainer);
  }
  createContainer(position) {
    const positionStrategy = this.positionBuilder.global().position(position);
    const ref = this.overlay.create({
      positionStrategy
    });
    this.addClassToOverlayHost(ref);
    const containerRef = ref.attach(new NbComponentPortal(NbToastrContainerComponent, null, null, this.cfr));
    return {
      overlayRef: ref,
      toastrContainer: new NbToastContainer(position, containerRef, this.positionHelper)
    };
  }
  addClassToOverlayHost(overlayRef) {
    overlayRef.hostElement.classList.add("toastr-overlay-container");
  }
  existsInDom(toastContainer) {
    return this.document.body.contains(toastContainer.nativeElement);
  }
};
_NbToastrContainerRegistry.ɵfac = function NbToastrContainerRegistry_Factory(t) {
  return new (t || _NbToastrContainerRegistry)(ɵɵinject(NbOverlayService), ɵɵinject(NbPositionBuilderService), ɵɵinject(NbPositionHelper), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NB_DOCUMENT));
};
_NbToastrContainerRegistry.ɵprov = ɵɵdefineInjectable({
  token: _NbToastrContainerRegistry,
  factory: _NbToastrContainerRegistry.ɵfac
});
var NbToastrContainerRegistry = _NbToastrContainerRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrContainerRegistry, [{
    type: Injectable
  }], () => [{
    type: NbOverlayService
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbPositionHelper
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbToastrService = class _NbToastrService {
  constructor(globalConfig, containerRegistry) {
    this.globalConfig = globalConfig;
    this.containerRegistry = containerRegistry;
  }
  /**
   * Shows toast with message, title and user config.
   * */
  show(message, title, userConfig) {
    const config = new NbToastrConfig(__spreadValues(__spreadValues({}, this.globalConfig), userConfig));
    const container = this.containerRegistry.get(config.position);
    const toast = {
      message,
      title,
      config
    };
    return container.attach(toast);
  }
  /**
   * Shows success toast with message, title and user config.
   * */
  success(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "success"
    }));
  }
  /**
   * Shows info toast with message, title and user config.
   * */
  info(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "info"
    }));
  }
  /**
   * Shows warning toast with message, title and user config.
   * */
  warning(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "warning"
    }));
  }
  /**
   * Shows primary toast with message, title and user config.
   * */
  primary(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "primary"
    }));
  }
  /**
   * Shows danger toast with message, title and user config.
   * */
  danger(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "danger"
    }));
  }
  /**
   * Shows default toast with message, title and user config.
   * */
  default(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "basic"
    }));
  }
  /**
   * Shows control toast with message, title and user config.
   * */
  control(message, title, config) {
    return this.default(message, title, __spreadProps(__spreadValues({}, config), {
      status: "control"
    }));
  }
};
_NbToastrService.ɵfac = function NbToastrService_Factory(t) {
  return new (t || _NbToastrService)(ɵɵinject(NB_TOASTR_CONFIG), ɵɵinject(NbToastrContainerRegistry));
};
_NbToastrService.ɵprov = ɵɵdefineInjectable({
  token: _NbToastrService,
  factory: _NbToastrService.ɵfac
});
var NbToastrService = _NbToastrService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrService, [{
    type: Injectable
  }], () => [{
    type: NbToastrConfig,
    decorators: [{
      type: Inject,
      args: [NB_TOASTR_CONFIG]
    }]
  }, {
    type: NbToastrContainerRegistry
  }], null);
})();
var _NbToastrModule = class _NbToastrModule {
  static forRoot(toastrConfig = {}) {
    return {
      ngModule: _NbToastrModule,
      providers: [NbToastrService, NbToastrContainerRegistry, {
        provide: NB_TOASTR_CONFIG,
        useValue: toastrConfig
      }]
    };
  }
};
_NbToastrModule.ɵfac = function NbToastrModule_Factory(t) {
  return new (t || _NbToastrModule)();
};
_NbToastrModule.ɵmod = ɵɵdefineNgModule({
  type: _NbToastrModule,
  declarations: [NbToastrContainerComponent, NbToastComponent],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule]
});
_NbToastrModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbIconModule]
});
var NbToastrModule = _NbToastrModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule],
      declarations: [NbToastrContainerComponent, NbToastComponent]
    }]
  }], null, null);
})();
var NbToast = class {
};
var _NbTooltipComponent = class _NbTooltipComponent {
  get binding() {
    return `${this.position} ${this.statusClass}`;
  }
  get show() {
    return true;
  }
  get statusClass() {
    if (this.context.status) {
      return this.statusService.getStatusClass(this.context.status);
    }
    return "";
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.position = NbPosition.TOP;
    this.context = {};
  }
  /**
   * The method is empty since we don't need to do anything additionally
   * render is handled by change detection
   */
  renderContent() {
  }
};
_NbTooltipComponent.ɵfac = function NbTooltipComponent_Factory(t) {
  return new (t || _NbTooltipComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTooltipComponent,
  selectors: [["nb-tooltip"]],
  hostVars: 3,
  hostBindings: function NbTooltipComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵsyntheticHostProperty("@showTooltip", ctx.show);
      ɵɵclassMap(ctx.binding);
    }
  },
  inputs: {
    content: "content",
    position: "position",
    context: "context"
  },
  decls: 4,
  vars: 2,
  consts: [[1, "arrow"], [1, "content"], [3, "config", 4, "ngIf"], [4, "ngIf"], [3, "config"]],
  template: function NbTooltipComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "span", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵtemplate(2, NbTooltipComponent_nb_icon_2_Template, 1, 1, "nb-icon", 2)(3, NbTooltipComponent_span_3_Template, 2, 1, "span", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.context == null ? null : ctx.context.icon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.content);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{z-index:10000}[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;align-items:center}.right[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{flex-direction:row-reverse}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}.right[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{border-left:6px solid transparent;border-right:6px solid transparent}.bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px;left:calc(50% - 6px)}.bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}[dir=rtl]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}.start-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;bottom:6px;transform:rotate(90deg)}.start-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;top:6px;transform:rotate(90deg)}.top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}.top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-5px;transform:rotate(180deg)}[dir=ltr]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-5px;transform:rotate(180deg)}[dir=ltr]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}[dir=rtl]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}.end-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8.4px;bottom:6px;transform:rotate(270deg)}.end-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8.4px;top:6px;transform:rotate(270deg)}"],
  data: {
    animation: [trigger("showTooltip", [state("in", style({
      opacity: 1
    })), transition("void => *", [style({
      opacity: 0
    }), animate(100)]), transition("* => void", [animate(100, style({
      opacity: 0
    }))])])]
  }
});
var NbTooltipComponent = _NbTooltipComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipComponent, [{
    type: Component,
    args: [{
      selector: "nb-tooltip",
      template: `
    <span class="arrow"></span>
    <div class="content">
      <nb-icon *ngIf="context?.icon" [config]="context.icon"></nb-icon>
      <span *ngIf="content">{{ content }}</span>
    </div>
  `,
      animations: [trigger("showTooltip", [state("in", style({
        opacity: 1
      })), transition("void => *", [style({
        opacity: 0
      }), animate(100)]), transition("* => void", [animate(100, style({
        opacity: 0
      }))])])],
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{z-index:10000}:host .content{display:flex;align-items:center}:host.right .content{flex-direction:row-reverse}:host .arrow{position:absolute;width:0;height:0}:host nb-icon+span{margin-left:.5rem}:host.right nb-icon+span{margin-right:.5rem}:host .arrow{border-left:6px solid transparent;border-right:6px solid transparent}:host(.bottom) .arrow{top:-6px;left:calc(50% - 6px)}:host(.bottom-start) .arrow{top:-6px}[dir=ltr] :host(.bottom-start) .arrow{right:6px}[dir=rtl] :host(.bottom-start) .arrow{left:6px}:host(.bottom-end) .arrow{top:-6px}[dir=ltr] :host(.bottom-end) .arrow{left:6px}[dir=rtl] :host(.bottom-end) .arrow{right:6px}:host(.left) .arrow,:host(.start) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.left) .arrow,[dir=ltr] :host(.start) .arrow{right:-8px;transform:rotate(90deg)}[dir=rtl] :host(.left) .arrow,[dir=rtl] :host(.start) .arrow{left:-8px;transform:rotate(270deg)}:host(.start-top) .arrow{right:-8px;bottom:6px;transform:rotate(90deg)}:host(.start-bottom) .arrow{right:-8px;top:6px;transform:rotate(90deg)}:host(.top) .arrow{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}:host(.top-start) .arrow{bottom:-5px;transform:rotate(180deg)}[dir=ltr] :host(.top-start) .arrow{right:6px}[dir=rtl] :host(.top-start) .arrow{left:6px}:host(.top-end) .arrow{bottom:-5px;transform:rotate(180deg)}[dir=ltr] :host(.top-end) .arrow{left:6px}[dir=rtl] :host(.top-end) .arrow{right:6px}:host(.right) .arrow,:host(.end) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.right) .arrow,[dir=ltr] :host(.end) .arrow{left:-8px;transform:rotate(270deg)}[dir=rtl] :host(.right) .arrow,[dir=rtl] :host(.end) .arrow{right:-8px;transform:rotate(90deg)}:host(.end-top) .arrow{left:-8.4px;bottom:6px;transform:rotate(270deg)}:host(.end-bottom) .arrow{left:-8.4px;top:6px;transform:rotate(270deg)}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    content: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    binding: [{
      type: HostBinding,
      args: ["class"]
    }],
    show: [{
      type: HostBinding,
      args: ["@showTooltip"]
    }],
    context: [{
      type: Input
    }]
  });
})();
var _NbTooltipDirective = class _NbTooltipDirective {
  /**
   * Container position will change automatically based on this strategy if container can't fit view port.
   * Set this property to `noop` value if you want to disable automatic adjustment.
   * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
   */
  get adjustment() {
    return this._adjustment;
  }
  set adjustment(value) {
    this._adjustment = value;
  }
  get tooltipClass() {
    return this._tooltipClass;
  }
  set tooltipClass(value) {
    if (value !== this.tooltipClass) {
      this._tooltipClass = value;
      this.overlayConfig = {
        panelClass: this.tooltipClass
      };
    }
  }
  /**
   * Accepts icon name or icon config object
   * @param {string | NbIconConfig} icon name or config object
   */
  set icon(icon) {
    this.context = Object.assign(this.context, {
      icon
    });
  }
  /**
   *
   * @param {string} status
   */
  set status(status) {
    this.context = Object.assign(this.context, {
      status
    });
  }
  get isShown() {
    return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
  }
  constructor(hostRef, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.destroy$ = new Subject();
    this.tooltipComponent = NbTooltipComponent;
    this.context = {};
    this.position = NbPosition.TOP;
    this._adjustment = NbAdjustment.CLOCKWISE;
    this._tooltipClass = "";
    this.trigger = NbTrigger.HINT;
    this.offset = 8;
    this.disabled = false;
    this.nbTooltipShowStateChange = new EventEmitter();
    this.overlayConfig = {
      panelClass: this.tooltipClass
    };
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(this.tooltipComponent).offset(this.offset);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.dynamicOverlay.isShown.pipe(skip(1), takeUntil(this.destroy$)).subscribe((isShown) => this.nbTooltipShowStateChange.emit({
      isShown
    }));
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).disabled(this.disabled).adjustment(this.adjustment).content(this.content).context(this.context).overlayConfig(this.overlayConfig);
  }
};
_NbTooltipDirective.ɵfac = function NbTooltipDirective_Factory(t) {
  return new (t || _NbTooltipDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbDynamicOverlayHandler));
};
_NbTooltipDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTooltipDirective,
  selectors: [["", "nbTooltip", ""]],
  inputs: {
    content: [InputFlags.None, "nbTooltip", "content"],
    position: [InputFlags.None, "nbTooltipPlacement", "position"],
    adjustment: [InputFlags.None, "nbTooltipAdjustment", "adjustment"],
    tooltipClass: [InputFlags.None, "nbTooltipClass", "tooltipClass"],
    icon: [InputFlags.None, "nbTooltipIcon", "icon"],
    status: [InputFlags.None, "nbTooltipStatus", "status"],
    trigger: [InputFlags.None, "nbTooltipTrigger", "trigger"],
    offset: [InputFlags.None, "nbTooltipOffset", "offset"],
    disabled: [InputFlags.None, "nbTooltipDisabled", "disabled"]
  },
  outputs: {
    nbTooltipShowStateChange: "nbTooltipShowStateChange"
  },
  exportAs: ["nbTooltip"],
  features: [ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵɵNgOnChangesFeature]
});
var NbTooltipDirective = _NbTooltipDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTooltip]",
      exportAs: "nbTooltip",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbDynamicOverlayHandler
  }], {
    content: [{
      type: Input,
      args: ["nbTooltip"]
    }],
    position: [{
      type: Input,
      args: ["nbTooltipPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbTooltipAdjustment"]
    }],
    tooltipClass: [{
      type: Input,
      args: ["nbTooltipClass"]
    }],
    icon: [{
      type: Input,
      args: ["nbTooltipIcon"]
    }],
    status: [{
      type: Input,
      args: ["nbTooltipStatus"]
    }],
    trigger: [{
      type: Input,
      args: ["nbTooltipTrigger"]
    }],
    offset: [{
      type: Input,
      args: ["nbTooltipOffset"]
    }],
    disabled: [{
      type: Input,
      args: ["nbTooltipDisabled"]
    }],
    nbTooltipShowStateChange: [{
      type: Output
    }]
  });
})();
var _NbTooltipModule = class _NbTooltipModule {
};
_NbTooltipModule.ɵfac = function NbTooltipModule_Factory(t) {
  return new (t || _NbTooltipModule)();
};
_NbTooltipModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTooltipModule,
  declarations: [NbTooltipComponent, NbTooltipDirective],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule],
  exports: [NbTooltipDirective]
});
_NbTooltipModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbIconModule]
});
var NbTooltipModule = _NbTooltipModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule],
      declarations: [NbTooltipComponent, NbTooltipDirective],
      exports: [NbTooltipDirective]
    }]
  }], null, null);
})();
var NB_SELECT_INJECTION_TOKEN = new InjectionToken("NB_SELECT_INJECTION_TOKEN");
var lastOptionId = 0;
var _NbOptionComponent = class _NbOptionComponent {
  get disabled() {
    return this._disabled || this.disabledByGroup;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  get click() {
    return this.click$.asObservable();
  }
  constructor(parent, elementRef, cd, zone, renderer) {
    this.elementRef = elementRef;
    this.cd = cd;
    this.zone = zone;
    this.renderer = renderer;
    this.disabledByGroup = false;
    this._disabled = false;
    this.selectionChange = new EventEmitter();
    this.click$ = new Subject();
    this.selected = false;
    this.alive = true;
    this.id = `nb-option-${lastOptionId++}`;
    this._active = false;
    this.parent = parent;
  }
  ngOnDestroy() {
    this.alive = false;
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  /**
   * Determines should we render checkbox.
   * */
  get withCheckbox() {
    return this.multiple && this.value != null;
  }
  get content() {
    return this.elementRef.nativeElement.textContent;
  }
  get hidden() {
    return this.elementRef.nativeElement.hidden;
  }
  // TODO: replace with isShowCheckbox property to control this behaviour outside, issues/1965
  get multiple() {
    return this.parent ? this.parent.multiple : false;
  }
  get selectedClass() {
    return this.selected;
  }
  get disabledAttribute() {
    return this.disabled ? "" : null;
  }
  get tabindex() {
    return "-1";
  }
  get activeClass() {
    return this._active;
  }
  onClick(event) {
    this.click$.next(this);
    event.preventDefault();
  }
  select() {
    this.setSelection(true);
  }
  deselect() {
    this.setSelection(false);
  }
  /**
   * Sets disabled by group state and marks component for check.
   */
  setDisabledByGroupState(disabled) {
    if (this.disabledByGroup !== disabled && this.alive) {
      this.disabledByGroup = disabled;
      this.cd.markForCheck();
    }
  }
  setSelection(selected) {
    if (this.alive && this.selected !== selected) {
      this.selected = selected;
      this.selectionChange.emit(this);
      this.cd.markForCheck();
    }
  }
  focus() {
    this.elementRef.nativeElement.focus();
  }
  getLabel() {
    return this.content;
  }
  setActiveStyles() {
    this._active = true;
    this.cd.markForCheck();
  }
  setInactiveStyles() {
    this._active = false;
    this.cd.markForCheck();
  }
};
_NbOptionComponent.ɵfac = function NbOptionComponent_Factory(t) {
  return new (t || _NbOptionComponent)(ɵɵdirectiveInject(NB_SELECT_INJECTION_TOKEN, 8), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
};
_NbOptionComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbOptionComponent,
  selectors: [["nb-option"]],
  hostVars: 9,
  hostBindings: function NbOptionComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbOptionComponent_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      })("keydown.space", function NbOptionComponent_keydown_space_HostBindingHandler($event) {
        return ctx.onClick($event);
      })("keydown.enter", function NbOptionComponent_keydown_enter_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("tabIndex", ctx.tabindex);
      ɵɵattribute("id", ctx.id)("disabled", ctx.disabledAttribute);
      ɵɵclassProp("multiple", ctx.multiple)("selected", ctx.selectedClass)("active", ctx.activeClass);
    }
  },
  inputs: {
    value: "value",
    disabled: "disabled"
  },
  outputs: {
    selectionChange: "selectionChange"
  },
  ngContentSelectors: _c03,
  decls: 2,
  vars: 1,
  consts: [["aria-hidden", "true", 3, "checked", "disabled", 4, "ngIf"], ["aria-hidden", "true", 3, "checked", "disabled"]],
  template: function NbOptionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, NbOptionComponent_nb_checkbox_0_Template, 1, 2, "nb-checkbox", 0);
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.withCheckbox);
    }
  },
  dependencies: [NgIf, NbCheckboxComponent],
  styles: ["\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]{display:flex}[hidden][_nghost-%COMP%]{display:none}[_nghost-%COMP%]:hover{cursor:pointer}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{display:flex;pointer-events:none}[dir=ltr]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-right:.5rem}[dir=rtl]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-left:.5rem}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]     .label{padding:0}[disabled][_nghost-%COMP%]{pointer-events:none}.nb-transition[_nghost-%COMP%]{transition-duration:.15s;transition-property:background-color,color;transition-timing-function:ease-in}"],
  changeDetection: 0
});
var NbOptionComponent = _NbOptionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionComponent, [{
    type: Component,
    args: [{
      selector: "nb-option",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <nb-checkbox *ngIf="withCheckbox" [checked]="selected" [disabled]="disabled" aria-hidden="true"> </nb-checkbox>
    <ng-content></ng-content>
  `,
      styles: ["/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex}:host[hidden]{display:none}:host:hover{cursor:pointer}:host nb-checkbox{display:flex;pointer-events:none}[dir=ltr] :host nb-checkbox{margin-right:.5rem}[dir=rtl] :host nb-checkbox{margin-left:.5rem}:host nb-checkbox ::ng-deep .label{padding:0}:host([disabled]){pointer-events:none}:host(.nb-transition){transition-duration:.15s;transition-property:background-color,color;transition-timing-function:ease-in}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_SELECT_INJECTION_TOKEN]
    }]
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }], {
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    multiple: [{
      type: HostBinding,
      args: ["class.multiple"]
    }],
    selectedClass: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    disabledAttribute: [{
      type: HostBinding,
      args: ["attr.disabled"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["tabIndex"]
    }],
    activeClass: [{
      type: HostBinding,
      args: ["class.active"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.space", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }]
  });
})();
var _NbOptionListComponent = class _NbOptionListComponent {
  constructor() {
    this.size = "medium";
  }
  get positionTop() {
    return this.position === NbPosition.TOP;
  }
  get positionBottom() {
    return this.position === NbPosition.BOTTOM;
  }
  get sizeTiny() {
    return this.size === "tiny";
  }
  get sizeSmall() {
    return this.size === "small";
  }
  get sizeMedium() {
    return this.size === "medium";
  }
  get sizeLarge() {
    return this.size === "large";
  }
  get sizeGiant() {
    return this.size === "giant";
  }
};
_NbOptionListComponent.ɵfac = function NbOptionListComponent_Factory(t) {
  return new (t || _NbOptionListComponent)();
};
_NbOptionListComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbOptionListComponent,
  selectors: [["nb-option-list"]],
  hostVars: 14,
  hostBindings: function NbOptionListComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("position-top", ctx.positionTop)("position-bottom", ctx.positionBottom)("size-tiny", ctx.sizeTiny)("size-small", ctx.sizeSmall)("size-medium", ctx.sizeMedium)("size-large", ctx.sizeLarge)("size-giant", ctx.sizeGiant);
    }
  },
  inputs: {
    size: "size",
    position: "position"
  },
  ngContentSelectors: _c03,
  decls: 2,
  vars: 0,
  consts: [[1, "option-list"]],
  template: function NbOptionListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "ul", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbOptionListComponent = _NbOptionListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionListComponent, [{
    type: Component,
    args: [{
      selector: "nb-option-list",
      template: `
    <ul class="option-list">
      <ng-content></ng-content>
    </ul>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    size: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    positionTop: [{
      type: HostBinding,
      args: ["class.position-top"]
    }],
    positionBottom: [{
      type: HostBinding,
      args: ["class.position-bottom"]
    }],
    sizeTiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    sizeSmall: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    sizeMedium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    sizeLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    sizeGiant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var _NbSelectLabelComponent = class _NbSelectLabelComponent {
};
_NbSelectLabelComponent.ɵfac = function NbSelectLabelComponent_Factory(t) {
  return new (t || _NbSelectLabelComponent)();
};
_NbSelectLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSelectLabelComponent,
  selectors: [["nb-select-label"]],
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NbSelectLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbSelectLabelComponent = _NbSelectLabelComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectLabelComponent, [{
    type: Component,
    args: [{
      selector: "nb-select-label",
      template: "<ng-content></ng-content>"
    }]
  }], null, null);
})();
function nbSelectFormFieldControlConfigFactory() {
  const config = new NbFormFieldControlConfig();
  config.supportsSuffix = false;
  return config;
}
var _NbSelectComponent = class _NbSelectComponent {
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  /**
   * Adds `outline` styles
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Adds `filled` styles
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Adds `hero` styles
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  /**
   * Disables the select
   */
  get disabled() {
    return !!this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * A function to compare option value with selected value.
   * By default, values are compared with strict equality (`===`).
   */
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    if (typeof fn !== "function") {
      return;
    }
    this._compareWith = fn;
    if (this.selectionModel.length && this.canSelectValue()) {
      this.setSelection(this.selected);
    }
  }
  /**
   * Accepts selected item or array of selected items.
   * */
  set selected(value) {
    this.writeValue(value);
  }
  get selected() {
    return this.multiple ? this.selectionModel.map((o) => o.value) : this.selectionModel[0].value;
  }
  /**
   * Gives capability just write `multiple` over the element.
   * */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Determines is select opened.
   * */
  get isOpen() {
    return this.ref && this.ref.hasAttached();
  }
  constructor(document2, overlay, hostRef, positionBuilder, triggerStrategyBuilder, cd, focusKeyManagerFactoryService, focusMonitor, renderer, zone, statusService) {
    this.document = document2;
    this.overlay = overlay;
    this.hostRef = hostRef;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cd = cd;
    this.focusKeyManagerFactoryService = focusKeyManagerFactoryService;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "outline";
    this._fullWidth = false;
    this.placeholder = "";
    this._compareWith = (v1, v2) => v1 === v2;
    this._multiple = false;
    this.optionsOverlayOffset = 8;
    this.scrollStrategy = "block";
    this.selectedChange = new EventEmitter();
    this.selectionModel = [];
    this.overlayPosition = "";
    this.alive = true;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.size);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(this.disabled);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
  }
  /**
   * Determines is select hidden.
   * */
  get isHidden() {
    return !this.isOpen;
  }
  /**
   * Returns width of the select button.
   * */
  get hostWidth() {
    return this.button.nativeElement.getBoundingClientRect().width;
  }
  get selectButtonClasses() {
    const classes = [];
    if (!this.selectionModel.length) {
      classes.push("placeholder");
    }
    if (!this.selectionModel.length && !this.placeholder) {
      classes.push("empty");
    }
    if (this.isOpen) {
      classes.push(this.overlayPosition);
    }
    return classes;
  }
  /**
   * Content rendered in the label.
   * */
  get selectionView() {
    if (this.selectionModel.length > 1) {
      return this.selectionModel.map((option) => option.content).join(", ");
    }
    return this.selectionModel[0].content;
  }
  ngOnChanges({
    disabled,
    status,
    size,
    fullWidth
  }) {
    if (disabled) {
      this.disabled$.next(disabled.currentValue);
    }
    if (status) {
      this.status$.next(status.currentValue);
    }
    if (size) {
      this.size$.next(size.currentValue);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngAfterContentInit() {
    this.options.changes.pipe(
      startWith(this.options),
      filter(() => this.queue != null && this.canSelectValue()),
      // Call 'writeValue' when current change detection run is finished.
      // When writing is finished, change detection starts again, since
      // microtasks queue is empty.
      // Prevents ExpressionChangedAfterItHasBeenCheckedError.
      switchMap((options) => from(Promise.resolve(options))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.writeValue(this.queue));
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnButtonFocus();
    this.subscribeOnTriggers();
    this.subscribeOnOptionClick();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.alive = false;
    this.destroy$.next();
    this.destroy$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  show() {
    if (this.shouldShow()) {
      this.attachToOverlay();
      this.positionStrategy.positionChange.pipe(take(1), takeUntil(this.destroy$)).subscribe(() => {
        this.setActiveOption();
      });
      this.cd.markForCheck();
    }
  }
  hide() {
    if (this.isOpen) {
      this.ref.detach();
      this.cd.markForCheck();
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd.markForCheck();
  }
  writeValue(value) {
    if (!this.alive) {
      return;
    }
    if (this.canSelectValue()) {
      this.setSelection(value);
      if (this.selectionModel.length) {
        this.queue = null;
      }
    } else {
      this.queue = value;
    }
  }
  /**
   * Selects option or clear all selected options if value is null.
   * */
  handleOptionClick(option) {
    this.queue = null;
    if (option.value == null) {
      this.reset();
    } else {
      this.selectOption(option);
    }
    this.cd.markForCheck();
  }
  /**
   * Deselect all selected options.
   * */
  reset() {
    this.selectionModel.forEach((option) => option.deselect());
    this.selectionModel = [];
    this.hide();
    this.button.nativeElement.focus();
    this.emitSelected(this.multiple ? [] : null);
  }
  /**
   * Determines how to select option as multiple or single.
   * */
  selectOption(option) {
    if (this.multiple) {
      this.handleMultipleSelect(option);
    } else {
      this.handleSingleSelect(option);
    }
  }
  /**
   * Select single option.
   * */
  handleSingleSelect(option) {
    const selected = this.selectionModel.pop();
    if (selected && !this._compareWith(selected.value, option.value)) {
      selected.deselect();
    }
    this.selectionModel = [option];
    option.select();
    this.hide();
    this.button.nativeElement.focus();
    this.emitSelected(option.value);
  }
  /**
   * Select for multiple options.
   * */
  handleMultipleSelect(option) {
    if (option.selected) {
      this.selectionModel = this.selectionModel.filter((s) => !this._compareWith(s.value, option.value));
      option.deselect();
    } else {
      this.selectionModel.push(option);
      option.select();
    }
    this.emitSelected(this.selectionModel.map((opt) => opt.value));
  }
  attachToOverlay() {
    if (!this.ref) {
      this.createOverlay();
      this.subscribeOnPositionChange();
      this.createKeyManager();
      this.subscribeOnOverlayKeys();
    }
    this.ref.attach(this.portal);
  }
  setActiveOption() {
    if (this.selectionModel.length) {
      this.keyManager.setActiveItem(this.selectionModel[0]);
    } else {
      this.keyManager.setFirstItemActive();
    }
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.positionStrategy = this.createPositionStrategy();
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy,
      panelClass: this.optionsPanelClass
    });
  }
  createKeyManager() {
    this.keyManager = this.focusKeyManagerFactoryService.create(this.options).withTypeAhead(200);
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.button).position(NbPosition.BOTTOM).offset(this.optionsOverlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.CLICK).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(($event) => {
      this.hide();
      if (!this.isClickedWithinComponent($event)) {
        this.onTouched();
      }
    });
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => {
      this.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  subscribeOnOptionClick() {
    this.options.changes.pipe(startWith(this.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleOptionClick(clickedOption));
  }
  subscribeOnOverlayKeys() {
    this.ref.keydownEvents().pipe(filter(() => this.isOpen), takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE) {
        this.button.nativeElement.focus();
        this.hide();
      } else {
        this.keyManager.onKeydown(event);
      }
    });
    this.keyManager.tabOut.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.hide();
      this.onTouched();
    });
  }
  subscribeOnButtonFocus() {
    this.focusMonitor.monitor(this.button).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.button)), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  getContainer() {
    return this.ref && this.ref.hasAttached() && {
      location: {
        nativeElement: this.ref.overlayElement
      }
    };
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.onChange(selected);
    this.selectedChange.emit(selected);
  }
  /**
   * Set selected value in model.
   * */
  setSelection(value) {
    const isResetValue = value == null;
    let safeValue = value;
    if (this.multiple) {
      safeValue = value ?? [];
    }
    const isArray = Array.isArray(safeValue);
    if (this.multiple && !isArray && !isResetValue) {
      throw new Error("Can't assign single value if select is marked as multiple");
    }
    if (!this.multiple && isArray) {
      throw new Error("Can't assign array if select is not marked as multiple");
    }
    const previouslySelectedOptions = this.selectionModel;
    this.selectionModel = [];
    if (this.multiple) {
      safeValue.forEach((option) => this.selectValue(option));
    } else {
      this.selectValue(safeValue);
    }
    previouslySelectedOptions.filter((option) => !this.selectionModel.includes(option)).forEach((option) => option.deselect());
    this.cd.markForCheck();
  }
  /**
   * Selects value.
   * */
  selectValue(value) {
    if (value == null) {
      return;
    }
    const corresponding = this.options.find((option) => this._compareWith(option.value, value));
    if (corresponding) {
      corresponding.select();
      this.selectionModel.push(corresponding);
    }
  }
  shouldShow() {
    return this.isHidden && this.options?.length > 0;
  }
  /**
   * Sets touched if focus moved outside of button and overlay,
   * ignoring the case when focus moved to options overlay.
   */
  trySetTouched() {
    if (this.isHidden) {
      this.onTouched();
    }
  }
  isClickedWithinComponent($event) {
    return this.hostRef.nativeElement === $event.target || this.hostRef.nativeElement.contains($event.target);
  }
  canSelectValue() {
    return !!(this.options && this.options.length);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
};
_NbSelectComponent.ɵfac = function NbSelectComponent_Factory(t) {
  return new (t || _NbSelectComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbFocusKeyManagerFactoryService), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbSelectComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSelectComponent,
  selectors: [["nb-select"]],
  contentQueries: function NbSelectComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbSelectLabelComponent, 5);
      ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.customLabel = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  viewQuery: function NbSelectComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalDirective, 5);
      ɵɵviewQuery(_c40, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.button = _t.first);
    }
  },
  hostVars: 42,
  hostBindings: function NbSelectComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("appearance-outline", ctx.outline)("appearance-filled", ctx.filled)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("open", ctx.isOpen)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    optionsListClass: "optionsListClass",
    optionsPanelClass: "optionsPanelClass",
    optionsWidth: "optionsWidth",
    outline: "outline",
    filled: "filled",
    hero: "hero",
    disabled: "disabled",
    fullWidth: "fullWidth",
    placeholder: "placeholder",
    compareWith: "compareWith",
    selected: "selected",
    multiple: "multiple",
    optionsOverlayOffset: "optionsOverlayOffset",
    scrollStrategy: "scrollStrategy"
  },
  outputs: {
    selectedChange: "selectedChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbSelectComponent),
    multi: true
  }, {
    provide: NB_SELECT_INJECTION_TOKEN,
    useExisting: _NbSelectComponent
  }, {
    provide: NbFormFieldControl,
    useExisting: _NbSelectComponent
  }, {
    provide: NbFormFieldControlConfig,
    useFactory: nbSelectFormFieldControlConfigFactory
  }]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c42,
  decls: 8,
  vars: 4,
  consts: [["selectButton", ""], ["placeholderTemplate", ""], ["defaultSelectionTemplate", ""], ["type", "button", 1, "select-button", 3, "blur", "keydown.arrowDown", "keydown.arrowUp", "disabled", "ngClass"], [3, "click"], [4, "ngIf", "ngIfElse"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"], [3, "size", "position", "width", "ngClass", 4, "nbPortal"], [3, "size", "position", "ngClass"]],
  template: function NbSelectComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c41);
      ɵɵelementStart(0, "button", 3, 0);
      ɵɵlistener("blur", function NbSelectComponent_Template_button_blur_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.trySetTouched());
      })("keydown.arrowDown", function NbSelectComponent_Template_button_keydown_arrowDown_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.show());
      })("keydown.arrowUp", function NbSelectComponent_Template_button_keydown_arrowUp_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.show());
      });
      ɵɵelementStart(2, "span", 4);
      ɵɵlistener("click", function NbSelectComponent_Template_span_click_2_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.disabled && $event.stopPropagation());
      });
      ɵɵtemplate(3, NbSelectComponent_ng_container_3_Template, 4, 2, "ng-container", 5)(4, NbSelectComponent_ng_template_4_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
      ɵɵelementStart(6, "nb-icon", 6);
      ɵɵlistener("click", function NbSelectComponent_Template_nb_icon_click_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.disabled && $event.stopPropagation());
      });
      ɵɵelementEnd()();
      ɵɵtemplate(7, NbSelectComponent_nb_option_list_7_Template, 2, 5, "nb-option-list", 7);
    }
    if (rf & 2) {
      const placeholderTemplate_r4 = ɵɵreference(5);
      ɵɵproperty("disabled", ctx.disabled)("ngClass", ctx.selectButtonClasses);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.selectionModel.length)("ngIfElse", placeholderTemplate_r4);
    }
  },
  dependencies: [NgClass, NgIf, NbPortalDirective, NbIconComponent, NbOptionListComponent],
  styles: ["\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]{display:inline-block;max-width:100%}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:left}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.2em}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:right}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.2em}.full-width[_nghost-%COMP%]{width:100%}.nb-transition[_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button[_ngcontent-%COMP%]{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon[_ngcontent-%COMP%]{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.5rem}[dir=rtl][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.5rem}.open[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{transform:translateY(-50%) rotate(180deg)}"],
  changeDetection: 0
});
var NbSelectComponent = _NbSelectComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectComponent, [{
    type: Component,
    args: [{
      selector: "nb-select",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbSelectComponent),
        multi: true
      }, {
        provide: NB_SELECT_INJECTION_TOKEN,
        useExisting: NbSelectComponent
      }, {
        provide: NbFormFieldControl,
        useExisting: NbSelectComponent
      }, {
        provide: NbFormFieldControlConfig,
        useFactory: nbSelectFormFieldControlConfigFactory
      }],
      template: '<button\n  [disabled]="disabled"\n  [ngClass]="selectButtonClasses"\n  (blur)="trySetTouched()"\n  (keydown.arrowDown)="show()"\n  (keydown.arrowUp)="show()"\n  class="select-button"\n  type="button"\n  #selectButton\n>\n  <span (click)="disabled && $event.stopPropagation()">\n    <ng-container *ngIf="selectionModel.length; else placeholderTemplate">\n      <ng-container *ngIf="customLabel; else defaultSelectionTemplate">\n        <ng-content select="nb-select-label"></ng-content>\n      </ng-container>\n\n      <ng-template #defaultSelectionTemplate>{{ selectionView }}</ng-template>\n    </ng-container>\n\n    <ng-template #placeholderTemplate>{{ placeholder }}</ng-template>\n  </span>\n\n  <nb-icon\n    icon="chevron-down-outline"\n    pack="nebular-essentials"\n    (click)="disabled && $event.stopPropagation()"\n    aria-hidden="true"\n  >\n  </nb-icon>\n</button>\n\n<nb-option-list\n  *nbPortal\n  [size]="size"\n  [position]="overlayPosition"\n  [style.width.px]="optionsWidth"\n  [ngClass]="optionsListClass"\n>\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: ["/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:inline-block;max-width:100%}[dir=ltr] :host .select-button{text-align:left}[dir=ltr] :host .select-button nb-icon{right:.2em}[dir=rtl] :host .select-button{text-align:right}[dir=rtl] :host .select-button nb-icon{left:.2em}:host(.full-width){width:100%}:host(.nb-transition) .select-button{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr] nb-icon{right:.5rem}[dir=rtl] nb-icon{left:.5rem}:host(.open) nb-icon{transform:translateY(-50%) rotate(180deg)}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbOverlayService
  }, {
    type: ElementRef
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbFocusKeyManagerFactoryService
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    disabled: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    placeholder: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    optionsOverlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    selectedChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    customLabel: [{
      type: ContentChild,
      args: [NbSelectLabelComponent]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    button: [{
      type: ViewChild,
      args: ["selectButton", {
        read: ElementRef
      }]
    }],
    isOpen: [{
      type: HostBinding,
      args: ["class.open"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }]
  });
})();
var _NbOptionGroupComponent = class _NbOptionGroupComponent {
  constructor() {
    this.destroy$ = new Subject();
    this._disabled = false;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
    if (this.options) {
      this.updateOptionsDisabledState();
    }
  }
  get disabledAttribute() {
    return this.disabled ? "" : null;
  }
  ngAfterContentInit() {
    if (this.options.length) {
      this.asyncUpdateOptionsDisabledState();
    }
    this.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.asyncUpdateOptionsDisabledState());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Sets disabled state for each option to current group disabled state.
   */
  updateOptionsDisabledState() {
    this.options.forEach((option) => option.setDisabledByGroupState(this.disabled));
  }
  /**
   * Updates options disabled state after promise resolution.
   * This way change detection will be triggered after options state updated.
   * Use this method when updating options during change detection run (e.g. QueryList.changes, lifecycle hooks).
   */
  asyncUpdateOptionsDisabledState() {
    from(Promise.resolve()).pipe(takeUntil(this.destroy$)).subscribe(() => this.updateOptionsDisabledState());
  }
};
_NbOptionGroupComponent.ɵfac = function NbOptionGroupComponent_Factory(t) {
  return new (t || _NbOptionGroupComponent)();
};
_NbOptionGroupComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbOptionGroupComponent,
  selectors: [["nb-option-group"]],
  contentQueries: function NbOptionGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  hostVars: 1,
  hostBindings: function NbOptionGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("disabled", ctx.disabledAttribute);
    }
  },
  inputs: {
    title: "title",
    disabled: "disabled"
  },
  ngContentSelectors: _c44,
  decls: 3,
  vars: 1,
  consts: [[1, "option-group-title"]],
  template: function NbOptionGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c43);
      ɵɵelementStart(0, "span", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵprojection(2);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.title);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:block}.option-group-title[_ngcontent-%COMP%]{display:block}"],
  changeDetection: 0
});
var NbOptionGroupComponent = _NbOptionGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-option-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <span class="option-group-title">{{ title }}</span>
    <ng-content select="nb-option, ng-container"></ng-content>
  `,
      styles: ["/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:block}.option-group-title{display:block}\n"]
    }]
  }], null, {
    title: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    disabledAttribute: [{
      type: HostBinding,
      args: ["attr.disabled"]
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }]
  });
})();
var NB_OPTION_LIST_COMPONENTS = [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent];
var _NbOptionModule = class _NbOptionModule {
};
_NbOptionModule.ɵfac = function NbOptionModule_Factory(t) {
  return new (t || _NbOptionModule)();
};
_NbOptionModule.ɵmod = ɵɵdefineNgModule({
  type: _NbOptionModule,
  declarations: [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent],
  imports: [CommonModule, NbCheckboxModule],
  exports: [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent]
});
_NbOptionModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbCheckboxModule]
});
var NbOptionModule = _NbOptionModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionModule, [{
    type: NgModule,
    args: [{
      declarations: [...NB_OPTION_LIST_COMPONENTS],
      imports: [CommonModule, NbCheckboxModule],
      exports: [...NB_OPTION_LIST_COMPONENTS]
    }]
  }], null, null);
})();
var NB_SELECT_COMPONENTS$1 = [NbSelectComponent, NbSelectLabelComponent];
var _NbSelectModule = class _NbSelectModule {
};
_NbSelectModule.ɵfac = function NbSelectModule_Factory(t) {
  return new (t || _NbSelectModule)();
};
_NbSelectModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSelectModule,
  declarations: [NbSelectComponent, NbSelectLabelComponent],
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule],
  exports: [NbSelectComponent, NbSelectLabelComponent, NbOptionModule]
});
_NbSelectModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbOptionModule]
});
var NbSelectModule = _NbSelectModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule],
      exports: [...NB_SELECT_COMPONENTS$1, NbOptionModule],
      declarations: [...NB_SELECT_COMPONENTS$1]
    }]
  }], null, null);
})();
var _NbPrefixDirective = class _NbPrefixDirective {
};
_NbPrefixDirective.ɵfac = function NbPrefixDirective_Factory(t) {
  return new (t || _NbPrefixDirective)();
};
_NbPrefixDirective.ɵdir = ɵɵdefineDirective({
  type: _NbPrefixDirective,
  selectors: [["", "nbPrefix", ""]]
});
var NbPrefixDirective = _NbPrefixDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPrefixDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPrefix]"
    }]
  }], null, null);
})();
var _NbSuffixDirective = class _NbSuffixDirective {
};
_NbSuffixDirective.ɵfac = function NbSuffixDirective_Factory(t) {
  return new (t || _NbSuffixDirective)();
};
_NbSuffixDirective.ɵdir = ɵɵdefineDirective({
  type: _NbSuffixDirective,
  selectors: [["", "nbSuffix", ""]]
});
var NbSuffixDirective = _NbSuffixDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSuffixDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSuffix]"
    }]
  }], null, null);
})();
function throwFormControlElementNotFound() {
  throw new Error(`NbFormFieldComponent must contain [nbInput]`);
}
var _NbFormFieldComponent = class _NbFormFieldComponent {
  constructor(cd, zone, elementRef, renderer) {
    this.cd = cd;
    this.zone = zone;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.destroy$ = new Subject();
    this.formControlState$ = new ReplaySubject(1);
    this.prefixClasses$ = this.formControlState$.pipe(map((s) => this.getAddonClasses("prefix", s)));
    this.suffixClasses$ = this.formControlState$.pipe(map((s) => this.getAddonClasses("suffix", s)));
  }
  ngAfterContentChecked() {
    if (!this.formControl) {
      throwFormControlElementNotFound();
    }
  }
  ngAfterContentInit() {
    this.subscribeToFormControlStateChange();
    this.subscribeToAddonChange();
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  shouldShowPrefix() {
    return this.getFormControlConfig().supportsPrefix && !!this.prefix.length;
  }
  shouldShowSuffix() {
    return this.getFormControlConfig().supportsSuffix && !!this.suffix.length;
  }
  subscribeToFormControlStateChange() {
    const {
      disabled$,
      focused$,
      size$,
      status$,
      fullWidth$
    } = this.formControl;
    combineLatest([disabled$, focused$, size$, status$, fullWidth$]).pipe(map(([disabled, focused, size, status, fullWidth]) => ({
      disabled,
      focused,
      size,
      status,
      fullWidth
    })), distinctUntilChanged((oldState, state2) => this.isStatesEqual(oldState, state2)), tap(({
      size,
      fullWidth
    }) => {
      const formFieldClasses = [`nb-form-field-size-${size}`];
      if (!fullWidth) {
        formFieldClasses.push("nb-form-field-limited-width");
      }
      this.formFieldClasses = formFieldClasses.join(" ");
    }), takeUntil(this.destroy$)).subscribe(this.formControlState$);
  }
  subscribeToAddonChange() {
    merge(this.prefix.changes, this.suffix.changes).pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  getAddonClasses(addon, state2) {
    const classes = ["nb-form-field-addon", `nb-form-field-${addon}-${state2.size}`];
    if (state2.disabled) {
      classes.push(`nb-form-field-addon-disabled`);
    } else if (state2.focused) {
      classes.push(`nb-form-field-addon-${state2.status}-highlight`);
    } else {
      classes.push(`nb-form-field-addon-${state2.status}`);
    }
    return classes;
  }
  getFormControlConfig() {
    return this.formControlConfig || new NbFormFieldControlConfig();
  }
  isStatesEqual(oldState, state2) {
    return oldState.status === state2.status && oldState.disabled === state2.disabled && oldState.focused === state2.focused && oldState.fullWidth === state2.fullWidth && oldState.size === state2.size;
  }
};
_NbFormFieldComponent.ɵfac = function NbFormFieldComponent_Factory(t) {
  return new (t || _NbFormFieldComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
_NbFormFieldComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbFormFieldComponent,
  selectors: [["nb-form-field"]],
  contentQueries: function NbFormFieldComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbFormFieldControl, 5);
      ɵɵcontentQuery(dirIndex, NbFormFieldControlConfig, 5);
      ɵɵcontentQuery(dirIndex, NbPrefixDirective, 5);
      ɵɵcontentQuery(dirIndex, NbSuffixDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.formControl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.formControlConfig = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefix = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffix = _t);
    }
  },
  hostVars: 2,
  hostBindings: function NbFormFieldComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.formFieldClasses);
    }
  },
  ngContentSelectors: _c46,
  decls: 4,
  vars: 6,
  consts: [[3, "ngClass", 4, "ngIf"], [1, "nb-form-control-container"], [3, "ngClass"]],
  template: function NbFormFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c45);
      ɵɵtemplate(0, NbFormFieldComponent_div_0_Template, 3, 3, "div", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵtemplate(3, NbFormFieldComponent_div_3_Template, 3, 3, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.shouldShowPrefix());
      ɵɵadvance();
      ɵɵclassProp("nb-form-field-control-with-prefix", ctx.shouldShowPrefix())("nb-form-field-control-with-suffix", ctx.shouldShowSuffix());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.shouldShowSuffix());
    }
  },
  dependencies: [NgClass, NgIf, AsyncPipe],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;align-items:center}[hidden][_nghost-%COMP%]{display:none}.nb-form-control-container[_ngcontent-%COMP%]{width:100%}"],
  changeDetection: 0
});
var NbFormFieldComponent = _NbFormFieldComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldComponent, [{
    type: Component,
    args: [{
      selector: "nb-form-field",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<div *ngIf="shouldShowPrefix()" [ngClass]="prefixClasses$ | async">\n  <ng-content select="[nbPrefix]"></ng-content>\n</div>\n\n<div class="nb-form-control-container"\n     [class.nb-form-field-control-with-prefix]="shouldShowPrefix()"\n     [class.nb-form-field-control-with-suffix]="shouldShowSuffix()">\n  <ng-content></ng-content>\n</div>\n\n<div *ngIf="shouldShowSuffix()" [ngClass]="suffixClasses$ | async">\n  <ng-content select="[nbSuffix]"></ng-content>\n</div>\n',
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;align-items:center}:host[hidden]{display:none}.nb-form-control-container{width:100%}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    prefix: [{
      type: ContentChildren,
      args: [NbPrefixDirective, {
        descendants: true
      }]
    }],
    suffix: [{
      type: ContentChildren,
      args: [NbSuffixDirective, {
        descendants: true
      }]
    }],
    formControl: [{
      type: ContentChild,
      args: [NbFormFieldControl, {
        static: false
      }]
    }],
    formControlConfig: [{
      type: ContentChild,
      args: [NbFormFieldControlConfig, {
        static: false
      }]
    }],
    formFieldClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbSelectWithAutocompleteComponent = class _NbSelectWithAutocompleteComponent {
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  /**
   * Adds `outline` styles
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Adds `filled` styles
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Adds `hero` styles
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  /**
   * Disables the select
   */
  get disabled() {
    return !!this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * A function to compare option value with selected value.
   * By default, values are compared with strict equality (`===`).
   */
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    if (typeof fn !== "function") {
      return;
    }
    this._compareWith = fn;
    if (this.selectionModel.length && this.canSelectValue()) {
      this.setSelection(this.selected);
    }
  }
  /**
   * Accepts selected item or array of selected items.
   * */
  set selected(value) {
    this.writeValue(value);
  }
  get selected() {
    return this.multiple ? this.selectionModel.map((o) => o.value) : this.selectionModel[0].value;
  }
  /**
   * Gives capability just write `multiple` over the element.
   * */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
    this.updatePositionStrategy();
    this.updateCurrentKeyManager();
  }
  /**
   * Experimental input.
   * Could be changed without any prior notice.
   * Use at your own risk.
   *
   * It replaces the button with input when the select is opened.
   * That replacement provides a very basic API to implement options filtering functionality.
   * Filtering itself isn't implemented inside select.
   * So it should be implemented by the user.
   */
  set withOptionsAutocomplete(value) {
    this._withOptionsAutocomplete = convertToBoolProperty(value);
    this.updatePositionStrategy();
    this.updateCurrentKeyManager();
    if (!value) {
      this.resetAutocompleteInput();
    }
  }
  get withOptionsAutocomplete() {
    return this._withOptionsAutocomplete;
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Determines is select opened.
   * */
  get isOpen() {
    return this.ref && this.ref.hasAttached();
  }
  get isOptionsAutocompleteAllowed() {
    return this.withOptionsAutocomplete;
  }
  get isOptionsAutocompleteInputShown() {
    return this.isOptionsAutocompleteAllowed && this.isOpen;
  }
  constructor(document2, overlay, hostRef, positionBuilder, triggerStrategyBuilder, cd, focusKeyManagerFactoryService, focusMonitor, renderer, zone, statusService, activeDescendantKeyManagerFactoryService) {
    this.document = document2;
    this.overlay = overlay;
    this.hostRef = hostRef;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cd = cd;
    this.focusKeyManagerFactoryService = focusKeyManagerFactoryService;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.activeDescendantKeyManagerFactoryService = activeDescendantKeyManagerFactoryService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "outline";
    this._fullWidth = false;
    this.placeholder = "";
    this._compareWith = (v1, v2) => v1 === v2;
    this._multiple = false;
    this.optionsOverlayOffset = 8;
    this.scrollStrategy = "block";
    this._withOptionsAutocomplete = false;
    this.selectedChange = new EventEmitter();
    this.selectOpen = new EventEmitter();
    this.selectClose = new EventEmitter();
    this.optionsAutocompleteInputChange = new EventEmitter();
    this.selectionModel = [];
    this.positionStrategy$ = new BehaviorSubject(void 0);
    this.overlayPosition = "";
    this.alive = true;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.size);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(this.disabled);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
    this.lastShownButtonWidth = void 0;
  }
  /**
   * Determines is select hidden.
   * */
  get isHidden() {
    return !this.isOpen;
  }
  /**
   * Returns width of the select button.
   * */
  get hostWidth() {
    if (this.isOptionsAutocompleteInputShown) {
      return this.optionsAutocompleteInput.nativeElement.getBoundingClientRect().width;
    }
    return this.button.nativeElement.getBoundingClientRect().width;
  }
  get selectButtonClasses() {
    const classes = [];
    if (!this.selectionModel.length) {
      classes.push("placeholder");
    }
    if (!this.selectionModel.length && !this.placeholder) {
      classes.push("empty");
    }
    if (this.isOpen) {
      classes.push(this.overlayPosition);
    }
    return classes;
  }
  /**
   * Content rendered in the label.
   * */
  get selectionView() {
    if (this.isOptionsAutocompleteInputShown && this.multiple) {
      return "";
    }
    if (this.selectionModel.length > 1) {
      return this.selectionModel.map((option) => option.content).join(", ");
    }
    return this.selectionModel[0]?.content?.trim() ?? "";
  }
  ngOnChanges({
    disabled,
    status,
    size,
    fullWidth
  }) {
    if (disabled) {
      this.disabled$.next(disabled.currentValue);
    }
    if (status) {
      this.status$.next(status.currentValue);
    }
    if (size) {
      this.size$.next(size.currentValue);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngAfterContentInit() {
    this.options.changes.pipe(
      startWith(this.options),
      filter(() => this.queue != null && this.canSelectValue()),
      // Call 'writeValue' when current change detection run is finished.
      // When writing is finished, change detection starts again, since
      // microtasks queue is empty.
      // Prevents ExpressionChangedAfterItHasBeenCheckedError.
      switchMap((options) => from(Promise.resolve(options))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.writeValue(this.queue));
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnButtonFocus();
    this.subscribeOnTriggers();
    this.subscribeOnOptionClick();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.alive = false;
    this.destroy$.next();
    this.destroy$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  onAutocompleteInputChange(event) {
    this.optionsAutocompleteInputChange.emit(event.target.value);
  }
  show() {
    if (this.shouldShow()) {
      this.lastShownButtonWidth = this.hostWidth;
      this.attachToOverlay();
      this.positionStrategy$.pipe(switchMap((positionStrategy) => positionStrategy.positionChange ?? EMPTY), take(1), takeUntil(this.destroy$)).subscribe(() => {
        if (this.isOptionsAutocompleteInputShown) {
          this.optionsAutocompleteInput.nativeElement.focus();
        }
        this.setActiveOption();
      });
      this.selectOpen.emit();
      this.cd.markForCheck();
    }
  }
  hide() {
    if (this.isOpen) {
      this.ref.detach();
      this.cd.markForCheck();
      this.selectClose.emit();
      this.resetAutocompleteInput();
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd.markForCheck();
  }
  writeValue(value) {
    if (!this.alive) {
      return;
    }
    if (this.canSelectValue()) {
      this.setSelection(value);
      if (this.selectionModel.length) {
        this.queue = null;
      }
    } else {
      this.queue = value;
    }
  }
  /**
   * Selects option or clear all selected options if value is null.
   * */
  handleOptionClick(option) {
    this.queue = null;
    if (option.value == null) {
      this.reset();
    } else {
      this.selectOption(option);
    }
    this.cd.markForCheck();
  }
  /**
   * Deselect all selected options.
   * */
  reset() {
    this.selectionModel.forEach((option) => option.deselect());
    this.selectionModel = [];
    this.hide();
    this.focusButton();
    this.emitSelected(this.multiple ? [] : null);
  }
  /**
   * Determines how to select option as multiple or single.
   * */
  selectOption(option) {
    if (this.multiple) {
      this.handleMultipleSelect(option);
    } else {
      this.handleSingleSelect(option);
    }
  }
  /**
   * Select single option.
   * */
  handleSingleSelect(option) {
    const selected = this.selectionModel.pop();
    if (selected && !this._compareWith(selected.value, option.value)) {
      selected.deselect();
    }
    this.selectionModel = [option];
    option.select();
    this.hide();
    this.focusButton();
    this.emitSelected(option.value);
  }
  /**
   * Select for multiple options.
   * */
  handleMultipleSelect(option) {
    if (option.selected) {
      this.selectionModel = this.selectionModel.filter((s) => !this._compareWith(s.value, option.value));
      option.deselect();
    } else {
      this.selectionModel.push(option);
      option.select();
    }
    this.emitSelected(this.selectionModel.map((opt) => opt.value));
  }
  attachToOverlay() {
    if (!this.ref) {
      this.createOverlay();
      this.subscribeOnPositionChange();
      this.createKeyManager();
      this.subscribeOnOverlayKeys();
      this.subscribeOnOptionsAutocompleteChange();
    }
    this.ref.attach(this.portal);
  }
  setActiveOption() {
    if (this.selectionModel.length && !this.selectionModel[0].hidden) {
      this.currentKeyManager?.setActiveItem(this.selectionModel[0]);
    } else {
      this.currentKeyManager?.setFirstItemActive();
    }
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.positionStrategy$.next(this.createPositionStrategy());
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy$.value,
      scrollStrategy,
      panelClass: this.optionsPanelClass
    });
  }
  createKeyManager() {
    this.activeDescendantKeyManager = this.activeDescendantKeyManagerFactoryService.create(this.options).skipPredicate((option) => {
      return this.isOptionHidden(option);
    });
    this.focusKeyManager = this.focusKeyManagerFactoryService.create(this.options).withTypeAhead(200).skipPredicate((option) => {
      return this.isOptionHidden(option);
    });
    this.updateCurrentKeyManager();
  }
  updateCurrentKeyManager() {
    this.currentKeyManager?.setActiveItem(-1);
    if (this.isOptionsAutocompleteAllowed) {
      this.currentKeyManager = this.activeDescendantKeyManager;
    } else {
      this.currentKeyManager = this.focusKeyManager;
    }
    this.setActiveOption();
  }
  resetAutocompleteInput() {
    if (this.optionsAutocompleteInput?.nativeElement) {
      this.optionsAutocompleteInput.nativeElement.value = this.selectionView;
      this.optionsAutocompleteInputChange.emit("");
    }
  }
  createPositionStrategy() {
    const element = this.isOptionsAutocompleteAllowed ? this.optionsAutocompleteInput : this.button;
    return this.positionBuilder.connectedTo(element).position(NbPosition.BOTTOM).offset(this.optionsOverlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  updatePositionStrategy() {
    if (this.ref) {
      this.positionStrategy$.next(this.createPositionStrategy());
      this.ref.updatePositionStrategy(this.positionStrategy$.value);
      if (this.isOpen) {
        this.ref.updatePosition();
      }
    }
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.CLICK).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(($event) => {
      this.hide();
      if (!this.isClickedWithinComponent($event)) {
        this.onTouched();
      }
    });
  }
  subscribeOnPositionChange() {
    this.positionStrategy$.pipe(switchMap((positionStrategy) => positionStrategy.positionChange ?? EMPTY), takeUntil(this.destroy$)).subscribe((position) => {
      this.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  subscribeOnOptionClick() {
    this.options.changes.pipe(startWith(this.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleOptionClick(clickedOption));
  }
  subscribeOnOverlayKeys() {
    this.ref.keydownEvents().pipe(filter(() => this.isOpen), takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE) {
        this.hide();
        this.focusButton();
      } else if (event.keyCode === ENTER && this.isOptionsAutocompleteInputShown) {
        event.preventDefault();
        const activeItem = this.currentKeyManager.activeItem;
        if (activeItem) {
          this.selectOption(activeItem);
        }
      } else {
        this.currentKeyManager.onKeydown(event);
      }
    });
    merge(this.focusKeyManager.tabOut.pipe(filter(() => !this.isOptionsAutocompleteInputShown)), this.activeDescendantKeyManager.tabOut.pipe(filter(() => this.isOptionsAutocompleteInputShown))).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.hide();
      this.onTouched();
    });
  }
  subscribeOnOptionsAutocompleteChange() {
    this.optionsAutocompleteInputChange.pipe(observeOn(animationFrameScheduler), filter(() => this.isOptionsAutocompleteInputShown), takeUntil(this.destroy$)).subscribe(() => {
      if (this.isOptionHidden(this.currentKeyManager.activeItem)) {
        this.currentKeyManager.setFirstItemActive();
      }
    });
  }
  subscribeOnButtonFocus() {
    const buttonFocus$ = this.focusMonitor.monitor(this.button).pipe(map((origin) => !!origin), startWith(false), finalize(() => this.focusMonitor.stopMonitoring(this.button)));
    const filterInputFocus$ = this.focusMonitor.monitor(this.optionsAutocompleteInput).pipe(map((origin) => !!origin), startWith(false), finalize(() => this.focusMonitor.stopMonitoring(this.button)));
    combineLatest([buttonFocus$, filterInputFocus$]).pipe(map(([buttonFocus, filterInputFocus]) => buttonFocus || filterInputFocus), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  getContainer() {
    return this.ref && this.ref.hasAttached() && {
      location: {
        nativeElement: this.ref.overlayElement
      }
    };
  }
  focusButton() {
    setTimeout(() => {
      this.button?.nativeElement?.focus();
    });
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.onChange(selected);
    this.selectedChange.emit(selected);
  }
  /**
   * Set selected value in model.
   * */
  setSelection(value) {
    const isResetValue = value == null;
    let safeValue = value;
    if (this.multiple) {
      safeValue = value ?? [];
    }
    const isArray = Array.isArray(safeValue);
    if (this.multiple && !isArray && !isResetValue) {
      throw new Error("Can't assign single value if select is marked as multiple");
    }
    if (!this.multiple && isArray) {
      throw new Error("Can't assign array if select is not marked as multiple");
    }
    const previouslySelectedOptions = this.selectionModel;
    this.selectionModel = [];
    if (this.multiple) {
      safeValue.forEach((option) => this.selectValue(option));
    } else {
      this.selectValue(safeValue);
    }
    previouslySelectedOptions.filter((option) => !this.selectionModel.includes(option)).forEach((option) => option.deselect());
    this.cd.markForCheck();
  }
  /**
   * Selects value.
   * */
  selectValue(value) {
    if (value == null) {
      return;
    }
    const corresponding = this.options.find((option) => this._compareWith(option.value, value));
    if (corresponding) {
      corresponding.select();
      this.selectionModel.push(corresponding);
    }
  }
  shouldShow() {
    return this.isHidden && this.options?.length > 0;
  }
  /**
   * Sets touched if focus moved outside of button and overlay,
   * ignoring the case when focus moved to options overlay.
   */
  trySetTouched() {
    if (this.isHidden) {
      this.onTouched();
    }
  }
  isClickedWithinComponent($event) {
    return this.hostRef.nativeElement === $event.target || this.hostRef.nativeElement.contains($event.target);
  }
  canSelectValue() {
    return !!(this.options && this.options.length);
  }
  isOptionHidden(option) {
    return option.hidden;
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
};
_NbSelectWithAutocompleteComponent.ɵfac = function NbSelectWithAutocompleteComponent_Factory(t) {
  return new (t || _NbSelectWithAutocompleteComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbFocusKeyManagerFactoryService), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService), ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService));
};
_NbSelectWithAutocompleteComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSelectWithAutocompleteComponent,
  selectors: [["nb-select-with-autocomplete"]],
  contentQueries: function NbSelectWithAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbSelectLabelComponent, 5);
      ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.customLabel = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  viewQuery: function NbSelectWithAutocompleteComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalDirective, 5);
      ɵɵviewQuery(_c40, 5, ElementRef);
      ɵɵviewQuery(_c47, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.button = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsAutocompleteInput = _t.first);
    }
  },
  hostVars: 42,
  hostBindings: function NbSelectWithAutocompleteComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("appearance-outline", ctx.outline)("appearance-filled", ctx.filled)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("open", ctx.isOpen)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    optionsListClass: "optionsListClass",
    optionsPanelClass: "optionsPanelClass",
    optionsWidth: "optionsWidth",
    outline: "outline",
    filled: "filled",
    hero: "hero",
    disabled: "disabled",
    fullWidth: "fullWidth",
    placeholder: "placeholder",
    compareWith: "compareWith",
    selected: "selected",
    multiple: "multiple",
    optionsOverlayOffset: "optionsOverlayOffset",
    scrollStrategy: "scrollStrategy",
    withOptionsAutocomplete: "withOptionsAutocomplete"
  },
  outputs: {
    selectedChange: "selectedChange",
    selectOpen: "selectOpen",
    selectClose: "selectClose",
    optionsAutocompleteInputChange: "optionsAutocompleteInputChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbSelectWithAutocompleteComponent),
    multi: true
  }, {
    provide: NB_SELECT_INJECTION_TOKEN,
    useExisting: _NbSelectWithAutocompleteComponent
  }, {
    provide: NbFormFieldControl,
    useExisting: _NbSelectWithAutocompleteComponent
  }, {
    provide: NbFormFieldControlConfig,
    useFactory: nbSelectFormFieldControlConfigFactory
  }]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c42,
  decls: 12,
  vars: 13,
  consts: [["selectButton", ""], ["placeholderTemplate", ""], ["optionsAutocompleteInput", ""], ["defaultSelectionTemplate", ""], ["type", "button", 1, "select-button", 3, "blur", "keydown.arrowDown", "keydown.arrowUp", "hidden", "disabled", "ngClass"], [3, "click"], [4, "ngIf", "ngIfElse"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"], [3, "hidden"], ["nbInput", "", "fullWidth", "", 3, "blur", "click", "dblclick", "input", "value", "placeholder", "status", "shape", "fieldSize"], ["nbSuffix", "", "icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true"], [3, "size", "position", "width", "ngClass", 4, "nbPortal"], [3, "size", "position", "ngClass"]],
  template: function NbSelectWithAutocompleteComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c41);
      ɵɵelementStart(0, "button", 4, 0);
      ɵɵlistener("blur", function NbSelectWithAutocompleteComponent_Template_button_blur_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.trySetTouched());
      })("keydown.arrowDown", function NbSelectWithAutocompleteComponent_Template_button_keydown_arrowDown_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.show());
      })("keydown.arrowUp", function NbSelectWithAutocompleteComponent_Template_button_keydown_arrowUp_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.show());
      });
      ɵɵelementStart(2, "span", 5);
      ɵɵlistener("click", function NbSelectWithAutocompleteComponent_Template_span_click_2_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.disabled && $event.stopPropagation());
      });
      ɵɵtemplate(3, NbSelectWithAutocompleteComponent_ng_container_3_Template, 4, 2, "ng-container", 6)(4, NbSelectWithAutocompleteComponent_ng_template_4_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
      ɵɵelementStart(6, "nb-icon", 7);
      ɵɵlistener("click", function NbSelectWithAutocompleteComponent_Template_nb_icon_click_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.disabled && $event.stopPropagation());
      });
      ɵɵelementEnd()();
      ɵɵelementStart(7, "nb-form-field", 8)(8, "input", 9, 2);
      ɵɵlistener("blur", function NbSelectWithAutocompleteComponent_Template_input_blur_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.trySetTouched());
      })("click", function NbSelectWithAutocompleteComponent_Template_input_click_8_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView($event.stopPropagation());
      })("dblclick", function NbSelectWithAutocompleteComponent_Template_input_dblclick_8_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView($event.stopPropagation());
      })("input", function NbSelectWithAutocompleteComponent_Template_input_input_8_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onAutocompleteInputChange($event));
      });
      ɵɵelementEnd();
      ɵɵelement(10, "nb-icon", 10);
      ɵɵelementEnd();
      ɵɵtemplate(11, NbSelectWithAutocompleteComponent_nb_option_list_11_Template, 2, 5, "nb-option-list", 11);
    }
    if (rf & 2) {
      const placeholderTemplate_r4 = ɵɵreference(5);
      ɵɵproperty("hidden", ctx.isOptionsAutocompleteInputShown)("disabled", ctx.disabled)("ngClass", ctx.selectButtonClasses);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.selectionModel.length)("ngIfElse", placeholderTemplate_r4);
      ɵɵadvance(4);
      ɵɵproperty("hidden", !ctx.isOptionsAutocompleteInputShown);
      ɵɵadvance();
      ɵɵstyleProp("max-width", ctx.lastShownButtonWidth, "px");
      ɵɵproperty("value", ctx.selectionView)("placeholder", ctx.placeholder)("status", ctx.status)("shape", ctx.shape)("fieldSize", ctx.size);
    }
  },
  dependencies: [NgClass, NgIf, NbPortalDirective, NbInputDirective, NbIconComponent, NbOptionListComponent, NbFormFieldComponent, NbSuffixDirective],
  styles: ["\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]{display:inline-block;max-width:100%}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:left}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.2em}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:right}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.2em}.full-width[_nghost-%COMP%]{width:100%}.nb-transition[_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button[_ngcontent-%COMP%], nb-form-field[_ngcontent-%COMP%]{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){right:.5rem}[dir=rtl][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){left:.5rem}.open[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){transform:translateY(-50%) rotate(180deg)}"],
  changeDetection: 0
});
var NbSelectWithAutocompleteComponent = _NbSelectWithAutocompleteComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectWithAutocompleteComponent, [{
    type: Component,
    args: [{
      selector: "nb-select-with-autocomplete",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbSelectWithAutocompleteComponent),
        multi: true
      }, {
        provide: NB_SELECT_INJECTION_TOKEN,
        useExisting: NbSelectWithAutocompleteComponent
      }, {
        provide: NbFormFieldControl,
        useExisting: NbSelectWithAutocompleteComponent
      }, {
        provide: NbFormFieldControlConfig,
        useFactory: nbSelectFormFieldControlConfigFactory
      }],
      template: '<button\n  [hidden]="isOptionsAutocompleteInputShown"\n  [disabled]="disabled"\n  [ngClass]="selectButtonClasses"\n  (blur)="trySetTouched()"\n  (keydown.arrowDown)="show()"\n  (keydown.arrowUp)="show()"\n  class="select-button"\n  type="button"\n  #selectButton\n>\n  <span (click)="disabled && $event.stopPropagation()">\n    <ng-container *ngIf="selectionModel.length; else placeholderTemplate">\n      <ng-container *ngIf="customLabel; else defaultSelectionTemplate">\n        <ng-content select="nb-select-label"></ng-content>\n      </ng-container>\n\n      <ng-template #defaultSelectionTemplate>{{ selectionView }}</ng-template>\n    </ng-container>\n\n    <ng-template #placeholderTemplate>{{ placeholder }}</ng-template>\n  </span>\n\n  <nb-icon\n    icon="chevron-down-outline"\n    pack="nebular-essentials"\n    (click)="disabled && $event.stopPropagation()"\n    aria-hidden="true"\n  >\n  </nb-icon>\n</button>\n\n<nb-form-field [hidden]="!isOptionsAutocompleteInputShown">\n  <input\n    nbInput\n    fullWidth\n    [style.max-width.px]="lastShownButtonWidth"\n    #optionsAutocompleteInput\n    [value]="selectionView"\n    [placeholder]="placeholder"\n    [status]="status"\n    [shape]="shape"\n    [fieldSize]="size"\n    (blur)="trySetTouched()"\n    (click)="$event.stopPropagation()"\n    (dblclick)="$event.stopPropagation()"\n    (input)="onAutocompleteInputChange($event)"\n  />\n  <nb-icon nbSuffix icon="chevron-up-outline" pack="nebular-essentials" aria-hidden="true"> </nb-icon>\n</nb-form-field>\n\n<nb-option-list\n  *nbPortal\n  [size]="size"\n  [position]="overlayPosition"\n  [style.width.px]="optionsWidth"\n  [ngClass]="optionsListClass"\n>\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: ["/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:inline-block;max-width:100%}[dir=ltr] :host .select-button{text-align:left}[dir=ltr] :host .select-button nb-icon{right:.2em}[dir=rtl] :host .select-button{text-align:right}[dir=rtl] :host .select-button nb-icon{left:.2em}:host(.full-width){width:100%}:host(.nb-transition) .select-button{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button,nb-form-field{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon:not([nbSuffix]){font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr] nb-icon:not([nbSuffix]){right:.5rem}[dir=rtl] nb-icon:not([nbSuffix]){left:.5rem}:host(.open) nb-icon:not([nbSuffix]){transform:translateY(-50%) rotate(180deg)}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbOverlayService
  }, {
    type: ElementRef
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbFocusKeyManagerFactoryService
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    disabled: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    placeholder: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    optionsOverlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    withOptionsAutocomplete: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    selectedChange: [{
      type: Output
    }],
    selectOpen: [{
      type: Output
    }],
    selectClose: [{
      type: Output
    }],
    optionsAutocompleteInputChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    customLabel: [{
      type: ContentChild,
      args: [NbSelectLabelComponent]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    button: [{
      type: ViewChild,
      args: ["selectButton", {
        read: ElementRef
      }]
    }],
    optionsAutocompleteInput: [{
      type: ViewChild,
      args: ["optionsAutocompleteInput", {
        read: ElementRef
      }]
    }],
    isOpen: [{
      type: HostBinding,
      args: ["class.open"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }]
  });
})();
var COMPONENTS$1 = [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective];
var _NbFormFieldModule = class _NbFormFieldModule {
};
_NbFormFieldModule.ɵfac = function NbFormFieldModule_Factory(t) {
  return new (t || _NbFormFieldModule)();
};
_NbFormFieldModule.ɵmod = ɵɵdefineNgModule({
  type: _NbFormFieldModule,
  declarations: [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective],
  imports: [CommonModule],
  exports: [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective]
});
_NbFormFieldModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
var NbFormFieldModule = _NbFormFieldModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [...COMPONENTS$1],
      exports: [...COMPONENTS$1]
    }]
  }], null, null);
})();
var NB_SELECT_COMPONENTS = [NbSelectWithAutocompleteComponent];
var _NbSelectWithAutocompleteModule = class _NbSelectWithAutocompleteModule {
};
_NbSelectWithAutocompleteModule.ɵfac = function NbSelectWithAutocompleteModule_Factory(t) {
  return new (t || _NbSelectWithAutocompleteModule)();
};
_NbSelectWithAutocompleteModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSelectWithAutocompleteModule,
  declarations: [NbSelectWithAutocompleteComponent],
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule],
  exports: [NbSelectWithAutocompleteComponent, NbOptionModule, NbSelectModule]
});
_NbSelectWithAutocompleteModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule, NbOptionModule, NbSelectModule]
});
var NbSelectWithAutocompleteModule = _NbSelectWithAutocompleteModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectWithAutocompleteModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule],
      exports: [...NB_SELECT_COMPONENTS, NbOptionModule, NbSelectModule],
      declarations: [...NB_SELECT_COMPONENTS]
    }]
  }], null, null);
})();
var lastAutocompleteId = 0;
var _NbAutocompleteComponent = class _NbAutocompleteComponent {
  get overlayPosition() {
    return this._overlayPosition;
  }
  set overlayPosition(value) {
    this._overlayPosition = value;
    this.cd.detectChanges();
  }
  /**
   * Returns width of the input.
   * */
  get hostWidth() {
    return this.hostRef.nativeElement.getBoundingClientRect().width;
  }
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  constructor(cd) {
    this.cd = cd;
    this.destroy$ = new Subject();
    this.id = `nb-autocomplete-${lastAutocompleteId++}`;
    this._overlayPosition = "";
    this.size = "medium";
    this.activeFirst = false;
    this.selectedChange = new EventEmitter();
  }
  ngAfterContentInit() {
    this.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Autocomplete knows nothing about host html input element.
   * So, attach method set input hostRef for styling.
   * */
  setHost(hostRef) {
    this.hostRef = hostRef;
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.selectedChange.emit(selected);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
};
_NbAutocompleteComponent.ɵfac = function NbAutocompleteComponent_Factory(t) {
  return new (t || _NbAutocompleteComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbAutocompleteComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAutocompleteComponent,
  selectors: [["nb-autocomplete"]],
  contentQueries: function NbAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  viewQuery: function NbAutocompleteComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
    }
  },
  hostVars: 10,
  hostBindings: function NbAutocompleteComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    }
  },
  inputs: {
    handleDisplayFn: "handleDisplayFn",
    size: "size",
    activeFirst: "activeFirst",
    optionsListClass: "optionsListClass",
    optionsPanelClass: "optionsPanelClass",
    optionsWidth: "optionsWidth"
  },
  outputs: {
    selectedChange: "selectedChange"
  },
  ngContentSelectors: _c49,
  decls: 1,
  vars: 0,
  consts: [["role", "listbox", 3, "size", "position", "width", "id", "empty", "ngClass", 4, "nbPortal"], ["role", "listbox", 3, "size", "position", "id", "ngClass"]],
  template: function NbAutocompleteComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c48);
      ɵɵtemplate(0, NbAutocompleteComponent_nb_option_list_0_Template, 2, 8, "nb-option-list", 0);
    }
  },
  dependencies: [NgClass, NbPortalDirective, NbOptionListComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]:hover{cursor:pointer}nb-option-list.empty[_ngcontent-%COMP%]{border:none}"],
  changeDetection: 0
});
var NbAutocompleteComponent = _NbAutocompleteComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteComponent, [{
    type: Component,
    args: [{
      selector: "nb-autocomplete",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<nb-option-list *nbPortal\n                [size]="size"\n                [position]="overlayPosition"\n                [style.width.px]="optionsWidth"\n                role="listbox"\n                [id]="id"\n                [class.empty]="!options?.length"\n                [ngClass]="optionsListClass">\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: ["/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host(:hover){cursor:pointer}nb-option-list.empty{border:none}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    handleDisplayFn: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    activeFirst: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    selectedChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var _NbAutocompleteDirective = class _NbAutocompleteDirective {
  /**
   * Determines is autocomplete overlay opened.
   * */
  get isOpen() {
    return this.overlayRef && this.overlayRef.hasAttached();
  }
  /**
   * Determines is autocomplete overlay closed.
   * */
  get isClosed() {
    return !this.isOpen;
  }
  /**
   * Provides autocomplete component.
   * */
  get autocomplete() {
    return this._autocomplete;
  }
  set autocomplete(autocomplete) {
    this._autocomplete = autocomplete;
  }
  get top() {
    return this.isOpen && this.autocomplete.options.length && this.autocomplete.overlayPosition === NbPosition.TOP;
  }
  get bottom() {
    return this.isOpen && this.autocomplete.options.length && this.autocomplete.overlayPosition === NbPosition.BOTTOM;
  }
  get ariaExpanded() {
    return this.isOpen && this.isOpen.toString();
  }
  get ariaOwns() {
    return this.isOpen ? this.autocomplete.id : null;
  }
  get ariaActiveDescendant() {
    return this.isOpen && this.keyManager.activeItem ? this.keyManager.activeItem.id : null;
  }
  constructor(hostRef, overlay, cd, triggerStrategyBuilder, positionBuilder, activeDescendantKeyManagerFactory, renderer) {
    this.hostRef = hostRef;
    this.overlay = overlay;
    this.cd = cd;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.positionBuilder = positionBuilder;
    this.activeDescendantKeyManagerFactory = activeDescendantKeyManagerFactory;
    this.renderer = renderer;
    this.destroy$ = new Subject();
    this._onChange = () => {
    };
    this._onTouched = () => {
    };
    this.overlayOffset = 8;
    this.scrollStrategy = "block";
    this.role = "combobox";
    this.ariaAutocomplete = "list";
    this.hasPopup = "true";
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnTriggers();
  }
  ngOnDestroy() {
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
    if (this.positionStrategy) {
      this.positionStrategy.dispose();
    }
    if (this.overlayRef) {
      this.overlayRef.dispose();
    }
    this.destroy$.next();
    this.destroy$.complete();
  }
  handleInput() {
    const currentValue = this.hostRef.nativeElement.value;
    this._onChange(currentValue);
    this.setHostInputValue(this.getDisplayValue(currentValue));
    this.show();
  }
  handleKeydown() {
    this.show();
  }
  handleBlur() {
    this._onTouched();
  }
  show() {
    if (this.shouldShow()) {
      this.attachToOverlay();
      this.setActiveItem();
    }
  }
  hide() {
    if (this.isOpen) {
      this.overlayRef.detach();
      this.cd.markForCheck();
    }
  }
  writeValue(value) {
    this.handleInputValueUpdate(value);
  }
  registerOnChange(fn) {
    this._onChange = fn;
  }
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  setDisabledState(disabled) {
    this.renderer.setProperty(this.hostRef.nativeElement, "disabled", disabled);
  }
  subscribeOnOptionClick() {
    this.autocomplete.options.changes.pipe(tap(() => this.setActiveItem()), startWith(this.autocomplete.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleInputValueUpdate(clickedOption.value, true));
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => {
      this.autocomplete.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  getActiveItem() {
    return this.keyManager.activeItem;
  }
  setupAutocomplete() {
    this.autocomplete.setHost(this.customOverlayHost || this.hostRef);
  }
  getDisplayValue(value) {
    const displayFn = this.autocomplete.handleDisplayFn;
    return displayFn ? displayFn(value) : value;
  }
  getContainer() {
    return this.overlayRef && this.isOpen && {
      location: {
        nativeElement: this.overlayRef.overlayElement
      }
    };
  }
  handleInputValueUpdate(value, focusInput = false) {
    this.setHostInputValue(value ?? "");
    this._onChange(value);
    if (focusInput) {
      this.hostRef.nativeElement.focus();
    }
    this.autocomplete.emitSelected(value);
    this.hide();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.pipe(filter(() => this.isClosed)).subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(() => this.hide());
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  createKeyManager() {
    this.keyManager = this.activeDescendantKeyManagerFactory.create(this.autocomplete.options);
  }
  setHostInputValue(value) {
    this.hostRef.nativeElement.value = this.getDisplayValue(value);
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.customOverlayHost || this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  subscribeOnOverlayKeys() {
    this.overlayRef.keydownEvents().pipe(takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE && this.isOpen) {
        event.preventDefault();
        this.hostRef.nativeElement.focus();
        this.hide();
      } else if (event.keyCode === ENTER) {
        event.preventDefault();
        const activeItem = this.getActiveItem();
        if (!activeItem) {
          return;
        }
        this.handleInputValueUpdate(activeItem.value, true);
      } else {
        this.keyManager.onKeydown(event);
      }
    });
  }
  setActiveItem() {
    const mode = this.autocomplete.activeFirst ? NbKeyManagerActiveItemMode.FIRST_ACTIVE : NbKeyManagerActiveItemMode.RESET_ACTIVE;
    this.keyManager.setActiveItem(mode);
    this.cd.detectChanges();
  }
  attachToOverlay() {
    if (!this.overlayRef) {
      this.setupAutocomplete();
      this.initOverlay();
    }
    this.overlayRef.attach(this.autocomplete.portal);
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.overlayRef = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy,
      panelClass: this.autocomplete.optionsPanelClass
    });
  }
  initOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.createKeyManager();
    this.subscribeOnPositionChange();
    this.subscribeOnOptionClick();
    this.checkOverlayVisibility();
    this.createOverlay();
    this.subscribeOnOverlayKeys();
  }
  checkOverlayVisibility() {
    this.autocomplete.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
      if (!this.autocomplete.options.length) {
        this.hide();
      }
    });
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  shouldShow() {
    return this.isClosed;
  }
};
_NbAutocompleteDirective.ɵfac = function NbAutocompleteDirective_Factory(t) {
  return new (t || _NbAutocompleteDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService), ɵɵdirectiveInject(Renderer2));
};
_NbAutocompleteDirective.ɵdir = ɵɵdefineDirective({
  type: _NbAutocompleteDirective,
  selectors: [["input", "nbAutocomplete", ""]],
  hostVars: 10,
  hostBindings: function NbAutocompleteDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("input", function NbAutocompleteDirective_input_HostBindingHandler() {
        return ctx.handleInput();
      })("keydown.arrowDown", function NbAutocompleteDirective_keydown_arrowDown_HostBindingHandler() {
        return ctx.handleKeydown();
      })("keydown.arrowUp", function NbAutocompleteDirective_keydown_arrowUp_HostBindingHandler() {
        return ctx.handleKeydown();
      })("blur", function NbAutocompleteDirective_blur_HostBindingHandler() {
        return ctx.handleBlur();
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", ctx.role)("aria-autocomplete", ctx.ariaAutocomplete)("haspopup", ctx.hasPopup)("aria-expanded", ctx.ariaExpanded)("aria-owns", ctx.ariaOwns)("aria-activedescendant", ctx.ariaActiveDescendant);
      ɵɵclassProp("nb-autocomplete-position-top", ctx.top)("nb-autocomplete-position-bottom", ctx.bottom);
    }
  },
  inputs: {
    autocomplete: [InputFlags.None, "nbAutocomplete", "autocomplete"],
    overlayOffset: "overlayOffset",
    scrollStrategy: "scrollStrategy",
    customOverlayHost: "customOverlayHost"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbAutocompleteDirective),
    multi: true
  }])]
});
var NbAutocompleteDirective = _NbAutocompleteDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbAutocomplete]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbAutocompleteDirective),
        multi: true
      }]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }, {
    type: Renderer2
  }], {
    autocomplete: [{
      type: Input,
      args: ["nbAutocomplete"]
    }],
    overlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    customOverlayHost: [{
      type: Input
    }],
    top: [{
      type: HostBinding,
      args: ["class.nb-autocomplete-position-top"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.nb-autocomplete-position-bottom"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaAutocomplete: [{
      type: HostBinding,
      args: ["attr.aria-autocomplete"]
    }],
    hasPopup: [{
      type: HostBinding,
      args: ["attr.haspopup"]
    }],
    ariaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    ariaOwns: [{
      type: HostBinding,
      args: ["attr.aria-owns"]
    }],
    ariaActiveDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    handleInput: [{
      type: HostListener,
      args: ["input"]
    }],
    handleKeydown: [{
      type: HostListener,
      args: ["keydown.arrowDown"]
    }, {
      type: HostListener,
      args: ["keydown.arrowUp"]
    }],
    handleBlur: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var NB_AUTOCOMPLETE_COMPONENTS = [NbAutocompleteComponent, NbAutocompleteDirective];
var _NbAutocompleteModule = class _NbAutocompleteModule {
};
_NbAutocompleteModule.ɵfac = function NbAutocompleteModule_Factory(t) {
  return new (t || _NbAutocompleteModule)();
};
_NbAutocompleteModule.ɵmod = ɵɵdefineNgModule({
  type: _NbAutocompleteModule,
  declarations: [NbAutocompleteComponent, NbAutocompleteDirective],
  imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule],
  exports: [NbAutocompleteComponent, NbAutocompleteDirective, NbOptionModule]
});
_NbAutocompleteModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule, NbOptionModule]
});
var NbAutocompleteModule = _NbAutocompleteModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule],
      exports: [...NB_AUTOCOMPLETE_COMPONENTS, NbOptionModule],
      declarations: [...NB_AUTOCOMPLETE_COMPONENTS]
    }]
  }], null, null);
})();
var NbWindowState;
(function(NbWindowState2) {
  NbWindowState2["MINIMIZED"] = "minimized";
  NbWindowState2["MAXIMIZED"] = "maximized";
  NbWindowState2["FULL_SCREEN"] = "full-screen";
})(NbWindowState || (NbWindowState = {}));
var NB_WINDOW_DEFAULT_BUTTONS_CONFIG = {
  minimize: true,
  maximize: true,
  fullScreen: true,
  close: true
};
var NbWindowConfig = class {
  constructor(...configs) {
    this.title = "";
    this.titleTemplateContext = {};
    this.initialState = NbWindowState.FULL_SCREEN;
    this.hasBackdrop = true;
    this.closeOnBackdropClick = true;
    this.closeOnEsc = true;
    this.windowClass = "";
    this.context = {};
    this.viewContainerRef = null;
    this.buttons = {};
    Object.assign(this, ...configs);
    this.applyDefaultButtonConfig();
  }
  applyDefaultButtonConfig() {
    Object.assign(this, {
      buttons: __spreadValues(__spreadValues({}, NB_WINDOW_DEFAULT_BUTTONS_CONFIG), this.buttons)
    });
  }
};
var NB_WINDOW_CONTENT = new InjectionToken("Nebular Window Content");
var NB_WINDOW_CONFIG = new InjectionToken("Nebular Window Config");
var NB_WINDOW_CONTEXT = new InjectionToken("Nebular Window Context");
var NbWindowRef = class {
  /**
   * Current window state.
   */
  get state() {
    return this.stateValue;
  }
  set state(newState) {
    if (newState && this.stateValue !== newState) {
      this.prevStateValue = this.state;
      this.stateValue = newState;
      this.stateChange$.next({
        oldState: this.prevStateValue,
        newState
      });
    }
  }
  /**
   * Emits when window state change.
   */
  get stateChange() {
    return this.stateChange$.asObservable();
  }
  /**
   * Emits when window was closed.
   */
  get onClose() {
    return this.closed$.asObservable();
  }
  constructor(config) {
    this.config = config;
    this.stateChange$ = new ReplaySubject(1);
    this._closed = false;
    this.closed$ = new Subject();
    this.state = config.initialState;
  }
  /**
   * Minimize window.
   */
  minimize() {
    this.state = NbWindowState.MINIMIZED;
  }
  /**
   * Maximize window.
   */
  maximize() {
    this.state = NbWindowState.MAXIMIZED;
  }
  /**
   * Set window on top.
   */
  fullScreen() {
    this.state = NbWindowState.FULL_SCREEN;
  }
  toPreviousState() {
    this.state = this.prevStateValue;
  }
  /**
   * Closes window.
   * */
  close(res) {
    if (this._closed) {
      return;
    }
    this._closed = true;
    this.componentRef.destroy();
    this.componentInstance = null;
    this.stateChange$.complete();
    this.closed$.next(res);
    this.closed$.complete();
  }
};
var _NbWindowsContainerComponent = class _NbWindowsContainerComponent {
};
_NbWindowsContainerComponent.ɵfac = function NbWindowsContainerComponent_Factory(t) {
  return new (t || _NbWindowsContainerComponent)();
};
_NbWindowsContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbWindowsContainerComponent,
  selectors: [["nb-windows-container"]],
  viewQuery: function NbWindowsContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c50, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);
    }
  },
  decls: 2,
  vars: 0,
  consts: [["viewContainerRef", ""]],
  template: function NbWindowsContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, null, 0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;align-items:flex-end;overflow-x:auto}[_nghost-%COMP%]     nb-window:not(.full-screen){margin:0 2rem}"]
});
var NbWindowsContainerComponent = _NbWindowsContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowsContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-windows-container",
      template: `<ng-container #viewContainerRef></ng-container>`,
      styles: [":host{display:flex;align-items:flex-end;overflow-x:auto}:host ::ng-deep nb-window:not(.full-screen){margin:0 2rem}\n"]
    }]
  }], null, {
    viewContainerRef: [{
      type: ViewChild,
      args: ["viewContainerRef", {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var _NbWindowComponent = class _NbWindowComponent {
  get isFullScreen() {
    return this.windowRef.state === NbWindowState.FULL_SCREEN;
  }
  get maximized() {
    return this.windowRef.state === NbWindowState.MAXIMIZED;
  }
  get minimized() {
    return this.windowRef.state === NbWindowState.MINIMIZED;
  }
  get showMinimize() {
    return this.config.buttons.minimize;
  }
  get showMaximize() {
    return this.config.buttons.maximize;
  }
  get showFullScreen() {
    return this.config.buttons.fullScreen;
  }
  get showClose() {
    return this.config.buttons.close;
  }
  constructor(content, context, windowRef, config, focusTrapFactory, elementRef, renderer) {
    this.content = content;
    this.context = context;
    this.windowRef = windowRef;
    this.config = config;
    this.focusTrapFactory = focusTrapFactory;
    this.elementRef = elementRef;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
    this.focusTrap.blurPreviouslyFocusedElement();
    this.focusTrap.focusInitialElement();
    if (this.config.windowClass) {
      this.renderer.addClass(this.elementRef.nativeElement, this.config.windowClass);
    }
  }
  ngAfterViewChecked() {
    if (!this.overlayContainer || this.overlayContainer.isAttached) {
      return;
    }
    if (this.content instanceof TemplateRef) {
      this.attachTemplate();
    } else {
      this.attachComponent();
    }
  }
  ngOnDestroy() {
    if (this.focusTrap) {
      this.focusTrap.restoreFocus();
    }
    this.close();
  }
  minimize() {
    if (this.windowRef.state === NbWindowState.MINIMIZED) {
      this.windowRef.toPreviousState();
    } else {
      this.windowRef.minimize();
    }
  }
  maximize() {
    this.windowRef.maximize();
  }
  fullScreen() {
    this.windowRef.fullScreen();
  }
  maximizeOrFullScreen() {
    if (this.windowRef.state === NbWindowState.MINIMIZED && this.showMaximize) {
      this.maximize();
    } else {
      this.fullScreen();
    }
  }
  close() {
    this.windowRef.close();
  }
  attachTemplate() {
    this.overlayContainer.attachTemplatePortal(new NbTemplatePortal(this.content, null, this.context));
  }
  attachComponent() {
    const portal = new NbComponentPortal(this.content, null, null, this.cfr);
    const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
    this.windowRef.componentInstance = ref.instance;
    ref.changeDetectorRef.detectChanges();
  }
};
_NbWindowComponent.ɵfac = function NbWindowComponent_Factory(t) {
  return new (t || _NbWindowComponent)(ɵɵdirectiveInject(NB_WINDOW_CONTENT), ɵɵdirectiveInject(NB_WINDOW_CONTEXT), ɵɵdirectiveInject(NbWindowRef), ɵɵdirectiveInject(NbWindowConfig), ɵɵdirectiveInject(NbFocusTrapFactoryService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
_NbWindowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbWindowComponent,
  selectors: [["nb-window"]],
  viewQuery: function NbWindowComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbOverlayContainerComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function NbWindowComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("full-screen", ctx.isFullScreen)("maximized", ctx.maximized)("minimized", ctx.minimized);
    }
  },
  inputs: {
    cfr: "cfr"
  },
  decls: 11,
  vars: 7,
  consts: [["textTitleTemplate", ""], ["cdkFocusInitial", "", "tabindex", "-1", 4, "ngIf", "ngIfElse"], [1, "buttons"], [4, "ngIf"], ["cdkFocusInitial", "", "tabindex", "-1"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["cdkFocusInitial", "", "tabindex", "-1", 1, "title"], ["nbButton", "", "ghost", "", 3, "click"], ["icon", "minus-outline", "pack", "nebular-essentials"], ["nbButton", "", "ghost", "", 3, "click", 4, "ngIf"], ["icon", "collapse-outline", "pack", "nebular-essentials"], ["icon", "expand-outline", "pack", "nebular-essentials"], ["icon", "close-outline", "pack", "nebular-essentials"]],
  template: function NbWindowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-card")(1, "nb-card-header");
      ɵɵtemplate(2, NbWindowComponent_div_2_Template, 2, 4, "div", 1)(3, NbWindowComponent_ng_template_3_Template, 2, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      ɵɵelementStart(5, "div", 2);
      ɵɵtemplate(6, NbWindowComponent_ng_container_6_Template, 3, 0, "ng-container", 3)(7, NbWindowComponent_ng_container_7_Template, 2, 1, "ng-container", 3)(8, NbWindowComponent_ng_container_8_Template, 2, 1, "ng-container", 3)(9, NbWindowComponent_ng_container_9_Template, 3, 0, "ng-container", 3);
      ɵɵelementEnd()();
      ɵɵtemplate(10, NbWindowComponent_nb_card_body_10_Template, 2, 0, "nb-card-body", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const textTitleTemplate_r6 = ɵɵreference(4);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.config.titleTemplate)("ngIfElse", textTitleTemplate_r6);
      ɵɵadvance(4);
      ɵɵproperty("ngIf", ctx.showMinimize);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showMaximize);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showFullScreen);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showClose);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.maximized || ctx.isFullScreen);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NbOverlayContainerComponent, NbCardComponent, NbCardBodyComponent, NbCardHeaderComponent, NbIconComponent, NbButtonComponent],
  styles: ["[_nghost-%COMP%]{flex:1 0 auto;min-width:20rem}[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{margin:0}[_nghost-%COMP%]   nb-card-header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;overflow:hidden}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]{width:9.5rem;display:flex;justify-content:flex-end}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]   [nbButton][_ngcontent-%COMP%]{flex:0 0 3rem}.full-screen[_nghost-%COMP%]{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}.maximized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]   nb-card-header[_ngcontent-%COMP%]{border-bottom:none}"]
});
var NbWindowComponent = _NbWindowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowComponent, [{
    type: Component,
    args: [{
      selector: "nb-window",
      template: `
    <nb-card>
      <nb-card-header>
        <div *ngIf="config.titleTemplate; else textTitleTemplate" cdkFocusInitial tabindex="-1">
          <ng-container
            *ngTemplateOutlet="config.titleTemplate; context: { $implicit: config.titleTemplateContext }"
          ></ng-container>
        </div>

        <ng-template #textTitleTemplate>
          <div cdkFocusInitial class="title" tabindex="-1">{{ config.title }}</div>
        </ng-template>

        <div class="buttons">
          <ng-container *ngIf="showMinimize">
            <button nbButton ghost (click)="minimize()">
              <nb-icon icon="minus-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showMaximize">
            <button nbButton ghost *ngIf="isFullScreen" (click)="maximize()">
              <nb-icon icon="collapse-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showFullScreen">
            <button nbButton ghost *ngIf="minimized || maximized" (click)="maximizeOrFullScreen()">
              <nb-icon icon="expand-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showClose">
            <button nbButton ghost (click)="close()">
              <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>
        </div>
      </nb-card-header>
      <nb-card-body *ngIf="maximized || isFullScreen">
        <nb-overlay-container></nb-overlay-container>
      </nb-card-body>
    </nb-card>
  `,
      styles: [":host{flex:1 0 auto;min-width:20rem}:host nb-card{margin:0}:host nb-card-header{display:flex;justify-content:space-between;align-items:center;overflow:hidden}:host .title{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .buttons{width:9.5rem;display:flex;justify-content:flex-end}:host .buttons [nbButton]{flex:0 0 3rem}:host(.full-screen){position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}:host(.maximized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0}:host(.minimized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}:host(.minimized) nb-card nb-card-header{border-bottom:none}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONTENT]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONTEXT]
    }]
  }, {
    type: NbWindowRef
  }, {
    type: NbWindowConfig
  }, {
    type: NbFocusTrapFactoryService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    cfr: [{
      type: Input
    }],
    isFullScreen: [{
      type: HostBinding,
      args: ["class.full-screen"]
    }],
    maximized: [{
      type: HostBinding,
      args: ["class.maximized"]
    }],
    minimized: [{
      type: HostBinding,
      args: ["class.minimized"]
    }],
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent]
    }]
  });
})();
var _NbWindowService = class _NbWindowService {
  constructor(componentFactoryResolver, overlayService, overlayPositionBuilder, blockScrollStrategy, defaultWindowsConfig, cfr, document2) {
    this.componentFactoryResolver = componentFactoryResolver;
    this.overlayService = overlayService;
    this.overlayPositionBuilder = overlayPositionBuilder;
    this.blockScrollStrategy = blockScrollStrategy;
    this.defaultWindowsConfig = defaultWindowsConfig;
    this.cfr = cfr;
    this.openWindows = [];
    this.document = document2;
  }
  /**
   * Opens new window.
   * @param windowContent
   * @param windowConfig
   * */
  open(windowContent, windowConfig = {}) {
    if (this.shouldCreateWindowsContainer()) {
      this.createWindowsContainer();
    }
    const config = new NbWindowConfig(this.defaultWindowsConfig, windowConfig);
    const windowRef = new NbWindowRef(config);
    windowRef.componentRef = this.appendWindow(windowContent, config, windowRef);
    this.openWindows.push(windowRef);
    this.subscribeToEvents(windowRef);
    return windowRef;
  }
  shouldCreateWindowsContainer() {
    if (this.windowsContainerViewRef) {
      const containerEl = this.windowsContainerViewRef.element.nativeElement;
      return !this.document.body.contains(containerEl);
    }
    return true;
  }
  createWindowsContainer() {
    if (this.overlayRef) {
      this.overlayRef.dispose();
    }
    this.overlayRef = this.overlayService.create({
      scrollStrategy: this.overlayService.scrollStrategies.noop(),
      positionStrategy: this.overlayPositionBuilder.global().bottom().right(),
      hasBackdrop: true
    });
    const windowsContainerPortal = new NbComponentPortal(NbWindowsContainerComponent, null, null, this.cfr);
    const overlayRef = this.overlayRef.attach(windowsContainerPortal);
    this.windowsContainerViewRef = overlayRef.instance.viewContainerRef;
  }
  appendWindow(content, config, windowRef) {
    const context = content instanceof TemplateRef ? {
      $implicit: config.context,
      windowRef
    } : config.context;
    const providers = [{
      provide: NB_WINDOW_CONTENT,
      useValue: content
    }, {
      provide: NB_WINDOW_CONTEXT,
      useValue: context
    }, {
      provide: NbWindowConfig,
      useValue: config
    }, {
      provide: NbWindowRef,
      useValue: windowRef
    }];
    const parentInjector = config.viewContainerRef ? config.viewContainerRef.injector : this.windowsContainerViewRef.injector;
    const injector = Injector.create({
      parent: parentInjector,
      providers
    });
    const windowFactory2 = this.componentFactoryResolver.resolveComponentFactory(NbWindowComponent);
    const ref = this.windowsContainerViewRef.createComponent(windowFactory2, this.windowsContainerViewRef.length, injector);
    ref.instance.cfr = this.cfr;
    ref.changeDetectorRef.detectChanges();
    return ref;
  }
  subscribeToEvents(windowRef) {
    if (windowRef.config.closeOnBackdropClick) {
      this.overlayRef.backdropClick().subscribe(() => windowRef.close());
    }
    if (windowRef.config.closeOnEsc) {
      this.overlayRef.keydownEvents().pipe(filter((event) => event.keyCode === 27)).subscribe(() => windowRef.close());
    }
    windowRef.stateChange.subscribe(() => this.checkAndUpdateOverlay());
    windowRef.onClose.subscribe(() => {
      this.openWindows.splice(this.openWindows.indexOf(windowRef), 1);
      this.checkAndUpdateOverlay();
    });
  }
  checkAndUpdateOverlay() {
    const fullScreenWindows = this.openWindows.filter((w) => w.state === NbWindowState.FULL_SCREEN);
    if (fullScreenWindows.length > 0) {
      this.blockScrollStrategy.enable();
    } else {
      this.blockScrollStrategy.disable();
    }
    if (fullScreenWindows.some((w) => w.config.hasBackdrop)) {
      this.overlayRef.backdropElement.removeAttribute("hidden");
    } else {
      this.overlayRef.backdropElement.setAttribute("hidden", "");
    }
  }
};
_NbWindowService.ɵfac = function NbWindowService_Factory(t) {
  return new (t || _NbWindowService)(ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NbOverlayService), ɵɵinject(NbOverlayPositionBuilder), ɵɵinject(NbBlockScrollStrategyAdapter), ɵɵinject(NB_WINDOW_CONFIG), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NB_DOCUMENT));
};
_NbWindowService.ɵprov = ɵɵdefineInjectable({
  token: _NbWindowService,
  factory: _NbWindowService.ɵfac
});
var NbWindowService = _NbWindowService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowService, [{
    type: Injectable
  }], () => [{
    type: ComponentFactoryResolver$1
  }, {
    type: NbOverlayService
  }, {
    type: NbOverlayPositionBuilder
  }, {
    type: NbBlockScrollStrategyAdapter
  }, {
    type: NbWindowConfig,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONFIG]
    }]
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbWindowModule = class _NbWindowModule {
  static forRoot(defaultConfig) {
    return {
      ngModule: _NbWindowModule,
      providers: [NbWindowService, {
        provide: NB_WINDOW_CONFIG,
        useValue: defaultConfig
      }]
    };
  }
  static forChild(defaultConfig) {
    return {
      ngModule: _NbWindowModule,
      providers: [NbWindowService, {
        provide: NB_WINDOW_CONFIG,
        useValue: defaultConfig
      }]
    };
  }
};
_NbWindowModule.ɵfac = function NbWindowModule_Factory(t) {
  return new (t || _NbWindowModule)();
};
_NbWindowModule.ɵmod = ɵɵdefineNgModule({
  type: _NbWindowModule,
  declarations: [NbWindowsContainerComponent, NbWindowComponent],
  imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]
});
_NbWindowModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]
});
var NbWindowModule = _NbWindowModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule],
      declarations: [NbWindowsContainerComponent, NbWindowComponent]
    }]
  }], null, null);
})();
var _NbTimePickerDirective = class _NbTimePickerDirective {
  /**
   * Provides timepicker component.
   * */
  get timepicker() {
    return this._timePickerComponent;
  }
  set timepicker(timePicker) {
    this._timePickerComponent = timePicker;
    this.pickerInputsChangedSubscription?.unsubscribe();
    this.pickerInputsChangedSubscription = this._timePickerComponent.timepickerFormatChange$.pipe(map(() => this._timePickerComponent.computedTimeFormat), startWith(this._timePickerComponent.computedTimeFormat), distinctUntilChanged(), pairwise(), takeUntil(this.destroy$)).subscribe(([prevFormat, nextFormat]) => {
      if (this.inputValue) {
        const date = this.dateService.parse(this.inputValue, prevFormat);
        this.writeValue(date);
      }
    });
  }
  /**
   * Returns html input element.
   * @docs-private
   * */
  get input() {
    return this.hostRef.nativeElement;
  }
  /**
   * Determines is timepicker overlay opened.
   * @docs-private
   * */
  get isOpen() {
    return this.overlayRef && this.overlayRef.hasAttached();
  }
  /**
   * Determines is timepicker overlay closed.
   * @docs-private
   * */
  get isClosed() {
    return !this.isOpen;
  }
  constructor(document2, positionBuilder, hostRef, triggerStrategyBuilder, overlay, cd, calendarTimeModelService, dateService, renderer, placeholder) {
    this.document = document2;
    this.positionBuilder = positionBuilder;
    this.hostRef = hostRef;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.overlay = overlay;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
    this.dateService = dateService;
    this.renderer = renderer;
    this.placeholder = placeholder;
    this.overlayOffset = 8;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
  }
  /**
   * Returns host input value.
   * @docs-private
   * */
  get inputValue() {
    return this.input.value;
  }
  set inputValue(value) {
    this.input.value = value;
  }
  ngAfterViewInit() {
    this.subscribeOnInputChange();
    if (!this.placeholder) {
      this.renderer.setProperty(this.input, "placeholder", this.timepicker.computedTimeFormat);
    }
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnTriggers();
    this.subscribeToBlur();
  }
  show() {
    if (this.isClosed) {
      this.attachToOverlay();
    }
  }
  hide() {
    if (this.isOpen) {
      this.overlayRef.detach();
      this.cd.markForCheck();
    }
  }
  /**
   * Attaches picker to the timepicker portal.
   * @docs-private
   * */
  attachToOverlay() {
    if (!this.overlayRef) {
      this.setupTimepicker();
      this.initOverlay();
    }
    this.overlayRef.attach(this.timepicker.portal);
  }
  setupTimepicker() {
    if (this.dateService.getId() === "native" && isDevMode()) {
      console.warn("Date.parse does not support parsing time with custom format. See details here https://akveo.github.io/nebular/docs/components/datepicker/overview#native-parse-issue");
    }
    this.timepicker.setHost(this.hostRef);
    if (this.inputValue) {
      const val = this.dateService.getId() === "native" ? this.parseNativeDateString(this.inputValue) : this.inputValue;
      this.timepicker.date = this.dateService.parse(val, this.timepicker.computedTimeFormat);
    } else {
      this.timepicker.date = this.calendarTimeModelService.getResetTime();
    }
  }
  initOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.subscribeOnApplyClick();
    this.createOverlay();
  }
  subscribeOnApplyClick() {
    this.timepicker.onSelectTime.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      const time = this.dateService.format(value.time, this.timepicker.computedTimeFormat).toUpperCase();
      this.inputValue = time;
      this.timepicker.date = value.time;
      this.onChange(value.time);
      if (value.save) {
        this.lastInputValue = time;
        this.hide();
      }
    });
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.overlayRef = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy
    });
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.pipe(filter(() => this.isClosed)).subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(() => {
      this.inputValue = this.lastInputValue || "";
      this.hide();
    });
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(NbAdjustment.COUNTERCLOCKWISE);
  }
  getContainer() {
    return this.overlayRef && this.isOpen && {
      location: {
        nativeElement: this.overlayRef.overlayElement
      }
    };
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies.block();
  }
  subscribeOnInputChange() {
    fromEvent(this.input, "input").pipe(map(() => this.inputValue), takeUntil(this.destroy$)).subscribe((value) => this.handleInputChange(value));
  }
  subscribeToBlur() {
    merge(this.timepicker.blur, fromEvent(this.input, "blur").pipe(filter(() => !this.isOpen && this.document.activeElement !== this.input))).pipe(takeUntil(this.destroy$)).subscribe(() => this.onTouched());
  }
  /**
   * Parses input value and write if it isn't null.
   * @docs-private
   * */
  handleInputChange(value) {
    if (this.dateService.getId() === "native") {
      value = this.parseNativeDateString(value);
    }
    const isValidDate = this.dateService.isValidDateString(value, this.timepicker.computedTimeFormat);
    if (isValidDate) {
      this.lastInputValue = value;
      const date = this.dateService.parse(value, this.timepicker.computedTimeFormat);
      this.onChange(date);
      this.timepicker.date = date;
    }
  }
  updateValue(value) {
    if (value) {
      this.timepicker.date = value;
      const timeString = this.dateService.format(value, this.timepicker.computedTimeFormat).toUpperCase();
      this.inputValue = timeString;
      this.lastInputValue = timeString;
    }
  }
  writeValue(value) {
    this.updateValue(value);
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.input.disabled = isDisabled;
  }
  parseNativeDateString(value) {
    const date = this.dateService.today();
    const year = this.dateService.getYear(date);
    const month = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getMonth(date));
    const day = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getDate(date));
    return `${year}-${month}-${day} ${value}`;
  }
};
_NbTimePickerDirective.ɵfac = function NbTimePickerDirective_Factory(t) {
  return new (t || _NbTimePickerDirective)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbCalendarTimeModelService), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(Renderer2), ɵɵinjectAttribute("placeholder"));
};
_NbTimePickerDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTimePickerDirective,
  selectors: [["input", "nbTimepicker", ""]],
  inputs: {
    timepicker: [InputFlags.None, "nbTimepicker", "timepicker"],
    overlayOffset: "overlayOffset"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbTimePickerDirective),
    multi: true
  }])]
});
var NbTimePickerDirective = _NbTimePickerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbTimepicker]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbTimePickerDirective),
        multi: true
      }]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: ElementRef
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }, {
    type: NbDateService
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["placeholder"]
    }]
  }], {
    timepicker: [{
      type: Input,
      args: ["nbTimepicker"]
    }],
    overlayOffset: [{
      type: Input
    }]
  });
})();
var _NbTimepickerModule = class _NbTimepickerModule {
  static forRoot(config = {}) {
    return {
      ngModule: _NbTimepickerModule,
      providers: [{
        provide: NB_TIME_PICKER_CONFIG,
        useValue: config
      }]
    };
  }
  static forChild(config = {}) {
    return {
      ngModule: _NbTimepickerModule,
      providers: [{
        provide: NB_TIME_PICKER_CONFIG,
        useValue: config
      }]
    };
  }
};
_NbTimepickerModule.ɵfac = function NbTimepickerModule_Factory(t) {
  return new (t || _NbTimepickerModule)();
};
_NbTimepickerModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTimepickerModule,
  declarations: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective],
  imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule],
  exports: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]
});
_NbTimepickerModule.ɵinj = ɵɵdefineInjector({
  providers: [NbCalendarTimeModelService],
  imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule]
});
var NbTimepickerModule = _NbTimepickerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimepickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule],
      providers: [NbCalendarTimeModelService],
      exports: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective],
      declarations: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]
    }]
  }], null, null);
})();
var _NbDateAdapterService = class _NbDateAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbDatepickerComponent;
  }
  parse(date, format) {
    return this.dateService.parse(date, format);
  }
  format(date, format) {
    return this.dateService.format(date, format);
  }
  isValid(date, format) {
    return this.dateService.isValidDateString(date, format);
  }
};
_NbDateAdapterService.ɵfac = function NbDateAdapterService_Factory(t) {
  return new (t || _NbDateAdapterService)(ɵɵinject(NbDateService));
};
_NbDateAdapterService.ɵprov = ɵɵdefineInjectable({
  token: _NbDateAdapterService,
  factory: _NbDateAdapterService.ɵfac
});
var NbDateAdapterService = _NbDateAdapterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbRangeAdapterService = class _NbRangeAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbRangepickerComponent;
  }
  parse(range2, format) {
    const [start, end] = range2.split("-").map((subDate) => subDate.trim());
    return {
      start: this.dateService.parse(start, format),
      end: this.dateService.parse(end, format)
    };
  }
  format(range2, format) {
    if (!range2) {
      return "";
    }
    const start = this.dateService.format(range2.start, format);
    const isStartValid = this.dateService.isValidDateString(start, format);
    if (!isStartValid) {
      return "";
    }
    const end = this.dateService.format(range2.end, format);
    const isEndValid = this.dateService.isValidDateString(end, format);
    if (isEndValid) {
      return `${start} - ${end}`;
    } else {
      return start;
    }
  }
  isValid(range2, format) {
    const [start, end] = range2.split("-").map((subDate) => subDate.trim());
    return this.dateService.isValidDateString(start, format) && this.dateService.isValidDateString(end, format);
  }
};
_NbRangeAdapterService.ɵfac = function NbRangeAdapterService_Factory(t) {
  return new (t || _NbRangeAdapterService)(ɵɵinject(NbDateService));
};
_NbRangeAdapterService.ɵprov = ɵɵdefineInjectable({
  token: _NbRangeAdapterService,
  factory: _NbRangeAdapterService.ɵfac
});
var NbRangeAdapterService = _NbRangeAdapterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRangeAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbDateTimeAdapterService = class _NbDateTimeAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbDateTimePickerComponent;
  }
  parse(date, format) {
    return this.dateService.parse(date, format);
  }
  format(date, format) {
    return this.dateService.format(date, format);
  }
  isValid(date, format) {
    return this.dateService.isValidDateString(date, format);
  }
};
_NbDateTimeAdapterService.ɵfac = function NbDateTimeAdapterService_Factory(t) {
  return new (t || _NbDateTimeAdapterService)(ɵɵinject(NbDateService));
};
_NbDateTimeAdapterService.ɵprov = ɵɵdefineInjectable({
  token: _NbDateTimeAdapterService,
  factory: _NbDateTimeAdapterService.ɵfac
});
var NbDateTimeAdapterService = _NbDateTimeAdapterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateTimeAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbDatepickerModule = class _NbDatepickerModule {
  static forRoot() {
    return {
      ngModule: _NbDatepickerModule,
      providers: [DatePipe, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbDateAdapterService
      }, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbRangeAdapterService
      }, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbDateTimeAdapterService
      }]
    };
  }
};
_NbDatepickerModule.ɵfac = function NbDatepickerModule_Factory(t) {
  return new (t || _NbDatepickerModule)();
};
_NbDatepickerModule.ɵmod = ɵɵdefineNgModule({
  type: _NbDatepickerModule,
  declarations: [NbDatepickerDirective, NbDatepickerContainerComponent, NbCalendarWithTimeComponent, NbDateTimePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbBasePickerComponent],
  imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule],
  exports: [NbDatepickerDirective, NbDatepickerComponent, NbRangepickerComponent, NbDateTimePickerComponent, NbCalendarWithTimeComponent]
});
_NbDatepickerModule.ɵinj = ɵɵdefineInjector({
  imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule]
});
var NbDatepickerModule = _NbDatepickerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerModule, [{
    type: NgModule,
    args: [{
      imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule],
      exports: [NbDatepickerDirective, NbDatepickerComponent, NbRangepickerComponent, NbDateTimePickerComponent, NbCalendarWithTimeComponent],
      declarations: [NbDatepickerDirective, NbDatepickerContainerComponent, NbCalendarWithTimeComponent, NbDateTimePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbBasePickerComponent]
    }]
  }], null, null);
})();
var _NbRadioComponent = class _NbRadioComponent {
  get name() {
    return this._name;
  }
  set name(value) {
    if (this._name !== value) {
      this._name = value;
    }
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    const boolValue = convertToBoolProperty(value);
    if (this._checked !== boolValue) {
      this._checked = boolValue;
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._value !== value) {
      this._value = value;
    }
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    const boolValue = convertToBoolProperty(disabled);
    if (this._disabled !== boolValue) {
      this._disabled = boolValue;
    }
  }
  constructor(cd, renderer, statusService) {
    this.cd = cd;
    this.renderer = renderer;
    this.statusService = statusService;
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this.valueChange = new EventEmitter();
    this.blur = new EventEmitter();
  }
  get isPrimary() {
    return this.status === "primary";
  }
  get isSuccess() {
    return this.status === "success";
  }
  get isWarning() {
    return this.status === "warning";
  }
  get isDanger() {
    return this.status === "danger";
  }
  get isInfo() {
    return this.status === "info";
  }
  get isBasic() {
    return this.status === "basic";
  }
  get isControl() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  onChange(event) {
    event.stopPropagation();
    this.checked = true;
    this.valueChange.emit(this.value);
  }
  onClick(event) {
    event.stopPropagation();
  }
  /*
   * @docs-private
   * We use this method when setting radio inputs from radio group component.
   * Otherwise Angular won't detect changes in radio template as cached last rendered
   * value didn't updated.
   **/
  _markForCheck() {
    this.cd.markForCheck();
  }
  /*
   * @docs-private
   * Use this method when setting radio name from radio group component.
   * In case option 'name' isn't set on nb-radio component we need to set name
   * right away, so it won't overlap with options without names from other radio
   * groups. Otherwise they all would have same name and will be considered as
   * options from one group so only the last option will stay selected.
   **/
  _setName(name) {
    this.name = name;
    if (this.input) {
      this.renderer.setProperty(this.input.nativeElement, "name", name);
    }
  }
};
_NbRadioComponent.ɵfac = function NbRadioComponent_Factory(t) {
  return new (t || _NbRadioComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NbStatusService));
};
_NbRadioComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRadioComponent,
  selectors: [["nb-radio"]],
  viewQuery: function NbRadioComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c51, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
    }
  },
  hostVars: 16,
  hostBindings: function NbRadioComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-primary", ctx.isPrimary)("status-success", ctx.isSuccess)("status-warning", ctx.isWarning)("status-danger", ctx.isDanger)("status-info", ctx.isInfo)("status-basic", ctx.isBasic)("status-control", ctx.isControl);
    }
  },
  inputs: {
    name: "name",
    checked: "checked",
    value: "value",
    disabled: "disabled",
    status: "status"
  },
  outputs: {
    valueChange: "valueChange",
    blur: "blur"
  },
  ngContentSelectors: _c03,
  decls: 7,
  vars: 4,
  consts: [["input", ""], ["type", "radio", 1, "native-input", "visually-hidden", 3, "change", "click", "name", "value", "checked", "disabled"], [1, "outer-circle"], [1, "inner-circle"], [1, "text"]],
  template: function NbRadioComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "label")(1, "input", 1, 0);
      ɵɵlistener("change", function NbRadioComponent_Template_input_change_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onChange($event));
      })("click", function NbRadioComponent_Template_input_click_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onClick($event));
      });
      ɵɵelementEnd();
      ɵɵelement(3, "span", 2)(4, "span", 3);
      ɵɵelementStart(5, "span", 4);
      ɵɵprojection(6);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("name", ctx.name)("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
    }
  },
  styles: ["\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]{display:block;position:relative}[_nghost-%COMP%]   label[_ngcontent-%COMP%]{display:inline-flex;margin:0;min-height:inherit;padding:.375rem 0;align-items:center}[dir=ltr]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-right:1.5rem}[dir=rtl]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-left:1.5rem}[_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=ltr]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{left:0}[dir=rtl]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{right:0}[_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{transform:translateY(-50%) scale(.6)}[dir=ltr]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-right:.5rem}"],
  changeDetection: 0
});
var NbRadioComponent = _NbRadioComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioComponent, [{
    type: Component,
    args: [{
      selector: "nb-radio",
      template: `
    <label>
      <input
        #input
        type="radio"
        class="native-input visually-hidden"
        [name]="name"
        [value]="value"
        [checked]="checked"
        [disabled]="disabled"
        (change)="onChange($event)"
        (click)="onClick($event)">
      <span class="outer-circle"></span>
      <span class="inner-circle"></span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:block;position:relative}:host label{display:inline-flex;margin:0;min-height:inherit;padding:.375rem 0;align-items:center}[dir=ltr] :host label{padding-right:1.5rem}[dir=rtl] :host label{padding-left:1.5rem}:host .outer-circle,:host .inner-circle{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] :host .outer-circle,[dir=ltr] :host .inner-circle{left:0}[dir=rtl] :host .outer-circle,[dir=rtl] :host .inner-circle{right:0}:host .inner-circle{transform:translateY(-50%) scale(.6)}[dir=ltr] :host .text{padding-left:.5rem}[dir=rtl] :host .text{padding-right:.5rem}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NbStatusService
  }], {
    name: [{
      type: Input
    }],
    checked: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    blur: [{
      type: Output
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        read: ElementRef
      }]
    }],
    isPrimary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    isSuccess: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    isWarning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    isDanger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    isInfo: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    isBasic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    isControl: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbRadioGroupComponent = class _NbRadioGroupComponent {
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.updateValues();
  }
  get name() {
    return this._name;
  }
  set name(name) {
    this._name = name;
    this.updateNames();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    this._disabled = convertToBoolProperty(disabled);
    this.updateDisabled();
  }
  /**
   * Radio buttons status.
   * Possible values are `primary` (default), `success`, `warning`, `danger`, `info`.
   */
  get status() {
    return this._status;
  }
  set status(value) {
    if (this._status !== value) {
      this._status = value;
      this.updateStatus();
    }
  }
  constructor(hostElement, platformId, document2) {
    this.hostElement = hostElement;
    this.platformId = platformId;
    this.document = document2;
    this.destroy$ = new Subject();
    this.onChange = (value) => {
    };
    this.onTouched = () => {
    };
    this._status = "basic";
    this.valueChange = new EventEmitter();
  }
  ngAfterContentInit() {
    this.updateNames();
    this.radios.changes.pipe(
      startWith(this.radios),
      // 'changes' emit during change detection run and we can't update
      // option properties right of since they already was initialized.
      // Instead we schedule microtask to update radios after change detection
      // run is finished and trigger one more change detection run.
      switchMap((radios) => from(Promise.resolve(radios))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.updateAndSubscribeToRadios());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(value) {
    this.value = value;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  updateAndSubscribeToRadios() {
    this.updateValueFromCheckedOption();
    this.updateNames();
    this.updateValues();
    this.updateDisabled();
    this.updateStatus();
    this.subscribeOnRadiosValueChange();
    this.subscribeOnRadiosBlur();
  }
  updateNames() {
    if (this.radios) {
      this.radios.forEach((radio) => radio._setName(this.name));
    }
  }
  updateValues() {
    this.updateAndMarkForCheckRadios((radio) => radio.checked = radio.value === this.value);
  }
  updateDisabled() {
    if (typeof this.disabled !== "undefined") {
      this.updateAndMarkForCheckRadios((radio) => radio.disabled = this.disabled);
    }
  }
  subscribeOnRadiosValueChange() {
    if (!this.radios || !this.radios.length) {
      return;
    }
    merge(...this.radios.map((radio) => radio.valueChange)).pipe(takeUntil(merge(this.radios.changes, this.destroy$))).subscribe((value) => {
      this.writeValue(value);
      this.propagateValue(value);
    });
  }
  propagateValue(value) {
    this.valueChange.emit(value);
    this.onChange(value);
  }
  subscribeOnRadiosBlur() {
    const hasNoRadios = !this.radios || !this.radios.length;
    if (!isPlatformBrowser(this.platformId) || hasNoRadios) {
      return;
    }
    const hostElement = this.hostElement.nativeElement;
    fromEvent(hostElement, "focusin").pipe(filter((event) => hostElement.contains(event.target)), switchMap(() => merge(fromEvent(this.document, "focusin"), fromEvent(this.document, "click"))), filter((event) => !hostElement.contains(event.target)), takeUntil(merge(this.radios.changes, this.destroy$))).subscribe(() => this.onTouched());
  }
  updateStatus() {
    this.updateAndMarkForCheckRadios((radio) => radio.status = this.status);
  }
  updateAndMarkForCheckRadios(updateFn) {
    if (this.radios) {
      this.radios.forEach((radio) => {
        updateFn(radio);
        radio._markForCheck();
      });
    }
  }
  updateValueFromCheckedOption() {
    const checkedRadio = this.radios.find((radio) => radio.checked);
    const isValueMissing = this.value === void 0 || this.value === null;
    if (checkedRadio && isValueMissing && checkedRadio.value !== this.value) {
      this.value = checkedRadio.value;
    }
  }
};
_NbRadioGroupComponent.ɵfac = function NbRadioGroupComponent_Factory(t) {
  return new (t || _NbRadioGroupComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NB_DOCUMENT));
};
_NbRadioGroupComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRadioGroupComponent,
  selectors: [["nb-radio-group"]],
  contentQueries: function NbRadioGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbRadioComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radios = _t);
    }
  },
  inputs: {
    value: "value",
    name: "name",
    disabled: "disabled",
    status: "status"
  },
  outputs: {
    valueChange: "valueChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbRadioGroupComponent),
    multi: true
  }])],
  ngContentSelectors: _c53,
  decls: 1,
  vars: 0,
  template: function NbRadioGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c52);
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbRadioGroupComponent = _NbRadioGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-radio-group",
      template: `
    <ng-content select="nb-radio"></ng-content>`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbRadioGroupComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], {
    value: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    radios: [{
      type: ContentChildren,
      args: [NbRadioComponent, {
        descendants: true
      }]
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var _NbRadioModule = class _NbRadioModule {
};
_NbRadioModule.ɵfac = function NbRadioModule_Factory(t) {
  return new (t || _NbRadioModule)();
};
_NbRadioModule.ɵmod = ɵɵdefineNgModule({
  type: _NbRadioModule,
  declarations: [NbRadioComponent, NbRadioGroupComponent],
  exports: [NbRadioComponent, NbRadioGroupComponent]
});
_NbRadioModule.ɵinj = ɵɵdefineInjector({});
var NbRadioModule = _NbRadioModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioModule, [{
    type: NgModule,
    args: [{
      imports: [],
      exports: [NbRadioComponent, NbRadioGroupComponent],
      declarations: [NbRadioComponent, NbRadioGroupComponent]
    }]
  }], null, null);
})();
var tagUniqueId = 0;
var _NbTagComponent = class _NbTagComponent {
  get destroy$() {
    return this._destroy$.asObservable();
  }
  get selected() {
    return this._selected;
  }
  set selected(value) {
    if (this.selected !== convertToBoolProperty(value)) {
      this._selected = !this.selected;
      this.selectedChange.emit({
        tag: this,
        selected: this.selected
      });
    }
  }
  /**
   * Controls whether the user can remove a tag or not.
   */
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = convertToBoolProperty(value);
  }
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  get basic() {
    return this.status === "basic";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get control() {
    return this.status === "control";
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  _remove() {
    if (this.removable) {
      this.remove.emit(this);
    }
  }
  constructor(_hostElement, cd, renderer, zone, statusService) {
    this._hostElement = _hostElement;
    this.cd = cd;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this._destroy$ = new Subject();
    this._selected = false;
    this._removable = false;
    this.appearance = "filled";
    this.status = "basic";
    this.size = "medium";
    this.role = "option";
    this.remove = new EventEmitter();
    this.selectedChange = new EventEmitter();
    this._isActive = false;
    this._id = `nb-tag-${tagUniqueId++}`;
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this._hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this._destroy$.next(this);
  }
  _toggleSelection() {
    this.selected = !this.selected;
    this.cd.markForCheck();
  }
  setActiveStyles() {
    if (!this._isActive) {
      this._isActive = true;
      this.cd.markForCheck();
    }
  }
  setInactiveStyles() {
    if (this._isActive) {
      this._isActive = false;
      this.cd.markForCheck();
    }
  }
};
_NbTagComponent.ɵfac = function NbTagComponent_Factory(t) {
  return new (t || _NbTagComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbTagComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTagComponent,
  selectors: [["nb-tag"]],
  hostVars: 37,
  hostBindings: function NbTagComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown.delete", function NbTagComponent_keydown_delete_HostBindingHandler() {
        return ctx._remove();
      })("keydown.backspace", function NbTagComponent_keydown_backspace_HostBindingHandler() {
        return ctx._remove();
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-selected", ctx.selected)("role", ctx.role)("id", ctx._id);
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("selected", ctx.selected)("active", ctx._isActive)("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("status-basic", ctx.basic)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-control", ctx.control)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    }
  },
  inputs: {
    text: "text",
    selected: "selected",
    removable: "removable",
    appearance: "appearance",
    status: "status",
    size: "size",
    role: "role"
  },
  outputs: {
    remove: "remove",
    selectedChange: "selectedChange"
  },
  exportAs: ["nbTag"],
  decls: 2,
  vars: 2,
  consts: [["icon", "close-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "class", "click", 4, "ngIf"], ["icon", "close-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"]],
  template: function NbTagComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtext(0);
      ɵɵtemplate(1, NbTagComponent_nb_icon_1_Template, 1, 3, "nb-icon", 0);
    }
    if (rf & 2) {
      ɵɵtextInterpolate1("", ctx.text, "\n");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.removable);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbTagComponent = _NbTagComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagComponent, [{
    type: Component,
    args: [{
      selector: "nb-tag",
      exportAs: "nbTag",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '{{ text }}\n<nb-icon *ngIf="removable"\n         (click)="_remove()"\n         class="nb-tag-remove size-{{size}}"\n         icon="close-outline"\n         pack="nebular-essentials"\n         aria-hidden="true">\n</nb-icon>\n'
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    text: [{
      type: Input
    }],
    selected: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.selected"]
    }, {
      type: HostBinding,
      args: ["attr.aria-selected"]
    }],
    removable: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }],
    remove: [{
      type: Output
    }],
    selectedChange: [{
      type: Output
    }],
    _isActive: [{
      type: HostBinding,
      args: ["class.active"]
    }],
    _id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    filled: [{
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    outline: [{
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    _remove: [{
      type: HostListener,
      args: ["keydown.delete"]
    }, {
      type: HostListener,
      args: ["keydown.backspace"]
    }]
  });
})();
var _NbTagInputDirective = class _NbTagInputDirective extends NbInputDirective {
  get _value() {
    return this._hostElement.nativeElement.value;
  }
  _onKeydown(event) {
    this.keyDown$.next(event);
  }
  constructor(_hostElement, focusMonitor, renderer, zone, statusService) {
    super(_hostElement, focusMonitor, renderer, zone, statusService);
    this._hostElement = _hostElement;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.keyDown$ = new Subject();
    this.separatorKeys = [ENTER];
    this.tagAdd = new EventEmitter();
    this.nbTagInputClass = true;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    this.keyDown$.pipe(filter(({
      keyCode
    }) => this.isSeparatorKey(keyCode)), map(() => this._value), takeUntil(this.destroy$)).subscribe((value) => this.tagAdd.emit({
      value,
      input: this._hostElement
    }));
  }
  isSeparatorKey(keyCode) {
    return this.separatorKeys.includes(keyCode);
  }
};
_NbTagInputDirective.ɵfac = function NbTagInputDirective_Factory(t) {
  return new (t || _NbTagInputDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbTagInputDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTagInputDirective,
  selectors: [["input", "nbTagInput", ""]],
  hostVars: 2,
  hostBindings: function NbTagInputDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function NbTagInputDirective_keydown_HostBindingHandler($event) {
        return ctx._onKeydown($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("nb-tag-input", ctx.nbTagInputClass);
    }
  },
  inputs: {
    separatorKeys: "separatorKeys"
  },
  outputs: {
    tagAdd: "tagAdd"
  },
  exportAs: ["nbTagInput"],
  features: [ɵɵProvidersFeature([{
    provide: NbFormFieldControl,
    useExisting: _NbTagInputDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTagInputDirective = _NbTagInputDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagInputDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbTagInput]",
      exportAs: "nbTagInput",
      providers: [{
        provide: NbFormFieldControl,
        useExisting: NbTagInputDirective
      }]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    separatorKeys: [{
      type: Input
    }],
    tagAdd: [{
      type: Output
    }],
    nbTagInputClass: [{
      type: HostBinding,
      args: ["class.nb-tag-input"]
    }],
    _onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var _NbTagListComponent = class _NbTagListComponent {
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  get _hasInput() {
    return !!this.tagInput;
  }
  get _isFocused() {
    return this.focused;
  }
  get _isFullWidth() {
    return !!this.tagInput?.fullWidth;
  }
  get _inputClasses() {
    if (this._hasInput) {
      return [`shape-${this.tagInput.shape}`, `size-${this.tagInput.fieldSize}`, this.statusService.getStatusClass(this.tagInput.status)];
    }
    return [`size-${this.size}`];
  }
  _onKeydown(event) {
    this.keyDown$.next(event);
  }
  _onClick({
    target
  }) {
    const clickedTag = this.tags.find((tag) => tag._hostElement.nativeElement === target);
    if (clickedTag) {
      this.tagClick$.next(clickedTag);
    }
  }
  constructor(hostElement, cd, renderer, zone, focusMonitor, activeDescendantKeyManagerFactory, directionService, statusService) {
    this.hostElement = hostElement;
    this.cd = cd;
    this.renderer = renderer;
    this.zone = zone;
    this.focusMonitor = focusMonitor;
    this.activeDescendantKeyManagerFactory = activeDescendantKeyManagerFactory;
    this.directionService = directionService;
    this.statusService = statusService;
    this.destroy$ = new Subject();
    this.keyDown$ = new Subject();
    this.tagClick$ = new Subject();
    this.focused = false;
    this.size = "medium";
    this.tabIndex = 0;
    this.role = "listbox";
    this._multiple = false;
    this.activeTagId = null;
    this.tagRemove = new EventEmitter();
  }
  ngOnInit() {
    this.focusMonitor.monitor(this.hostElement, true).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.hostElement)), takeUntil(this.destroy$)).subscribe((isFocused) => this.onFocusChange(isFocused));
  }
  ngAfterContentInit() {
    this.initKeyManager();
    this.setAutocompleteCustomHost();
  }
  ngAfterViewInit() {
    this.listenToLayoutDirectionChange();
    this.listenListKeyDown();
    this.listenInputKeyDown();
    this.listenTagClick();
    this.listenTagRemove();
    this.listenTagDestroy();
    this.listenActiveTagChange();
    this.listenNoTags();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  initKeyManager() {
    this.keyManager = this.activeDescendantKeyManagerFactory.create(this.tags).withHorizontalOrientation(this.directionService.getDirection()).withWrap();
  }
  listenToLayoutDirectionChange() {
    this.directionService.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe((direction) => this.keyManager.withHorizontalOrientation(direction));
  }
  listenListKeyDown() {
    const tagListKeyDown$ = this.keyDown$.pipe(filter(({
      target
    }) => target === this.hostElement.nativeElement));
    const activeTagKeyDown$ = tagListKeyDown$.pipe(filter(() => !!this.keyManager.activeItem));
    tagListKeyDown$.pipe(takeUntil(this.destroy$)).subscribe((event) => this.keyManager.onKeydown(event));
    activeTagKeyDown$.pipe(filter(({
      keyCode
    }) => keyCode === SPACE), takeUntil(this.destroy$)).subscribe((event) => {
      this.toggleTag(this.keyManager.activeItem);
      event.preventDefault();
    });
    activeTagKeyDown$.pipe(filter(({
      keyCode
    }) => this.isBackspaceOrDelete(keyCode)), map(() => this.keyManager.activeItem), takeUntil(this.destroy$)).subscribe((tagToRemove) => tagToRemove._remove());
  }
  listenInputKeyDown() {
    const inputKeyDown$ = this.keyDown$.pipe(filter(({
      target
    }) => target === this.tagInput?._hostElement.nativeElement));
    inputKeyDown$.pipe(filter(({
      keyCode
    }) => {
      return this.tagInput._value === "" && this.isBackspaceOrDelete(keyCode) && this.tags.length > 0;
    }), takeUntil(this.destroy$)).subscribe(() => {
      this.hostElement.nativeElement.focus();
      this.keyManager.setLastItemActive();
      this.cd.markForCheck();
    });
  }
  listenTagClick() {
    this.tagClick$.pipe(takeUntil(this.destroy$)).subscribe((clickedTag) => {
      this.toggleTag(clickedTag);
      this.keyManager.setActiveItem(clickedTag);
    });
  }
  listenTagRemove() {
    this.tags.changes.pipe(startWith(this.tags), switchMap((tags) => merge(...tags.map((tag) => tag.remove))), takeUntil(this.destroy$)).subscribe((tagToRemove) => this.tagRemove.emit(tagToRemove));
  }
  listenTagDestroy() {
    this.tags.changes.pipe(startWith(this.tags), switchMap((tags) => merge(...tags.map((tag) => tag.destroy$))), filter((destroyedTag) => destroyedTag === this.keyManager.activeItem), map((destroyedTag) => destroyedTag === this.tags.last), takeUntil(this.destroy$)).subscribe((isLastTagDestroyed) => {
      if (isLastTagDestroyed) {
        this.keyManager.setPreviousItemActive();
      } else {
        this.keyManager.setNextItemActive();
      }
    });
  }
  listenNoTags() {
    this.tags.changes.pipe(startWith(this.tags), filter((tags) => tags.length === 0), takeUntil(this.destroy$)).subscribe(() => this.focusInputIfActive());
  }
  listenActiveTagChange() {
    this.keyManager.change.pipe(map(() => this.keyManager.activeItem?._id), takeUntil(this.destroy$)).subscribe((activeTagId) => {
      this.activeTagId = activeTagId;
      this.cd.markForCheck();
    });
  }
  onFocusChange(isFocused) {
    this.focused = isFocused;
    this.cd.markForCheck();
    if (!isFocused || this.tagInput?.focused$.value) {
      this.keyManager?.setActiveItem(-1);
      return;
    }
    if (this.tags.length === 0 && this._hasInput) {
      this.focusInput();
    } else {
      this.keyManager.setFirstItemActive();
    }
  }
  isBackspaceOrDelete(keyCode) {
    return keyCode === BACKSPACE || keyCode === DELETE;
  }
  setAutocompleteCustomHost() {
    if (this.autocompleteDirective) {
      this.autocompleteDirective.customOverlayHost = this.hostElement;
    }
  }
  toggleTag(tagToToggle) {
    tagToToggle._toggleSelection();
    if (tagToToggle.selected && !this.multiple) {
      this.tags.forEach((tag) => {
        if (tag !== tagToToggle) {
          tag.selected = false;
        }
      });
    }
  }
  focusInput() {
    if (this._hasInput) {
      this.tagInput._hostElement.nativeElement.focus();
    }
  }
  focusInputIfActive() {
    if (this._isFocused) {
      this.focusInput();
    }
  }
};
_NbTagListComponent.ɵfac = function NbTagListComponent_Factory(t) {
  return new (t || _NbTagListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbStatusService));
};
_NbTagListComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTagListComponent,
  selectors: [["nb-tag-list"]],
  contentQueries: function NbTagListComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbTagInputDirective, 5);
      ɵɵcontentQuery(dirIndex, NbAutocompleteDirective, 5);
      ɵɵcontentQuery(dirIndex, NbTagComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagInput = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.autocompleteDirective = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tags = _t);
    }
  },
  hostVars: 12,
  hostBindings: function NbTagListComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function NbTagListComponent_keydown_HostBindingHandler($event) {
        return ctx._onKeydown($event);
      })("click", function NbTagListComponent_click_HostBindingHandler($event) {
        return ctx._onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("tabindex", ctx.tabIndex)("role", ctx.role)("aria-multiselectable", ctx.multiple)("aria-activedescendant", ctx.activeTagId);
      ɵɵclassMap(ctx._inputClasses);
      ɵɵclassProp("nb-tag-list-with-input", ctx._hasInput)("focus", ctx._isFocused)("input-full-width", ctx._isFullWidth);
    }
  },
  inputs: {
    size: "size",
    tabIndex: "tabIndex",
    role: "role",
    multiple: "multiple"
  },
  outputs: {
    tagRemove: "tagRemove"
  },
  exportAs: ["nbTagList"],
  ngContentSelectors: _c55,
  decls: 2,
  vars: 0,
  consts: [[1, "nb-tag-list-tags-wrapper"]],
  template: function NbTagListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c54);
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbTagListComponent = _NbTagListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagListComponent, [{
    type: Component,
    args: [{
      selector: "nb-tag-list",
      template: `
    <div class="nb-tag-list-tags-wrapper">
      <ng-content select="nb-tag, input[nbTagInput]"></ng-content>
    </div>
  `,
      exportAs: "nbTagList",
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbFocusMonitor
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbStatusService
  }], {
    tags: [{
      type: ContentChildren,
      args: [NbTagComponent]
    }],
    tagInput: [{
      type: ContentChild,
      args: [NbTagInputDirective]
    }],
    autocompleteDirective: [{
      type: ContentChild,
      args: [NbAutocompleteDirective]
    }],
    size: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }],
    multiple: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-multiselectable"]
    }],
    activeTagId: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    tagRemove: [{
      type: Output
    }],
    _hasInput: [{
      type: HostBinding,
      args: ["class.nb-tag-list-with-input"]
    }],
    _isFocused: [{
      type: HostBinding,
      args: ["class.focus"]
    }],
    _isFullWidth: [{
      type: HostBinding,
      args: ["class.input-full-width"]
    }],
    _inputClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    _onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    _onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _NbTagModule = class _NbTagModule {
};
_NbTagModule.ɵfac = function NbTagModule_Factory(t) {
  return new (t || _NbTagModule)();
};
_NbTagModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTagModule,
  declarations: [NbTagComponent, NbTagListComponent, NbTagInputDirective],
  imports: [CommonModule, NbIconModule],
  exports: [NbTagComponent, NbTagListComponent, NbTagInputDirective]
});
_NbTagModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbIconModule]
});
var NbTagModule = _NbTagModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      declarations: [NbTagComponent, NbTagListComponent, NbTagInputDirective],
      exports: [NbTagComponent, NbTagListComponent, NbTagInputDirective]
    }]
  }], null, null);
})();
var NB_DEFAULT_ROW_LEVEL = 0;
var NbTreeGridPresentationNode = class {
  constructor(data, children, expanded, level) {
    this.data = data;
    this.children = children;
    this.expanded = expanded;
    this.level = level;
  }
  /**
   * True if row has child rows
   */
  hasChildren() {
    return !!this.children && !!this.children.length;
  }
};
var _NbTreeGridFilterService = class _NbTreeGridFilterService {
  filter(query, data) {
    if (!query) {
      return data;
    }
    return data.reduce((filtered, node) => {
      let filteredChildren;
      if (node.children) {
        filteredChildren = this.filter(query, node.children);
        node.children = filteredChildren;
      }
      node.expanded = false;
      if (filteredChildren && filteredChildren.length) {
        node.expanded = true;
        filtered.push(node);
      } else if (this.filterPredicate(node.data, query)) {
        filtered.push(node);
      }
      return filtered;
    }, []);
  }
  filterPredicate(data, searchQuery) {
    const preparedQuery = searchQuery.trim().toLocaleLowerCase();
    for (const val of Object.values(data)) {
      const preparedVal = `${val}`.trim().toLocaleLowerCase();
      if (preparedVal.includes(preparedQuery)) {
        return true;
      }
    }
    return false;
  }
};
_NbTreeGridFilterService.ɵfac = function NbTreeGridFilterService_Factory(t) {
  return new (t || _NbTreeGridFilterService)();
};
_NbTreeGridFilterService.ɵprov = ɵɵdefineInjectable({
  token: _NbTreeGridFilterService,
  factory: _NbTreeGridFilterService.ɵfac
});
var NbTreeGridFilterService = _NbTreeGridFilterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFilterService, [{
    type: Injectable
  }], null, null);
})();
var NbSortDirection;
(function(NbSortDirection2) {
  NbSortDirection2["ASCENDING"] = "asc";
  NbSortDirection2["DESCENDING"] = "desc";
  NbSortDirection2["NONE"] = "";
})(NbSortDirection || (NbSortDirection = {}));
var sortDirections = [NbSortDirection.ASCENDING, NbSortDirection.DESCENDING, NbSortDirection.NONE];
var _NbSortDirective = class _NbSortDirective {
  constructor() {
    this.sort = new EventEmitter();
  }
  emitSort(sortRequest) {
    if (this.sortable && this.sortable.sort) {
      this.sortable.sort(sortRequest);
    }
    this.sort.emit(sortRequest);
  }
};
_NbSortDirective.ɵfac = function NbSortDirective_Factory(t) {
  return new (t || _NbSortDirective)();
};
_NbSortDirective.ɵdir = ɵɵdefineDirective({
  type: _NbSortDirective,
  selectors: [["", "nbSort", ""]],
  inputs: {
    sortable: [InputFlags.None, "nbSort", "sortable"]
  },
  outputs: {
    sort: "sort"
  }
});
var NbSortDirective = _NbSortDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSort]"
    }]
  }], null, {
    sortable: [{
      type: Input,
      args: ["nbSort"]
    }],
    sort: [{
      type: Output
    }]
  });
})();
var _NbSortHeaderIconDirective = class _NbSortHeaderIconDirective {
};
_NbSortHeaderIconDirective.ɵfac = function NbSortHeaderIconDirective_Factory(t) {
  return new (t || _NbSortHeaderIconDirective)();
};
_NbSortHeaderIconDirective.ɵdir = ɵɵdefineDirective({
  type: _NbSortHeaderIconDirective,
  selectors: [["", "nbSortHeaderIcon", ""]]
});
var NbSortHeaderIconDirective = _NbSortHeaderIconDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortHeaderIconDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSortHeaderIcon]"
    }]
  }], null, null);
})();
var _NbSortIconComponent = class _NbSortIconComponent {
  constructor() {
    this.direction = NbSortDirection.NONE;
  }
  isAscending() {
    return this.direction === NbSortDirection.ASCENDING;
  }
  isDescending() {
    return this.direction === NbSortDirection.DESCENDING;
  }
  isDirectionSet() {
    return this.isAscending() || this.isDescending();
  }
};
_NbSortIconComponent.ɵfac = function NbSortIconComponent_Factory(t) {
  return new (t || _NbSortIconComponent)();
};
_NbSortIconComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSortIconComponent,
  selectors: [["nb-sort-icon"]],
  inputs: {
    direction: "direction"
  },
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
  template: function NbSortIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbSortIconComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isDirectionSet());
    }
  },
  dependencies: [NgIf, NbIconComponent],
  encapsulation: 2
});
var NbSortIconComponent = _NbSortIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortIconComponent, [{
    type: Component,
    args: [{
      selector: "nb-sort-icon",
      template: `
    <ng-container *ngIf="isDirectionSet()">
      <nb-icon *ngIf="isAscending()" icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
      <nb-icon *ngIf="isDescending()" icon="chevron-up-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </ng-container>
  `
    }]
  }], null, {
    direction: [{
      type: Input
    }]
  });
})();
var _NbSortHeaderComponent = class _NbSortHeaderComponent {
  /**
   * Disable sort header
   */
  set disabled(value) {
    this.disabledValue = convertToBoolProperty(value);
  }
  get disabled() {
    return this.disabledValue;
  }
  sortIfEnabled() {
    if (!this.disabled) {
      this.sortData();
    }
  }
  constructor(sort, columnDef) {
    this.sort = sort;
    this.columnDef = columnDef;
    this.disabledValue = false;
  }
  isAscending() {
    return this.direction === NbSortDirection.ASCENDING;
  }
  isDescending() {
    return this.direction === NbSortDirection.DESCENDING;
  }
  sortData() {
    const sortRequest = this.createSortRequest();
    this.sort.emitSort(sortRequest);
  }
  getIconContext() {
    return {
      $implicit: this.direction,
      isAscending: this.isAscending(),
      isDescending: this.isDescending(),
      isNone: !this.isAscending() && !this.isDescending()
    };
  }
  getDisabledAttributeValue() {
    return this.disabled ? "" : null;
  }
  createSortRequest() {
    this.direction = this.getNextDirection();
    return {
      direction: this.direction,
      column: this.columnDef.name
    };
  }
  getNextDirection() {
    const sortDirectionCycle = sortDirections;
    let nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
    if (nextDirectionIndex >= sortDirectionCycle.length) {
      nextDirectionIndex = 0;
    }
    return sortDirectionCycle[nextDirectionIndex];
  }
};
_NbSortHeaderComponent.ɵfac = function NbSortHeaderComponent_Factory(t) {
  return new (t || _NbSortHeaderComponent)(ɵɵdirectiveInject(NbSortDirective), ɵɵdirectiveInject(NB_SORT_HEADER_COLUMN_DEF));
};
_NbSortHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSortHeaderComponent,
  selectors: [["", "nbSortHeader", ""]],
  contentQueries: function NbSortHeaderComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbSortHeaderIconDirective, 5, TemplateRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sortIcon = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function NbSortHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbSortHeaderComponent_click_HostBindingHandler() {
        return ctx.sortIfEnabled();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("disabled", ctx.disabled);
    }
  },
  inputs: {
    direction: [InputFlags.None, "nbSortHeader", "direction"],
    disabled: "disabled"
  },
  attrs: _c56,
  ngContentSelectors: _c03,
  decls: 5,
  vars: 5,
  consts: [["customIcon", ""], ["type", "button", 1, "nb-tree-grid-header-change-sort-button", 3, "click"], [3, "direction", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "direction"]],
  template: function NbSortHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 1);
      ɵɵlistener("click", function NbSortHeaderComponent_Template_button_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.sortData());
      });
      ɵɵprojection(1);
      ɵɵelementEnd();
      ɵɵtemplate(2, NbSortHeaderComponent_nb_sort_icon_2_Template, 1, 1, "nb-sort-icon", 2)(3, NbSortHeaderComponent_ng_template_3_Template, 0, 0, "ng-template", 3, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const customIcon_r3 = ɵɵreference(4);
      ɵɵattribute("disabled", ctx.getDisabledAttributeValue());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.sortIcon)("ngIfElse", customIcon_r3);
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", ctx.sortIcon)("ngTemplateOutletContext", ctx.getIconContext());
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NbSortIconComponent],
  encapsulation: 2
});
var NbSortHeaderComponent = _NbSortHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortHeaderComponent, [{
    type: Component,
    args: [{
      selector: "[nbSortHeader]",
      template: `
    <button
      class="nb-tree-grid-header-change-sort-button"
      type="button"
      [attr.disabled]="getDisabledAttributeValue()"
      (click)="sortData()">
      <ng-content></ng-content>
    </button>
    <nb-sort-icon *ngIf="!sortIcon; else customIcon" [direction]="direction"></nb-sort-icon>
    <ng-template #customIcon [ngTemplateOutlet]="sortIcon" [ngTemplateOutletContext]="getIconContext()"></ng-template>
  `
    }]
  }], () => [{
    type: NbSortDirective
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_SORT_HEADER_COLUMN_DEF]
    }]
  }], {
    sortIcon: [{
      type: ContentChild,
      args: [NbSortHeaderIconDirective, {
        read: TemplateRef
      }]
    }],
    direction: [{
      type: Input,
      args: ["nbSortHeader"]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    sortIfEnabled: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbTreeGridSortService = class _NbTreeGridSortService {
  sort(request, data) {
    if (!request) {
      return data;
    }
    const sorted = data.sort((na, nb) => this.comparator(request, na, nb));
    for (const node of data) {
      if (node.children) {
        node.children = this.sort(request, node.children);
      }
    }
    return sorted;
  }
  comparator(request, na, nb) {
    const key = request.column;
    const dir = request.direction;
    const a = na.data[key];
    const b = nb.data[key];
    let res = 0;
    if (a > b) {
      res = 1;
    }
    if (a < b) {
      res = -1;
    }
    return dir === NbSortDirection.ASCENDING ? res : res * -1;
  }
};
_NbTreeGridSortService.ɵfac = function NbTreeGridSortService_Factory(t) {
  return new (t || _NbTreeGridSortService)();
};
_NbTreeGridSortService.ɵprov = ɵɵdefineInjectable({
  token: _NbTreeGridSortService,
  factory: _NbTreeGridSortService.ɵfac
});
var NbTreeGridSortService = _NbTreeGridSortService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridSortService, [{
    type: Injectable
  }], null, null);
})();
var _NbTreeGridService = class _NbTreeGridService {
  expand(data, row, options = {}) {
    const node = this.find(data, row);
    node.expanded = true;
    if (options.deep && node.hasChildren()) {
      node.children.forEach((n) => this.expand(data, n.data, options));
    }
  }
  collapse(data, row, options = {}) {
    const node = this.find(data, row);
    node.expanded = false;
    if (options.deep && node.hasChildren()) {
      node.children.forEach((n) => this.collapse(data, n.data, options));
    }
  }
  toggle(data, row, options = {}) {
    const node = this.find(data, row);
    if (node.expanded) {
      this.collapse(data, row, options);
    } else {
      this.expand(data, row, options);
    }
  }
  find(data, row) {
    const toCheck = [...data];
    for (const node of toCheck) {
      if (node.data === row) {
        return node;
      }
      if (node.hasChildren()) {
        toCheck.push(...node.children);
      }
    }
    return void 0;
  }
};
_NbTreeGridService.ɵfac = function NbTreeGridService_Factory(t) {
  return new (t || _NbTreeGridService)();
};
_NbTreeGridService.ɵprov = ɵɵdefineInjectable({
  token: _NbTreeGridService,
  factory: _NbTreeGridService.ɵfac
});
var NbTreeGridService = _NbTreeGridService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridService, [{
    type: Injectable
  }], null, null);
})();
var _NbTreeGridDataService = class _NbTreeGridDataService {
  constructor() {
    this.defaultGetters = {
      dataGetter: (node) => node.data,
      childrenGetter: (d) => d.children || void 0,
      expandedGetter: (d) => !!d.expanded
    };
  }
  toPresentationNodes(nodes, customGetters, level = NB_DEFAULT_ROW_LEVEL) {
    const getters = __spreadValues(__spreadValues({}, this.defaultGetters), customGetters);
    return this.mapNodes(nodes, getters, level);
  }
  mapNodes(nodes, getters, level) {
    const {
      dataGetter,
      childrenGetter,
      expandedGetter
    } = getters;
    return nodes.map((node) => {
      const childrenNodes = childrenGetter(node);
      let children;
      if (childrenNodes) {
        children = this.toPresentationNodes(childrenNodes, getters, level + 1);
      }
      return new NbTreeGridPresentationNode(dataGetter(node), children, expandedGetter(node), level);
    });
  }
  flattenExpanded(nodes) {
    return nodes.reduce((res, node) => {
      res.push(node);
      if (node.expanded && node.hasChildren()) {
        res.push(...this.flattenExpanded(node.children));
      }
      return res;
    }, []);
  }
  copy(nodes) {
    return nodes.map((node) => {
      let children;
      if (node.hasChildren()) {
        children = this.copy(node.children);
      }
      return new NbTreeGridPresentationNode(node.data, children, node.expanded, node.level);
    });
  }
};
_NbTreeGridDataService.ɵfac = function NbTreeGridDataService_Factory(t) {
  return new (t || _NbTreeGridDataService)();
};
_NbTreeGridDataService.ɵprov = ɵɵdefineInjectable({
  token: _NbTreeGridDataService,
  factory: _NbTreeGridDataService.ɵfac
});
var NbTreeGridDataService = _NbTreeGridDataService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridDataService, [{
    type: Injectable
  }], null, null);
})();
var NbTreeGridDataSource = class extends NbDataSource {
  constructor(sortService, filterService, treeGridService, treeGridDataService) {
    super();
    this.sortService = sortService;
    this.filterService = filterService;
    this.treeGridService = treeGridService;
    this.treeGridDataService = treeGridDataService;
    this.renderData = new BehaviorSubject([]);
    this.filterRequest = new BehaviorSubject("");
    this.sortRequest = new BehaviorSubject(null);
  }
  setData(data, customGetters) {
    let presentationData = [];
    if (data) {
      presentationData = this.treeGridDataService.toPresentationNodes(data, customGetters);
    }
    this.data = new BehaviorSubject(presentationData);
    this.updateChangeSubscription();
  }
  connect(collectionViewer) {
    return this.renderData;
  }
  disconnect(collectionViewer) {
  }
  expand(row) {
    this.treeGridService.expand(this.data.value, row);
    this.data.next(this.data.value);
  }
  collapse(row) {
    this.treeGridService.collapse(this.data.value, row);
    this.data.next(this.data.value);
  }
  toggle(row, options) {
    this.treeGridService.toggle(this.data.value, row, options);
    this.data.next(this.data.value);
  }
  toggleByIndex(dataIndex, options) {
    const node = this.renderData.value && this.renderData.value[dataIndex];
    if (node) {
      this.toggle(node.data, options);
    }
  }
  getLevel(rowIndex) {
    const row = this.renderData.value[rowIndex];
    return row ? row.level : NB_DEFAULT_ROW_LEVEL;
  }
  sort(sortRequest) {
    this.sortRequest.next(sortRequest);
  }
  filter(searchQuery) {
    this.filterRequest.next(searchQuery);
  }
  updateChangeSubscription() {
    const dataStream = this.data;
    const filteredData = combineLatest([dataStream, this.filterRequest]).pipe(map(([data]) => this.treeGridDataService.copy(data)), map((data) => this.filterData(data)));
    const sortedData = combineLatest([filteredData, this.sortRequest]).pipe(map(([data]) => this.sortData(data)));
    sortedData.pipe(map((data) => this.treeGridDataService.flattenExpanded(data))).subscribe((data) => this.renderData.next(data));
  }
  filterData(data) {
    return this.filterService.filter(this.filterRequest.value, data);
  }
  sortData(data) {
    return this.sortService.sort(this.sortRequest.value, data);
  }
};
var _NbTreeGridDataSourceBuilder = class _NbTreeGridDataSourceBuilder {
  constructor(filterService, sortService, treeGridService, treeGridDataService) {
    this.filterService = filterService;
    this.sortService = sortService;
    this.treeGridService = treeGridService;
    this.treeGridDataService = treeGridDataService;
  }
  create(data, customGetters) {
    const dataSource = new NbTreeGridDataSource(this.sortService, this.filterService, this.treeGridService, this.treeGridDataService);
    dataSource.setData(data, customGetters);
    return dataSource;
  }
};
_NbTreeGridDataSourceBuilder.ɵfac = function NbTreeGridDataSourceBuilder_Factory(t) {
  return new (t || _NbTreeGridDataSourceBuilder)(ɵɵinject(NbTreeGridFilterService), ɵɵinject(NbTreeGridSortService), ɵɵinject(NbTreeGridService), ɵɵinject(NbTreeGridDataService));
};
_NbTreeGridDataSourceBuilder.ɵprov = ɵɵdefineInjectable({
  token: _NbTreeGridDataSourceBuilder,
  factory: _NbTreeGridDataSourceBuilder.ɵfac
});
var NbTreeGridDataSourceBuilder = _NbTreeGridDataSourceBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridDataSourceBuilder, [{
    type: Injectable
  }], () => [{
    type: NbTreeGridFilterService
  }, {
    type: NbTreeGridSortService
  }, {
    type: NbTreeGridService
  }, {
    type: NbTreeGridDataService
  }], null);
})();
var NB_TREE_GRID = new InjectionToken("NB_TREE_GRID");
var _NbColumnsService = class _NbColumnsService {
  constructor(differs) {
    this.differs = differs;
    this.columnHide$ = new Subject();
    this.columnShow$ = new Subject();
  }
  setColumns(columns) {
    if (!this.changesDiffer) {
      this.changesDiffer = this.differs.find(columns || []).create();
    }
    if (this.changesDiffer.diff(columns)) {
      this.allColumns = Array.from(columns);
      this.visibleColumns = Array.from(columns);
    }
  }
  getVisibleColumns() {
    return this.visibleColumns;
  }
  hideColumn(column) {
    const toRemove = this.visibleColumns.indexOf(column);
    if (toRemove > -1) {
      this.visibleColumns.splice(toRemove, 1);
      this.columnHide$.next();
    }
  }
  showColumn(column) {
    if (this.visibleColumns.includes(column)) {
      return;
    }
    this.visibleColumns.splice(this.findInsertIndex(column), 0, column);
    this.columnShow$.next();
  }
  onColumnsChange() {
    return merge(this.columnShow$, this.columnHide$);
  }
  findInsertIndex(column) {
    const initialIndex = this.allColumns.indexOf(column);
    if (initialIndex === 0 || !this.visibleColumns.length) {
      return 0;
    }
    if (initialIndex === this.allColumns.length - 1) {
      return this.visibleColumns.length;
    }
    const leftSiblingIndex = initialIndex - 1;
    for (let i = leftSiblingIndex; i >= 0; i--) {
      const leftSibling = this.allColumns[i];
      const index = this.visibleColumns.indexOf(leftSibling);
      if (index !== -1) {
        return index + 1;
      }
    }
    const rightSiblingIndex = initialIndex + 1;
    for (let i = rightSiblingIndex; i < this.allColumns.length; i++) {
      const rightSibling = this.allColumns[i];
      const index = this.visibleColumns.indexOf(rightSibling);
      if (index !== -1) {
        return index;
      }
    }
    throw new Error(`Can't restore column position.`);
  }
};
_NbColumnsService.ɵfac = function NbColumnsService_Factory(t) {
  return new (t || _NbColumnsService)(ɵɵinject(IterableDiffers));
};
_NbColumnsService.ɵprov = ɵɵdefineInjectable({
  token: _NbColumnsService,
  factory: _NbColumnsService.ɵfac
});
var NbColumnsService = _NbColumnsService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbColumnsService, [{
    type: Injectable
  }], () => [{
    type: IterableDiffers
  }], null);
})();
var _NbTreeGridComponent = class _NbTreeGridComponent extends NbTable {
  constructor(dataSourceBuilder, differs, changeDetectorRef, elementRef, role, dir, document2, platform, window2, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener) {
    super(differs, changeDetectorRef, elementRef, role, dir, document2, platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener);
    this.dataSourceBuilder = dataSourceBuilder;
    this.window = window2;
    this._viewRepeater = _viewRepeater;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._stickyPositioningListener = _stickyPositioningListener;
    this.destroy$ = new Subject();
    this.levelPadding = "";
    this.equalColumnsWidthValue = false;
    this.treeClass = true;
    this.platform = platform;
  }
  /**
   * The table's data
   * @param data
   * @type {<T>[] | NbTreeGridDataSource}
   */
  set source(data) {
    if (!data) {
      return;
    }
    if (data instanceof NbTreeGridDataSource) {
      this._source = data;
    } else {
      this._source = this.dataSourceBuilder.create(data);
    }
    this.dataSource = this._source;
  }
  /**
   * Make all columns equal width. False by default.
   */
  set equalColumnsWidth(value) {
    this.equalColumnsWidthValue = convertToBoolProperty(value);
  }
  get equalColumnsWidth() {
    return this.equalColumnsWidthValue;
  }
  ngAfterViewInit() {
    this.checkDefsCount();
    const rowsChange$ = merge(this._contentRowDefs.changes, this._contentHeaderRowDefs.changes, this._contentFooterRowDefs.changes);
    rowsChange$.pipe(takeUntil(this.destroy$)).subscribe(() => this.checkDefsCount());
    if (this.platform.isBrowser) {
      this.updateVisibleColumns();
      const windowResize$ = fromEvent(this.window, "resize").pipe(debounceTime(50));
      merge(rowsChange$, this._contentColumnDefs.changes, windowResize$).pipe(takeUntil(this.destroy$)).subscribe(() => this.updateVisibleColumns());
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  toggleRow(row, options) {
    const context = this.getRowContext(row);
    this._source.toggle(context.$implicit.data, options);
  }
  toggleCellRow(cell) {
    const context = this.getCellContext(cell);
    this._source.toggle(context.$implicit.data);
  }
  getColumnWidth() {
    if (this.equalColumnsWidth) {
      return `${100 / this.getColumnsCount()}%`;
    }
    return "";
  }
  getCellLevel(cell, columnName) {
    if (this.isFirstColumn(columnName)) {
      return this.getCellContext(cell).$implicit.level;
    }
    return NB_DEFAULT_ROW_LEVEL;
  }
  getRowContext(row) {
    return this.getContextByRowEl(row.elementRef.nativeElement);
  }
  getCellContext(cell) {
    return this.getContextByCellEl(cell.elementRef.nativeElement);
  }
  getContextByCellEl(cellEl) {
    return this.getContextByRowEl(cellEl.parentElement);
  }
  getContextByRowEl(rowEl) {
    const rowsContainer = this._rowOutlet.viewContainer;
    for (let i = 0; i < rowsContainer.length; i++) {
      const rowViewRef = rowsContainer.get(i);
      if (rowViewRef.rootNodes.includes(rowEl)) {
        return rowViewRef.context;
      }
    }
    return void 0;
  }
  getColumns() {
    let rowDef;
    if (this._contentHeaderRowDefs.length) {
      rowDef = this._contentHeaderRowDefs.first;
    } else {
      rowDef = this._contentRowDefs.first;
    }
    return Array.from(rowDef.getVisibleColumns() || []);
  }
  getColumnsCount() {
    return this.getColumns().length;
  }
  isFirstColumn(columnName) {
    return this.getColumns()[0] === columnName;
  }
  checkDefsCount() {
    if (this._contentRowDefs.length > 1) {
      throw new Error(`Found multiple row definitions`);
    }
    if (this._contentHeaderRowDefs.length > 1) {
      throw new Error(`Found multiple header row definitions`);
    }
    if (this._contentFooterRowDefs.length > 1) {
      throw new Error(`Found multiple footer row definitions`);
    }
  }
  updateVisibleColumns() {
    const width = this.window.innerWidth;
    const columnDefs = this._contentColumnDefs;
    const columnsToHide = columnDefs.filter((col) => col.shouldHide(width)).map((col) => col.name);
    const columnsToShow = columnDefs.filter((col) => col.shouldShow(width)).map((col) => col.name);
    if (!columnsToHide.length && !columnsToShow.length) {
      return;
    }
    const rowDefs = [this._contentHeaderRowDefs.first, this._contentRowDefs.first, this._contentFooterRowDefs.first].filter((d) => !!d);
    for (const rowDef of rowDefs) {
      for (const column of columnsToHide) {
        rowDef.hideColumn(column);
      }
      for (const column of columnsToShow) {
        rowDef.showColumn(column);
      }
    }
  }
};
_NbTreeGridComponent.ɵfac = function NbTreeGridComponent_Factory(t) {
  return new (t || _NbTreeGridComponent)(ɵɵdirectiveInject(NbTreeGridDataSourceBuilder), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵinjectAttribute("role"), ɵɵdirectiveInject(NbDirectionality), ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPlatform), ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(NB_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(NB_COALESCED_STYLE_SCHEDULER), ɵɵdirectiveInject(NbViewportRulerAdapter), ɵɵdirectiveInject(NB_STICKY_POSITIONING_LISTENER, 12));
};
_NbTreeGridComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTreeGridComponent,
  selectors: [["table", "nbTreeGrid", ""]],
  hostVars: 2,
  hostBindings: function NbTreeGridComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("nb-tree-grid", ctx.treeClass);
    }
  },
  inputs: {
    source: [InputFlags.None, "nbTreeGrid", "source"],
    levelPadding: "levelPadding",
    equalColumnsWidth: "equalColumnsWidth"
  },
  features: [ɵɵProvidersFeature([{
    provide: NB_TREE_GRID,
    useExisting: _NbTreeGridComponent
  }, NbColumnsService, ...NB_TABLE_PROVIDERS]), ɵɵInheritDefinitionFeature],
  attrs: _c57,
  decls: 4,
  vars: 0,
  consts: [["nbHeaderRowOutlet", ""], ["nbRowOutlet", ""], ["nbNoDataRowOutlet", ""], ["nbFooterRowOutlet", ""]],
  template: function NbTreeGridComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0)(1, 1)(2, 2)(3, 3);
    }
  },
  dependencies: [NbDataRowOutletDirective, NbHeaderRowOutletDirective, NbFooterRowOutletDirective, NbNoDataRowOutletDirective],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}  .nb-tree-grid-cell,   .nb-tree-grid-header-cell,   .nb-tree-grid-footer-cell{overflow:hidden}"]
});
var NbTreeGridComponent = _NbTreeGridComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridComponent, [{
    type: Component,
    args: [{
      selector: "table[nbTreeGrid]",
      template: NB_TABLE_TEMPLATE,
      providers: [{
        provide: NB_TREE_GRID,
        useExisting: NbTreeGridComponent
      }, NbColumnsService, ...NB_TABLE_PROVIDERS],
      styles: ["/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}::ng-deep .nb-tree-grid-cell,::ng-deep .nb-tree-grid-header-cell,::ng-deep .nb-tree-grid-footer-cell{overflow:hidden}\n"]
    }]
  }], () => [{
    type: NbTreeGridDataSourceBuilder
  }, {
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["role"]
    }]
  }, {
    type: NbDirectionality
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [NB_STICKY_POSITIONING_LISTENER]
    }]
  }], {
    source: [{
      type: Input,
      args: ["nbTreeGrid"]
    }],
    levelPadding: [{
      type: Input
    }],
    equalColumnsWidth: [{
      type: Input
    }],
    treeClass: [{
      type: HostBinding,
      args: ["class.nb-tree-grid"]
    }]
  });
})();
var _NbTreeGridRowDefDirective = class _NbTreeGridRowDefDirective extends NbRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
};
_NbTreeGridRowDefDirective.ɵfac = function NbTreeGridRowDefDirective_Factory(t) {
  return new (t || _NbTreeGridRowDefDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(NbColumnsService));
};
_NbTreeGridRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridRowDefDirective,
  selectors: [["", "nbTreeGridRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbTreeGridRowDefColumns", "columns"]
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkRowDef,
    useExisting: _NbTreeGridRowDefDirective
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var NbTreeGridRowDefDirective = _NbTreeGridRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridRowDef]",
      providers: [{
        provide: NbCdkRowDef,
        useExisting: NbTreeGridRowDefDirective
      }]
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridRowDefColumns"]
    }]
  });
})();
var _NbTreeGridHeaderRowDefDirective = class _NbTreeGridHeaderRowDefDirective extends NbHeaderRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
};
_NbTreeGridHeaderRowDefDirective.ɵfac = function NbTreeGridHeaderRowDefDirective_Factory(t) {
  return new (t || _NbTreeGridHeaderRowDefDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(NbColumnsService));
};
_NbTreeGridHeaderRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridHeaderRowDefDirective,
  selectors: [["", "nbTreeGridHeaderRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbTreeGridHeaderRowDef", "columns"]
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkHeaderRowDef,
    useExisting: _NbTreeGridHeaderRowDefDirective
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var NbTreeGridHeaderRowDefDirective = _NbTreeGridHeaderRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridHeaderRowDef]",
      providers: [{
        provide: NbCdkHeaderRowDef,
        useExisting: NbTreeGridHeaderRowDefDirective
      }]
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridHeaderRowDef"]
    }]
  });
})();
var _NbTreeGridFooterRowDefDirective = class _NbTreeGridFooterRowDefDirective extends NbFooterRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
};
_NbTreeGridFooterRowDefDirective.ɵfac = function NbTreeGridFooterRowDefDirective_Factory(t) {
  return new (t || _NbTreeGridFooterRowDefDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(NbColumnsService));
};
_NbTreeGridFooterRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridFooterRowDefDirective,
  selectors: [["", "nbTreeGridFooterRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbTreeGridFooterRowDef", "columns"]
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkFooterRowDef,
    useExisting: _NbTreeGridFooterRowDefDirective
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var NbTreeGridFooterRowDefDirective = _NbTreeGridFooterRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridFooterRowDef]",
      providers: [{
        provide: NbCdkFooterRowDef,
        useExisting: NbTreeGridFooterRowDefDirective
      }]
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridFooterRowDef"]
    }]
  });
})();
var _NbTreeGridCellDefDirective = class _NbTreeGridCellDefDirective extends NbCellDefDirective {
};
_NbTreeGridCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridCellDefDirective_BaseFactory;
  return function NbTreeGridCellDefDirective_Factory(t) {
    return (ɵNbTreeGridCellDefDirective_BaseFactory || (ɵNbTreeGridCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridCellDefDirective)))(t || _NbTreeGridCellDefDirective);
  };
})();
_NbTreeGridCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridCellDefDirective,
  selectors: [["", "nbTreeGridCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: NbCdkCellDef,
    useExisting: _NbTreeGridCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridCellDefDirective = _NbTreeGridCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridCellDef]",
      providers: [{
        provide: NbCdkCellDef,
        useExisting: NbTreeGridCellDefDirective
      }]
    }]
  }], null, null);
})();
var _NbTreeGridHeaderCellDefDirective = class _NbTreeGridHeaderCellDefDirective extends NbHeaderCellDefDirective {
};
_NbTreeGridHeaderCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridHeaderCellDefDirective_BaseFactory;
  return function NbTreeGridHeaderCellDefDirective_Factory(t) {
    return (ɵNbTreeGridHeaderCellDefDirective_BaseFactory || (ɵNbTreeGridHeaderCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridHeaderCellDefDirective)))(t || _NbTreeGridHeaderCellDefDirective);
  };
})();
_NbTreeGridHeaderCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridHeaderCellDefDirective,
  selectors: [["", "nbTreeGridHeaderCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: NbCdkHeaderCellDef,
    useExisting: _NbTreeGridHeaderCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridHeaderCellDefDirective = _NbTreeGridHeaderCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridHeaderCellDef]",
      providers: [{
        provide: NbCdkHeaderCellDef,
        useExisting: NbTreeGridHeaderCellDefDirective
      }]
    }]
  }], null, null);
})();
var _NbTreeGridFooterCellDefDirective = class _NbTreeGridFooterCellDefDirective extends NbFooterCellDefDirective {
};
_NbTreeGridFooterCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridFooterCellDefDirective_BaseFactory;
  return function NbTreeGridFooterCellDefDirective_Factory(t) {
    return (ɵNbTreeGridFooterCellDefDirective_BaseFactory || (ɵNbTreeGridFooterCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridFooterCellDefDirective)))(t || _NbTreeGridFooterCellDefDirective);
  };
})();
_NbTreeGridFooterCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridFooterCellDefDirective,
  selectors: [["", "nbTreeGridFooterCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: NbCdkFooterCellDef,
    useExisting: _NbTreeGridFooterCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridFooterCellDefDirective = _NbTreeGridFooterCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridFooterCellDef]",
      providers: [{
        provide: NbCdkFooterCellDef,
        useExisting: NbTreeGridFooterCellDefDirective
      }]
    }]
  }], null, null);
})();
var NB_ROW_DOUBLE_CLICK_DELAY = 200;
var _NbTreeGridRowComponent = class _NbTreeGridRowComponent extends NbRowComponent {
  toggleIfEnabledNode() {
    if (!this.clickToToggle) {
      return;
    }
    timer(NB_ROW_DOUBLE_CLICK_DELAY).pipe(take(1), takeUntil(this.doubleClick$)).subscribe(() => this.tree.toggleRow(this));
  }
  toggleIfEnabledNodeDeep() {
    if (!this.clickToToggle) {
      return;
    }
    this.doubleClick$.next();
    this.tree.toggleRow(this, {
      deep: true
    });
  }
  constructor(tree, elementRef) {
    super();
    this.elementRef = elementRef;
    this.doubleClick$ = new Subject();
    this.doubleClickDelay = NB_ROW_DOUBLE_CLICK_DELAY;
    this.clickToToggle = true;
    this.tree = tree;
  }
  ngOnDestroy() {
    this.doubleClick$.complete();
  }
};
_NbTreeGridRowComponent.ɵfac = function NbTreeGridRowComponent_Factory(t) {
  return new (t || _NbTreeGridRowComponent)(ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(ElementRef));
};
_NbTreeGridRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTreeGridRowComponent,
  selectors: [["tr", "nbTreeGridRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-tree-grid-row"],
  hostBindings: function NbTreeGridRowComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbTreeGridRowComponent_click_HostBindingHandler() {
        return ctx.toggleIfEnabledNode();
      })("dblclick", function NbTreeGridRowComponent_dblclick_HostBindingHandler() {
        return ctx.toggleIfEnabledNodeDeep();
      });
    }
  },
  inputs: {
    doubleClickDelay: "doubleClickDelay",
    clickToToggle: "clickToToggle"
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkRow,
    useExisting: _NbTreeGridRowComponent
  }]), ɵɵInheritDefinitionFeature],
  attrs: _c58,
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbTreeGridRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbTreeGridRowComponent = _NbTreeGridRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridRow]",
      template: `<ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkRow,
        useExisting: NbTreeGridRowComponent
      }]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: ElementRef
  }], {
    doubleClickDelay: [{
      type: Input
    }],
    clickToToggle: [{
      type: Input
    }],
    toggleIfEnabledNode: [{
      type: HostListener,
      args: ["click"]
    }],
    toggleIfEnabledNodeDeep: [{
      type: HostListener,
      args: ["dblclick"]
    }]
  });
})();
var _NbTreeGridHeaderRowComponent = class _NbTreeGridHeaderRowComponent extends NbHeaderRowComponent {
};
_NbTreeGridHeaderRowComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridHeaderRowComponent_BaseFactory;
  return function NbTreeGridHeaderRowComponent_Factory(t) {
    return (ɵNbTreeGridHeaderRowComponent_BaseFactory || (ɵNbTreeGridHeaderRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridHeaderRowComponent)))(t || _NbTreeGridHeaderRowComponent);
  };
})();
_NbTreeGridHeaderRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTreeGridHeaderRowComponent,
  selectors: [["tr", "nbTreeGridHeaderRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-tree-grid-header-row"],
  features: [ɵɵProvidersFeature([{
    provide: NbCdkHeaderRow,
    useExisting: _NbTreeGridHeaderRowComponent
  }]), ɵɵInheritDefinitionFeature],
  attrs: _c59,
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbTreeGridHeaderRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbTreeGridHeaderRowComponent = _NbTreeGridHeaderRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridHeaderRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-header-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkHeaderRow,
        useExisting: NbTreeGridHeaderRowComponent
      }]
    }]
  }], null, null);
})();
var _NbTreeGridFooterRowComponent = class _NbTreeGridFooterRowComponent extends NbFooterRowComponent {
};
_NbTreeGridFooterRowComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridFooterRowComponent_BaseFactory;
  return function NbTreeGridFooterRowComponent_Factory(t) {
    return (ɵNbTreeGridFooterRowComponent_BaseFactory || (ɵNbTreeGridFooterRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridFooterRowComponent)))(t || _NbTreeGridFooterRowComponent);
  };
})();
_NbTreeGridFooterRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTreeGridFooterRowComponent,
  selectors: [["tr", "nbTreeGridFooterRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-tree-grid-footer-row"],
  features: [ɵɵProvidersFeature([{
    provide: NbCdkFooterRow,
    useExisting: _NbTreeGridFooterRowComponent
  }]), ɵɵInheritDefinitionFeature],
  attrs: _c60,
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbTreeGridFooterRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbTreeGridFooterRowComponent = _NbTreeGridFooterRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridFooterRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-footer-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkFooterRow,
        useExisting: NbTreeGridFooterRowComponent
      }]
    }]
  }], null, null);
})();
var _NbTreeGridColumnDefDirective = class _NbTreeGridColumnDefDirective extends NbColumnDefDirective {
  constructor() {
    super(...arguments);
    this.hideOnValue = null;
    this.showOnValue = null;
  }
  /**
   * Column name
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._setNameInput(value);
  }
  /**
   * Amount of pixels of viewport at which column should be hidden.
   * type number
   */
  get hideOn() {
    return this.hideOnValue;
  }
  set hideOn(value) {
    this.hideOnValue = !value && value !== 0 ? null : parseInt(value, 10);
  }
  /**
   * Amount of pixels of viewport at which column should be shown.
   * type number
   */
  get showOn() {
    return this.showOnValue;
  }
  set showOn(value) {
    this.showOnValue = !value && value !== 0 ? null : parseInt(value, 10);
  }
  ngOnChanges() {
    if (this.hideOn != null && this.showOn != null) {
      throw new Error(`hideOn and showOn are mutually exclusive and can't be used simultaneously.`);
    }
  }
  shouldHide(width) {
    return !this.shouldShow(width);
  }
  shouldShow(width) {
    if (this.hideOn == null && this.showOn == null) {
      return true;
    }
    if (this.hideOn != null) {
      return width > this.hideOn;
    }
    return width >= this.showOn;
  }
};
_NbTreeGridColumnDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridColumnDefDirective_BaseFactory;
  return function NbTreeGridColumnDefDirective_Factory(t) {
    return (ɵNbTreeGridColumnDefDirective_BaseFactory || (ɵNbTreeGridColumnDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridColumnDefDirective)))(t || _NbTreeGridColumnDefDirective);
  };
})();
_NbTreeGridColumnDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridColumnDefDirective,
  selectors: [["", "nbTreeGridColumnDef", ""]],
  inputs: {
    name: [InputFlags.None, "nbTreeGridColumnDef", "name"],
    hideOn: "hideOn",
    showOn: "showOn"
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkColumnDef,
    useExisting: _NbTreeGridColumnDefDirective
  }, {
    provide: NB_SORT_HEADER_COLUMN_DEF,
    useExisting: _NbTreeGridColumnDefDirective
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var NbTreeGridColumnDefDirective = _NbTreeGridColumnDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridColumnDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridColumnDef]",
      providers: [{
        provide: NbCdkColumnDef,
        useExisting: NbTreeGridColumnDefDirective
      }, {
        provide: NB_SORT_HEADER_COLUMN_DEF,
        useExisting: NbTreeGridColumnDefDirective
      }]
    }]
  }], null, {
    name: [{
      type: Input,
      args: ["nbTreeGridColumnDef"]
    }],
    hideOn: [{
      type: Input
    }],
    showOn: [{
      type: Input
    }]
  });
})();
var _NbTreeGridCellDirective = class _NbTreeGridCellDirective extends NbCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    if (this.latestWidth) {
      return this.latestWidth;
    }
    return null;
  }
  get leftPadding() {
    if (this.directionService.isLtr()) {
      return this.getStartPadding();
    }
    return null;
  }
  get rightPadding() {
    if (this.directionService.isRtl()) {
      return this.getStartPadding();
    }
    return null;
  }
  constructor(columnDef, elementRef, tree, platformId, window2, sanitizer, directionService, columnService, cd) {
    super(columnDef, elementRef);
    this.platformId = platformId;
    this.window = window2;
    this.sanitizer = sanitizer;
    this.directionService = directionService;
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.initialLeftPadding = "";
    this.initialRightPadding = "";
    this.tree = tree;
    this.columnDef = columnDef;
    this.elementRef = elementRef;
  }
  ngOnInit() {
    if (isPlatformBrowser(this.platformId)) {
      const style2 = this.window.getComputedStyle(this.elementRef.nativeElement);
      this.initialLeftPadding = style2.paddingLeft;
      this.initialRightPadding = style2.paddingRight;
    }
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  toggleRow() {
    this.tree.toggleCellRow(this);
  }
  get initialStartPadding() {
    return this.directionService.isLtr() ? this.initialLeftPadding : this.initialRightPadding;
  }
  getStartPadding() {
    const rowLevel = this.tree.getCellLevel(this, this.columnDef.name);
    if (rowLevel === NB_DEFAULT_ROW_LEVEL) {
      return null;
    }
    const nestingLevel = rowLevel + 1;
    let padding = "";
    if (this.tree.levelPadding) {
      padding = `calc(${this.tree.levelPadding} * ${nestingLevel})`;
    } else if (this.initialStartPadding) {
      padding = `calc(${this.initialStartPadding} * ${nestingLevel})`;
    }
    if (!padding) {
      return null;
    }
    return this.sanitizer.bypassSecurityTrustStyle(padding);
  }
};
_NbTreeGridCellDirective.ɵfac = function NbTreeGridCellDirective_Factory(t) {
  return new (t || _NbTreeGridCellDirective)(ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbColumnsService), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbTreeGridCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridCellDirective,
  selectors: [["td", "nbTreeGridCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-cell"],
  hostVars: 6,
  hostBindings: function NbTreeGridCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("width", ctx.columnWidth)("padding-left", ctx.leftPadding)("padding-right", ctx.rightPadding);
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkCell,
    useExisting: _NbTreeGridCellDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridCellDirective = _NbTreeGridCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridCellDirective, [{
    type: Directive,
    args: [{
      selector: "td[nbTreeGridCell]",
      host: {
        "class": "nb-tree-grid-cell",
        "role": "gridcell"
      },
      providers: [{
        provide: NbCdkCell,
        useExisting: NbTreeGridCellDirective
      }]
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: DomSanitizer
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }],
    leftPadding: [{
      type: HostBinding,
      args: ["style.padding-left"]
    }],
    rightPadding: [{
      type: HostBinding,
      args: ["style.padding-right"]
    }]
  });
})();
var _NbTreeGridHeaderCellDirective = class _NbTreeGridHeaderCellDirective extends NbHeaderCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    return this.latestWidth || null;
  }
  constructor(columnDef, elementRef, tree, columnService, cd) {
    super(columnDef, elementRef);
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.tree = tree;
  }
  ngOnInit() {
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbTreeGridHeaderCellDirective.ɵfac = function NbTreeGridHeaderCellDirective_Factory(t) {
  return new (t || _NbTreeGridHeaderCellDirective)(ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(NbColumnsService), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbTreeGridHeaderCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridHeaderCellDirective,
  selectors: [["th", "nbTreeGridHeaderCell", ""]],
  hostAttrs: ["role", "columnheader", 1, "nb-tree-grid-header-cell"],
  hostVars: 2,
  hostBindings: function NbTreeGridHeaderCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("width", ctx.columnWidth);
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkHeaderCell,
    useExisting: _NbTreeGridHeaderCellDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridHeaderCellDirective = _NbTreeGridHeaderCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderCellDirective, [{
    type: Directive,
    args: [{
      selector: "th[nbTreeGridHeaderCell]",
      host: {
        "class": "nb-tree-grid-header-cell",
        "role": "columnheader"
      },
      providers: [{
        provide: NbCdkHeaderCell,
        useExisting: NbTreeGridHeaderCellDirective
      }]
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }]
  });
})();
var _NbTreeGridFooterCellDirective = class _NbTreeGridFooterCellDirective extends NbFooterCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    return this.latestWidth || null;
  }
  constructor(columnDef, elementRef, tree, columnService, cd) {
    super(columnDef, elementRef);
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.tree = tree;
  }
  ngOnInit() {
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbTreeGridFooterCellDirective.ɵfac = function NbTreeGridFooterCellDirective_Factory(t) {
  return new (t || _NbTreeGridFooterCellDirective)(ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(NbColumnsService), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbTreeGridFooterCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridFooterCellDirective,
  selectors: [["td", "nbTreeGridFooterCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-footer-cell"],
  hostVars: 2,
  hostBindings: function NbTreeGridFooterCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("width", ctx.columnWidth);
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkFooterCell,
    useExisting: _NbTreeGridFooterCellDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridFooterCellDirective = _NbTreeGridFooterCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterCellDirective, [{
    type: Directive,
    args: [{
      selector: "td[nbTreeGridFooterCell]",
      host: {
        "class": "nb-tree-grid-footer-cell",
        "role": "gridcell"
      },
      providers: [{
        provide: NbCdkFooterCell,
        useExisting: NbTreeGridFooterCellDirective
      }]
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }]
  });
})();
var _NbFilterDirective = class _NbFilterDirective {
  filter(filterRequest) {
    this.filterable.filter(filterRequest);
  }
};
_NbFilterDirective.ɵfac = function NbFilterDirective_Factory(t) {
  return new (t || _NbFilterDirective)();
};
_NbFilterDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFilterDirective,
  selectors: [["", "nbFilter", ""]],
  inputs: {
    filterable: [InputFlags.None, "nbFilter", "filterable"]
  }
});
var NbFilterDirective = _NbFilterDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFilterDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFilter]"
    }]
  }], null, {
    filterable: [{
      type: Input,
      args: ["nbFilter"]
    }]
  });
})();
var _NbFilterInputDirective = class _NbFilterInputDirective extends NbFilterDirective {
  constructor() {
    super(...arguments);
    this.search$ = new Subject();
    this.destroy$ = new Subject();
    this.debounceTime = 200;
  }
  ngOnInit() {
    this.search$.pipe(debounceTime(this.debounceTime), takeUntil(this.destroy$)).subscribe((query) => {
      super.filter(query);
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.search$.complete();
  }
  filter(event) {
    this.search$.next(event.target.value);
  }
};
_NbFilterInputDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFilterInputDirective_BaseFactory;
  return function NbFilterInputDirective_Factory(t) {
    return (ɵNbFilterInputDirective_BaseFactory || (ɵNbFilterInputDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFilterInputDirective)))(t || _NbFilterInputDirective);
  };
})();
_NbFilterInputDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFilterInputDirective,
  selectors: [["", "nbFilterInput", ""]],
  hostBindings: function NbFilterInputDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("input", function NbFilterInputDirective_input_HostBindingHandler($event) {
        return ctx.filter($event);
      });
    }
  },
  inputs: {
    filterable: [InputFlags.None, "nbFilterInput", "filterable"],
    debounceTime: "debounceTime"
  },
  features: [ɵɵProvidersFeature([{
    provide: NbFilterDirective,
    useExisting: _NbFilterInputDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbFilterInputDirective = _NbFilterInputDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFilterInputDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFilterInput]",
      providers: [{
        provide: NbFilterDirective,
        useExisting: NbFilterInputDirective
      }]
    }]
  }], null, {
    filterable: [{
      type: Input,
      args: ["nbFilterInput"]
    }],
    debounceTime: [{
      type: Input
    }],
    filter: [{
      type: HostListener,
      args: ["input", ["$event"]]
    }]
  });
})();
var _NbTreeGridRowToggleDirective = class _NbTreeGridRowToggleDirective {
  toggleRow($event) {
    this.cell.toggleRow();
    $event.stopPropagation();
  }
  constructor(cell) {
    this.cell = cell;
  }
};
_NbTreeGridRowToggleDirective.ɵfac = function NbTreeGridRowToggleDirective_Factory(t) {
  return new (t || _NbTreeGridRowToggleDirective)(ɵɵdirectiveInject(NbTreeGridCellDirective));
};
_NbTreeGridRowToggleDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridRowToggleDirective,
  selectors: [["", "nbTreeGridRowToggle", ""]],
  hostBindings: function NbTreeGridRowToggleDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbTreeGridRowToggleDirective_click_HostBindingHandler($event) {
        return ctx.toggleRow($event);
      });
    }
  }
});
var NbTreeGridRowToggleDirective = _NbTreeGridRowToggleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowToggleDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridRowToggle]"
    }]
  }], () => [{
    type: NbTreeGridCellDirective
  }], {
    toggleRow: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _NbTreeGridRowToggleComponent = class _NbTreeGridRowToggleComponent {
  set expanded(value) {
    this.expandedValue = value;
  }
  get expanded() {
    return this.expandedValue;
  }
  toggleRow($event) {
    this.cell.toggleRow();
    $event.stopPropagation();
  }
  constructor(cell) {
    this.cell = cell;
  }
};
_NbTreeGridRowToggleComponent.ɵfac = function NbTreeGridRowToggleComponent_Factory(t) {
  return new (t || _NbTreeGridRowToggleComponent)(ɵɵdirectiveInject(NbTreeGridCellDirective));
};
_NbTreeGridRowToggleComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTreeGridRowToggleComponent,
  selectors: [["nb-tree-grid-row-toggle"]],
  hostBindings: function NbTreeGridRowToggleComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbTreeGridRowToggleComponent_click_HostBindingHandler($event) {
        return ctx.toggleRow($event);
      });
    }
  },
  inputs: {
    expanded: "expanded"
  },
  decls: 2,
  vars: 2,
  consts: [[1, "row-toggle-button"], ["pack", "nebular-essentials", "aria-hidden", "true", 3, "icon"]],
  template: function NbTreeGridRowToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵelement(1, "nb-icon", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.expanded ? "collapse" : "expand");
      ɵɵadvance();
      ɵɵproperty("icon", ctx.expanded ? "chevron-down-outline" : "chevron-right-outline");
    }
  },
  dependencies: [NbIconComponent],
  styles: ["button[_ngcontent-%COMP%]{background:transparent;border:none;padding:0}"]
});
var NbTreeGridRowToggleComponent = _NbTreeGridRowToggleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowToggleComponent, [{
    type: Component,
    args: [{
      selector: "nb-tree-grid-row-toggle",
      template: `
    <button class="row-toggle-button" [attr.aria-label]="expanded ? 'collapse' : 'expand'">
      <nb-icon [icon]="expanded ? 'chevron-down-outline' : 'chevron-right-outline'"
               pack="nebular-essentials"
               aria-hidden="true">
      </nb-icon>
    </button>
  `,
      styles: ["button{background:transparent;border:none;padding:0}\n"]
    }]
  }], () => [{
    type: NbTreeGridCellDirective
  }], {
    expanded: [{
      type: Input
    }],
    toggleRow: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var COMPONENTS = [
  // Tree Grid
  NbTreeGridComponent,
  NbTreeGridRowDefDirective,
  NbTreeGridRowComponent,
  NbTreeGridCellDefDirective,
  NbTreeGridCellDirective,
  NbTreeGridHeaderRowDefDirective,
  NbTreeGridHeaderRowComponent,
  NbTreeGridHeaderCellDefDirective,
  NbTreeGridHeaderCellDirective,
  NbTreeGridFooterRowDefDirective,
  NbTreeGridFooterRowComponent,
  NbTreeGridFooterCellDefDirective,
  NbTreeGridFooterCellDirective,
  NbTreeGridColumnDefDirective,
  // Sort directives
  NbSortDirective,
  NbSortHeaderComponent,
  NbSortIconComponent,
  // Filter directives
  NbFilterDirective,
  NbFilterInputDirective,
  NbTreeGridRowToggleDirective,
  NbTreeGridRowToggleComponent,
  NbSortHeaderIconDirective
];
var _NbTreeGridModule = class _NbTreeGridModule {
};
_NbTreeGridModule.ɵfac = function NbTreeGridModule_Factory(t) {
  return new (t || _NbTreeGridModule)();
};
_NbTreeGridModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTreeGridModule,
  declarations: [
    // Tree Grid
    NbTreeGridComponent,
    NbTreeGridRowDefDirective,
    NbTreeGridRowComponent,
    NbTreeGridCellDefDirective,
    NbTreeGridCellDirective,
    NbTreeGridHeaderRowDefDirective,
    NbTreeGridHeaderRowComponent,
    NbTreeGridHeaderCellDefDirective,
    NbTreeGridHeaderCellDirective,
    NbTreeGridFooterRowDefDirective,
    NbTreeGridFooterRowComponent,
    NbTreeGridFooterCellDefDirective,
    NbTreeGridFooterCellDirective,
    NbTreeGridColumnDefDirective,
    // Sort directives
    NbSortDirective,
    NbSortHeaderComponent,
    NbSortIconComponent,
    // Filter directives
    NbFilterDirective,
    NbFilterInputDirective,
    NbTreeGridRowToggleDirective,
    NbTreeGridRowToggleComponent,
    NbSortHeaderIconDirective
  ],
  imports: [CommonModule, NbTableModule, NbIconModule],
  exports: [
    NbTableModule,
    // Tree Grid
    NbTreeGridComponent,
    NbTreeGridRowDefDirective,
    NbTreeGridRowComponent,
    NbTreeGridCellDefDirective,
    NbTreeGridCellDirective,
    NbTreeGridHeaderRowDefDirective,
    NbTreeGridHeaderRowComponent,
    NbTreeGridHeaderCellDefDirective,
    NbTreeGridHeaderCellDirective,
    NbTreeGridFooterRowDefDirective,
    NbTreeGridFooterRowComponent,
    NbTreeGridFooterCellDefDirective,
    NbTreeGridFooterCellDirective,
    NbTreeGridColumnDefDirective,
    // Sort directives
    NbSortDirective,
    NbSortHeaderComponent,
    NbSortIconComponent,
    // Filter directives
    NbFilterDirective,
    NbFilterInputDirective,
    NbTreeGridRowToggleDirective,
    NbTreeGridRowToggleComponent,
    NbSortHeaderIconDirective
  ]
});
_NbTreeGridModule.ɵinj = ɵɵdefineInjector({
  providers: [NbTreeGridSortService, NbTreeGridFilterService, NbTreeGridService, NbTreeGridDataService, NbTreeGridDataSourceBuilder],
  imports: [CommonModule, NbTableModule, NbIconModule, NbTableModule]
});
var NbTreeGridModule = _NbTreeGridModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbTableModule, NbIconModule],
      declarations: [...COMPONENTS],
      exports: [NbTableModule, ...COMPONENTS],
      providers: [NbTreeGridSortService, NbTreeGridFilterService, NbTreeGridService, NbTreeGridDataService, NbTreeGridDataSourceBuilder]
    }]
  }], null, null);
})();
var _NbToggleComponent = class _NbToggleComponent {
  /**
   * Toggle checked
   * @type {boolean}
   */
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._checked = convertToBoolProperty(value);
  }
  /**
   * Controls input disabled state
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get info() {
    return this.status === "info";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  get labelLeft() {
    return this.labelPosition === "left";
  }
  get labelRight() {
    return this.labelPosition === "right";
  }
  get labelStart() {
    return this.labelPosition === "start";
  }
  get labelEnd() {
    return this.labelPosition === "end";
  }
  constructor(changeDetector, layoutDirection, renderer, hostElement, zone, statusService) {
    this.changeDetector = changeDetector;
    this.layoutDirection = layoutDirection;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.zone = zone;
    this.statusService = statusService;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.destroy$ = new Subject();
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this.labelPosition = "end";
    this.checkedChange = new EventEmitter();
  }
  ngOnInit() {
    this.layoutDirection.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe(() => this.changeDetector.detectChanges());
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  checkState() {
    if (this.checked) {
      return this.layoutDirection.isLtr() ? "right" : "left";
    }
    return this.layoutDirection.isLtr() ? "left" : "right";
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(val) {
    this.checked = val;
    this.changeDetector.markForCheck();
  }
  setDisabledState(val) {
    this.disabled = convertToBoolProperty(val);
    this.changeDetector.markForCheck();
  }
  updateValue(event) {
    const input = event.target;
    this.checked = input.checked;
    this.checkedChange.emit(this.checked);
    this.onChange(this.checked);
  }
  onInputClick(event) {
    event.stopPropagation();
  }
};
_NbToggleComponent.ɵfac = function NbToggleComponent_Factory(t) {
  return new (t || _NbToggleComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbToggleComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbToggleComponent,
  selectors: [["nb-toggle"]],
  hostVars: 24,
  hostBindings: function NbToggleComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control)("toggle-label-left", ctx.labelLeft)("toggle-label-right", ctx.labelRight)("toggle-label-start", ctx.labelStart)("toggle-label-end", ctx.labelEnd);
    }
  },
  inputs: {
    checked: "checked",
    disabled: "disabled",
    status: "status",
    labelPosition: "labelPosition"
  },
  outputs: {
    checkedChange: "checkedChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbToggleComponent),
    multi: true
  }])],
  ngContentSelectors: _c03,
  decls: 7,
  vars: 7,
  consts: [[1, "toggle-label"], ["type", "checkbox", "role", "switch", 1, "native-input", "visually-hidden", 3, "change", "blur", "click", "disabled", "checked"], [1, "toggle"], [1, "toggle-switcher"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "text"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials"]],
  template: function NbToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "label", 0)(1, "input", 1);
      ɵɵlistener("change", function NbToggleComponent_Template_input_change_1_listener($event) {
        return ctx.updateValue($event);
      })("blur", function NbToggleComponent_Template_input_blur_1_listener() {
        return ctx.onTouched();
      })("click", function NbToggleComponent_Template_input_click_1_listener($event) {
        return ctx.onInputClick($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(2, "div", 2)(3, "span", 3);
      ɵɵtemplate(4, NbToggleComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
      ɵɵelementEnd()();
      ɵɵelementStart(5, "span", 5);
      ɵɵprojection(6);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("disabled", ctx.disabled)("checked", ctx.checked);
      ɵɵattribute("aria-checked", ctx.checked);
      ɵɵadvance();
      ɵɵclassProp("checked", ctx.checked);
      ɵɵadvance();
      ɵɵproperty("@position", ctx.checkState());
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.checked);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:inline-flex;outline:none}.toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}[dir=ltr]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}[dir=rtl]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}.toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=ltr]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}[dir=rtl]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}.toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]{flex-direction:row-reverse}[dir=ltr]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}[dir=rtl]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=ltr]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=rtl]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}.nb-transition[_nghost-%COMP%]   .toggle[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center}.toggle[_ngcontent-%COMP%]{position:relative;display:inline-flex;box-sizing:content-box}.toggle-switcher[_ngcontent-%COMP%]{position:absolute;border-radius:50%;margin:1px}.toggle-switcher[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}"],
  data: {
    animation: [trigger("position", [state("right", style({
      right: 0,
      left: "*"
    })), state("left", style({
      left: 0,
      right: "*"
    })), transition(":enter", [animate(0)]), transition("right <=> left", [animate("0.15s")])])]
  },
  changeDetection: 0
});
var NbToggleComponent = _NbToggleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToggleComponent, [{
    type: Component,
    args: [{
      selector: "nb-toggle",
      animations: [trigger("position", [state("right", style({
        right: 0,
        left: "*"
      })), state("left", style({
        left: 0,
        right: "*"
      })), transition(":enter", [animate(0)]), transition("right <=> left", [animate("0.15s")])])],
      template: `
    <label class="toggle-label">
      <input type="checkbox"
             class="native-input visually-hidden"
             role="switch"
             [attr.aria-checked]="checked"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValue($event)"
             (blur)="onTouched()"
             (click)="onInputClick($event)">
      <div class="toggle" [class.checked]="checked">
        <span [@position]="checkState()" class="toggle-switcher">
          <nb-icon *ngIf="checked" icon="checkmark-bold-outline" pack="nebular-essentials"></nb-icon>
        </span>
      </div>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbToggleComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:inline-flex;outline:none}:host(.toggle-label-left) .text:not(:empty){padding-right:.6875rem}[dir=ltr] :host(.toggle-label-left) .text:not(:empty){order:-1}[dir=rtl] :host(.toggle-label-left) .text:not(:empty){order:1}:host(.toggle-label-right) .text:not(:empty){padding-left:.6875rem}[dir=ltr] :host(.toggle-label-right) .text:not(:empty){order:1}[dir=rtl] :host(.toggle-label-right) .text:not(:empty){order:-1}:host(.toggle-label-start) .toggle-label{flex-direction:row-reverse}[dir=ltr] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-right:.6875rem}[dir=rtl] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-left:.6875rem}[dir=ltr] :host(.toggle-label-end) .text:not(:empty){padding-left:.6875rem}[dir=rtl] :host(.toggle-label-end) .text:not(:empty){padding-right:.6875rem}:host(.nb-transition) .toggle{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-label{position:relative;display:inline-flex;align-items:center}.toggle{position:relative;display:inline-flex;box-sizing:content-box}.toggle-switcher{position:absolute;border-radius:50%;margin:1px}.toggle-switcher nb-icon{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    labelPosition: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    labelLeft: [{
      type: HostBinding,
      args: ["class.toggle-label-left"]
    }],
    labelRight: [{
      type: HostBinding,
      args: ["class.toggle-label-right"]
    }],
    labelStart: [{
      type: HostBinding,
      args: ["class.toggle-label-start"]
    }],
    labelEnd: [{
      type: HostBinding,
      args: ["class.toggle-label-end"]
    }]
  });
})();
var _NbToggleModule = class _NbToggleModule {
};
_NbToggleModule.ɵfac = function NbToggleModule_Factory(t) {
  return new (t || _NbToggleModule)();
};
_NbToggleModule.ɵmod = ɵɵdefineNgModule({
  type: _NbToggleModule,
  declarations: [NbToggleComponent],
  imports: [CommonModule, NbIconModule],
  exports: [NbToggleComponent]
});
_NbToggleModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbIconModule]
});
var NbToggleModule = _NbToggleModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToggleModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      declarations: [NbToggleComponent],
      exports: [NbToggleComponent]
    }]
  }], null, null);
})();

export {
  NB_THEME_OPTIONS,
  NB_MEDIA_BREAKPOINTS,
  NB_BUILT_IN_JS_THEMES,
  NB_JS_THEMES,
  NB_WINDOW,
  NB_DOCUMENT,
  DEFAULT_MEDIA_BREAKPOINTS,
  NbMediaBreakpointsService,
  DEFAULT_THEME,
  COSMIC_THEME,
  CORPORATE_THEME,
  DARK_THEME,
  BUILT_IN_THEMES,
  NbJSThemesRegistry,
  NbThemeService,
  NbSpinnerService,
  NbLayoutDirection,
  NB_LAYOUT_DIRECTION,
  NbLayoutDirectionService,
  NbLayoutScrollService,
  NbLayoutRulerService,
  NbFocusTrap,
  NbFocusTrapFactoryService,
  NbFocusKeyManager,
  NbFocusKeyManagerFactoryService,
  NbFocusMonitor,
  NbA11yModule,
  NbPortalDirective,
  NbPortalOutletDirective,
  NbComponentPortal,
  NbOverlay,
  NbOverlayPositionBuilder,
  NbTemplatePortal,
  NbOverlayContainer,
  NbFlexibleConnectedPositionStrategy,
  NbPortalInjector,
  NbCdkMappingModule,
  NbGlobalLogicalPosition,
  NbGlobalPhysicalPosition,
  NbPositionHelper,
  NbPlatform,
  NbViewportRulerAdapter,
  NbOverlayContainerAdapter,
  NbAdjustment,
  NbPosition,
  NbAdjustableConnectedPositionStrategy,
  NbGlobalPositionStrategy,
  NbPositionBuilderService,
  NbPositionedContainerComponent,
  NbOverlayContainerComponent,
  patch,
  createContainer,
  NbOverlayService,
  NbScrollDispatcherAdapter,
  NbBlockScrollStrategyAdapter,
  NbScrollStrategyOptions,
  NbCdkAdapterModule,
  NbTrigger,
  NbTriggerStrategyBase,
  NbClickTriggerStrategy,
  NbHoverTriggerStrategy,
  NbHintTriggerStrategy,
  NbFocusTriggerStrategy,
  NbNoopTriggerStrategy,
  NbTriggerStrategyBuilderService,
  NbOverlayModule,
  NbStatusService,
  windowFactory,
  NbThemeModule,
  NbColorHelper,
  NbIconPackType,
  NbFontIcon,
  NbSvgIcon,
  NbIconDefinition,
  NbIconLibraries,
  NbIconComponent,
  NbIconModule,
  NbCardHeaderComponent,
  NbCardBodyComponent,
  NbCardFooterComponent,
  NbCardComponent,
  NbRevealCardComponent,
  NbFlipCardComponent,
  NbCardFrontComponent,
  NbCardBackComponent,
  NbCardModule,
  NbCalendarViewMode,
  NbCalendarSize,
  NbDateService,
  NbCalendarYearModelService,
  NbButton,
  NbButtonComponent,
  NbCalendarViewModeComponent,
  NbCalendarPageableNavigationComponent,
  NbCalendarYearCellComponent,
  NbCalendarPickerRowComponent,
  NbCalendarPickerComponent,
  NbCalendarYearPickerComponent,
  NbCalendarMonthCellComponent,
  MONTHS_IN_VIEW,
  MONTHS_IN_COLUMN,
  NbCalendarMonthPickerComponent,
  NbCalendarDayCellComponent,
  NbCalendarMonthModelService,
  NbCalendarDaysNamesComponent,
  NbCalendarWeekNumberComponent,
  NbCalendarDayPickerComponent,
  NbBaseCalendarComponent,
  NbCalendarComponent,
  NbButtonModule,
  NbNativeDateService,
  NbCalendarTimeModelService,
  NbCalendarActionsComponent,
  NbCalendarKitModule,
  NbBaseCalendarModule,
  NbCalendarModule,
  NbBaseCalendarRangeCell,
  NbCalendarRangeDayCellComponent,
  NbCalendarRangeYearCellComponent,
  NbCalendarRangeMonthCellComponent,
  NbCalendarRangeComponent,
  NbCalendarRangeModule,
  NB_TIME_PICKER_CONFIG,
  NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG,
  NbListComponent,
  NbListItemComponent,
  NbTimePickerCellComponent,
  NbTimePickerComponent,
  NbCalendarWithTimeComponent,
  NbDatepickerContainerComponent,
  NbDatepickerAdapter,
  NbDatepicker,
  NB_DATE_ADAPTER,
  NB_DATE_SERVICE_OPTIONS,
  NbDatepickerDirective,
  NbBasePicker,
  NbBasePickerComponent,
  NbDatepickerComponent,
  NbRangepickerComponent,
  NbDateTimePickerComponent,
  NbRestoreScrollTopHelper,
  NbLayoutComponent,
  NbLayoutColumnComponent,
  NbLayoutHeaderComponent,
  NbLayoutFooterComponent,
  NbLtrDirective,
  NbRtlDirective,
  NbLayoutModule,
  NbMenuItem,
  NbMenuService,
  NbBadgeComponent,
  NbToggleStates,
  NbMenuItemComponent,
  NbMenuComponent,
  NbBadgeModule,
  NbMenuModule,
  NbRouteTabsetComponent,
  NbRouteTabsetModule,
  NbSidebarService,
  NbSidebarHeaderComponent,
  NbSidebarFooterComponent,
  NbSidebarComponent,
  NbSidebarModule,
  NbTabContentDirective,
  NbTabTitleDirective,
  NbTabComponent,
  NbTabsetComponent,
  NbTabsetModule,
  NbUserComponent,
  NbUserModule,
  NbActionComponent,
  NbActionsComponent,
  NbActionsModule,
  NbSearchService,
  NbSearchFieldComponent,
  NbSearchComponent,
  NbSearchModule,
  NbCheckboxComponent,
  NbCheckboxModule,
  NbDynamicOverlay,
  NbDynamicOverlayChange,
  NbDynamicOverlayHandler,
  NbPopoverComponent,
  NbPopoverDirective,
  NbPopoverModule,
  NbContextMenuComponent,
  NbContextMenuDirective,
  NbContextMenuModule,
  NbProgressBarComponent,
  NbProgressBarModule,
  NbAlertComponent,
  NbAlertModule,
  NbFormFieldControl,
  NbFormFieldControlConfig,
  NbInputDirective,
  NbChatFormComponent,
  NbChatCustomMessageService,
  NbChatMessageTextComponent,
  NbChatMessageFileComponent,
  NbChatMessageQuoteComponent,
  NbChatOptions,
  NbChatMessageMapComponent,
  NbChatAvatarComponent,
  NbChatMessageComponent,
  NbChatTitleDirective,
  NbChatComponent,
  NbInputModule,
  NbChatCustomMessageDirective,
  NbChatModule,
  NbSpinnerComponent,
  NbSpinnerDirective,
  NbSpinnerModule,
  NB_STEPPER,
  NbStepComponent,
  NbStepperComponent,
  NbStepperNextDirective,
  NbStepperPreviousDirective,
  NbStepperModule,
  NbAccordionComponent,
  NbAccordionItemComponent,
  NbAccordionItemBodyComponent,
  NbAccordionItemHeaderComponent,
  NbAccordionModule,
  NB_BUTTON_GROUP,
  NbButtonToggleDirective,
  NbButtonGroupComponent,
  NbButtonGroupModule,
  NbListPageTrackerDirective,
  NbScrollableContainerDimensions,
  NbInfiniteListDirective,
  NbListModule,
  NbDirectionality,
  NbBidiModule,
  NbCellDefDirective,
  NbHeaderCellDefDirective,
  NbFooterCellDefDirective,
  NB_SORT_HEADER_COLUMN_DEF,
  NbColumnDefDirective,
  NbHeaderCellDirective,
  NbFooterCellDirective,
  NbCellDirective,
  NbDataSource,
  NbDataRowOutletDirective,
  NbHeaderRowOutletDirective,
  NbFooterRowOutletDirective,
  NbNoDataRowOutletDirective,
  NbCellOutletDirective,
  NbHeaderRowDefDirective,
  NbFooterRowDefDirective,
  NbRowDefDirective,
  NbHeaderRowComponent,
  NbFooterRowComponent,
  NbRowComponent,
  NB_TABLE_TEMPLATE,
  NB_VIEW_REPEATER_STRATEGY,
  NB_COALESCED_STYLE_SCHEDULER,
  NB_TABLE_PROVIDERS,
  NbTable,
  NbTableModule,
  NB_DIALOG_CONFIG,
  NbDialogConfig,
  NbDialogRef,
  NbDialogContainerComponent,
  NbDialogService,
  NbDialogModule,
  NbToastComponent,
  NbToastrContainerComponent,
  NB_TOASTR_CONFIG,
  NbToastrConfig,
  NbToastRef,
  NbToastContainer,
  NbToastrContainerRegistry,
  NbToastrService,
  NbToastrModule,
  NbToast,
  NbTooltipComponent,
  NbTooltipDirective,
  NbTooltipModule,
  NB_SELECT_INJECTION_TOKEN,
  NbOptionComponent,
  NbOptionListComponent,
  NbSelectLabelComponent,
  nbSelectFormFieldControlConfigFactory,
  NbSelectComponent,
  NbOptionGroupComponent,
  NbOptionModule,
  NbSelectModule,
  NbPrefixDirective,
  NbSuffixDirective,
  NbFormFieldComponent,
  NbSelectWithAutocompleteComponent,
  NbFormFieldModule,
  NbSelectWithAutocompleteModule,
  NbAutocompleteComponent,
  NbAutocompleteDirective,
  NbAutocompleteModule,
  NbWindowState,
  NB_WINDOW_DEFAULT_BUTTONS_CONFIG,
  NbWindowConfig,
  NB_WINDOW_CONTENT,
  NB_WINDOW_CONFIG,
  NB_WINDOW_CONTEXT,
  NbWindowRef,
  NbWindowsContainerComponent,
  NbWindowComponent,
  NbWindowService,
  NbWindowModule,
  NbTimePickerDirective,
  NbTimepickerModule,
  NbDateAdapterService,
  NbRangeAdapterService,
  NbDateTimeAdapterService,
  NbDatepickerModule,
  NbRadioComponent,
  NbRadioGroupComponent,
  NbRadioModule,
  NbTagComponent,
  NbTagInputDirective,
  NbTagListComponent,
  NbTagModule,
  NB_DEFAULT_ROW_LEVEL,
  NbTreeGridPresentationNode,
  NbTreeGridFilterService,
  NbSortDirection,
  NbSortDirective,
  NbSortHeaderIconDirective,
  NbSortIconComponent,
  NbSortHeaderComponent,
  NbTreeGridSortService,
  NbTreeGridService,
  NbTreeGridDataService,
  NbTreeGridDataSource,
  NbTreeGridDataSourceBuilder,
  NB_TREE_GRID,
  NbColumnsService,
  NbTreeGridComponent,
  NbTreeGridRowDefDirective,
  NbTreeGridHeaderRowDefDirective,
  NbTreeGridFooterRowDefDirective,
  NbTreeGridCellDefDirective,
  NbTreeGridHeaderCellDefDirective,
  NbTreeGridFooterCellDefDirective,
  NB_ROW_DOUBLE_CLICK_DELAY,
  NbTreeGridRowComponent,
  NbTreeGridHeaderRowComponent,
  NbTreeGridFooterRowComponent,
  NbTreeGridColumnDefDirective,
  NbTreeGridCellDirective,
  NbTreeGridHeaderCellDirective,
  NbTreeGridFooterCellDirective,
  NbFilterDirective,
  NbFilterInputDirective,
  NbTreeGridRowToggleDirective,
  NbTreeGridRowToggleComponent,
  NbTreeGridModule,
  NbToggleComponent,
  NbToggleModule
};
/*! Bundled license information:

@nebular/theme/fesm2022/nebular-theme.mjs:
  (**
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)

@nebular/theme/fesm2022/nebular-theme.mjs:
  (*
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)
  (**
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)
  (*
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license infornbion.
   *)
*/
//# sourceMappingURL=chunk-3BBPLQMJ.js.map
